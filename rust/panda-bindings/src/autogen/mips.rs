/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const __GNUC_VA_LIST: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _DYNAMIC_STACK_SIZE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_DYNAMIC_STACK_SIZE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const L_cuserid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _PRINTF_NAN_LEN_MAX: u32 = 4;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const CHAR_WIDTH: u32 = 8;
pub const SCHAR_WIDTH: u32 = 8;
pub const UCHAR_WIDTH: u32 = 8;
pub const SHRT_WIDTH: u32 = 16;
pub const USHRT_WIDTH: u32 = 16;
pub const INT_WIDTH: u32 = 32;
pub const UINT_WIDTH: u32 = 32;
pub const LONG_WIDTH: u32 = 64;
pub const ULONG_WIDTH: u32 = 64;
pub const LLONG_WIDTH: u32 = 64;
pub const ULLONG_WIDTH: u32 = 64;
pub const BOOL_MAX: u32 = 1;
pub const BOOL_WIDTH: u32 = 1;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_FD_SETSIZE: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_QLIMIT: u32 = 1;
pub const _POSIX_HIWAT: u32 = 512;
pub const _POSIX_UIO_MAXIOV: u32 = 16;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const __SC_THREAD_STACK_MIN_VALUE: u32 = 75;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _XOPEN_LIM_H: u32 = 1;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const IOV_MAX: u32 = 1024;
pub const NL_ARGMAX: u32 = 4096;
pub const NL_LANGMAX: u32 = 2048;
pub const NZERO: u32 = 20;
pub const WORD_BIT: u32 = 32;
pub const LONG_BIT: u32 = 64;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48] = b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const CLOSE_RANGE_UNSHARE: u32 = 2;
pub const CLOSE_RANGE_CLOEXEC: u32 = 4;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const _BITS_TIMEX_H: u32 = 1;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 32769;
pub const ADJ_OFFSET_SS_READ: u32 = 40961;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_CLKB: u32 = 16384;
pub const MOD_CLKA: u32 = 32769;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _CTYPE_H: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const __error_t_defined: u32 = 1;
pub const _FCNTL_H: u32 = 1;
pub const __O_LARGEFILE: u32 = 0;
pub const F_GETLK64: u32 = 5;
pub const F_SETLK64: u32 = 6;
pub const F_SETLKW64: u32 = 7;
pub const __iovec_defined: u32 = 1;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_NDELAY: u32 = 2048;
pub const O_SYNC: u32 = 1052672;
pub const O_FSYNC: u32 = 1052672;
pub const O_ASYNC: u32 = 8192;
pub const __O_DIRECTORY: u32 = 65536;
pub const __O_NOFOLLOW: u32 = 131072;
pub const __O_CLOEXEC: u32 = 524288;
pub const __O_DIRECT: u32 = 16384;
pub const __O_NOATIME: u32 = 262144;
pub const __O_PATH: u32 = 2097152;
pub const __O_DSYNC: u32 = 4096;
pub const __O_TMPFILE: u32 = 4259840;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const F_OFD_GETLK: u32 = 36;
pub const F_OFD_SETLK: u32 = 37;
pub const F_OFD_SETLKW: u32 = 38;
pub const O_LARGEFILE: u32 = 0;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_DIRECT: u32 = 16384;
pub const O_NOATIME: u32 = 262144;
pub const O_PATH: u32 = 2097152;
pub const O_TMPFILE: u32 = 4259840;
pub const O_DSYNC: u32 = 4096;
pub const O_RSYNC: u32 = 1052672;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const __F_SETOWN: u32 = 8;
pub const __F_GETOWN: u32 = 9;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const __F_SETSIG: u32 = 10;
pub const __F_GETSIG: u32 = 11;
pub const __F_SETOWN_EX: u32 = 15;
pub const __F_GETOWN_EX: u32 = 16;
pub const F_SETSIG: u32 = 10;
pub const F_GETSIG: u32 = 11;
pub const F_SETOWN_EX: u32 = 15;
pub const F_GETOWN_EX: u32 = 16;
pub const F_SETLEASE: u32 = 1024;
pub const F_GETLEASE: u32 = 1025;
pub const F_NOTIFY: u32 = 1026;
pub const F_SETPIPE_SZ: u32 = 1031;
pub const F_GETPIPE_SZ: u32 = 1032;
pub const F_ADD_SEALS: u32 = 1033;
pub const F_GET_SEALS: u32 = 1034;
pub const F_GET_RW_HINT: u32 = 1035;
pub const F_SET_RW_HINT: u32 = 1036;
pub const F_GET_FILE_RW_HINT: u32 = 1037;
pub const F_SET_FILE_RW_HINT: u32 = 1038;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const LOCK_MAND: u32 = 32;
pub const LOCK_READ: u32 = 64;
pub const LOCK_WRITE: u32 = 128;
pub const LOCK_RW: u32 = 192;
pub const DN_ACCESS: u32 = 1;
pub const DN_MODIFY: u32 = 2;
pub const DN_CREATE: u32 = 4;
pub const DN_DELETE: u32 = 8;
pub const DN_RENAME: u32 = 16;
pub const DN_ATTRIB: u32 = 32;
pub const DN_MULTISHOT: u32 = 2147483648;
pub const F_SEAL_SEAL: u32 = 1;
pub const F_SEAL_SHRINK: u32 = 2;
pub const F_SEAL_GROW: u32 = 4;
pub const F_SEAL_WRITE: u32 = 8;
pub const F_SEAL_FUTURE_WRITE: u32 = 16;
pub const RWH_WRITE_LIFE_NOT_SET: u32 = 0;
pub const RWF_WRITE_LIFE_NOT_SET: u32 = 0;
pub const RWH_WRITE_LIFE_NONE: u32 = 1;
pub const RWH_WRITE_LIFE_SHORT: u32 = 2;
pub const RWH_WRITE_LIFE_MEDIUM: u32 = 3;
pub const RWH_WRITE_LIFE_LONG: u32 = 4;
pub const RWH_WRITE_LIFE_EXTREME: u32 = 5;
pub const FAPPEND: u32 = 1024;
pub const FFSYNC: u32 = 1052672;
pub const FASYNC: u32 = 8192;
pub const FNONBLOCK: u32 = 2048;
pub const FNDELAY: u32 = 2048;
pub const __POSIX_FADV_DONTNEED: u32 = 4;
pub const __POSIX_FADV_NOREUSE: u32 = 5;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const SYNC_FILE_RANGE_WAIT_BEFORE: u32 = 1;
pub const SYNC_FILE_RANGE_WRITE: u32 = 2;
pub const SYNC_FILE_RANGE_WAIT_AFTER: u32 = 4;
pub const SYNC_FILE_RANGE_WRITE_AND_WAIT: u32 = 7;
pub const SPLICE_F_MOVE: u32 = 1;
pub const SPLICE_F_NONBLOCK: u32 = 2;
pub const SPLICE_F_MORE: u32 = 4;
pub const SPLICE_F_GIFT: u32 = 8;
pub const FALLOC_FL_KEEP_SIZE: u32 = 1;
pub const FALLOC_FL_PUNCH_HOLE: u32 = 2;
pub const FALLOC_FL_NO_HIDE_STALE: u32 = 4;
pub const FALLOC_FL_COLLAPSE_RANGE: u32 = 8;
pub const FALLOC_FL_ZERO_RANGE: u32 = 16;
pub const FALLOC_FL_INSERT_RANGE: u32 = 32;
pub const FALLOC_FL_UNSHARE_RANGE: u32 = 64;
pub const MAX_HANDLE_SZ: u32 = 128;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_NO_AUTOMOUNT: u32 = 2048;
pub const AT_EMPTY_PATH: u32 = 4096;
pub const AT_STATX_SYNC_TYPE: u32 = 24576;
pub const AT_STATX_SYNC_AS_STAT: u32 = 0;
pub const AT_STATX_FORCE_SYNC: u32 = 8192;
pub const AT_STATX_DONT_SYNC: u32 = 16384;
pub const AT_RECURSIVE: u32 = 32768;
pub const AT_EACCESS: u32 = 512;
pub const _BITS_STAT_H: u32 = 1;
pub const _BITS_STRUCT_STAT_H: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const _GETOPT_H: u32 = 1;
pub const _GETOPT_EXT_H: u32 = 1;
pub const no_argument: u32 = 0;
pub const required_argument: u32 = 1;
pub const optional_argument: u32 = 2;
pub const _NETINET_IN_H: u32 = 1;
pub const _SYS_SOCKET_H: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MCTP: u32 = 45;
pub const PF_MAX: u32 = 46;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MCTP: u32 = 45;
pub const AF_MAX: u32 = 46;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const __BITS_PER_LONG: u32 = 64;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SO_NETNS_COOKIE: u32 = 71;
pub const SO_BUF_LOCK: u32 = 72;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_RECVERR_RFC4884: u32 = 26;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_RECVERR_RFC4884: u32 = 31;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _NETINET_TCP_H: u32 = 1;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_MAXSEG: u32 = 2;
pub const TCP_CORK: u32 = 3;
pub const TCP_KEEPIDLE: u32 = 4;
pub const TCP_KEEPINTVL: u32 = 5;
pub const TCP_KEEPCNT: u32 = 6;
pub const TCP_SYNCNT: u32 = 7;
pub const TCP_LINGER2: u32 = 8;
pub const TCP_DEFER_ACCEPT: u32 = 9;
pub const TCP_WINDOW_CLAMP: u32 = 10;
pub const TCP_INFO: u32 = 11;
pub const TCP_QUICKACK: u32 = 12;
pub const TCP_CONGESTION: u32 = 13;
pub const TCP_MD5SIG: u32 = 14;
pub const TCP_COOKIE_TRANSACTIONS: u32 = 15;
pub const TCP_THIN_LINEAR_TIMEOUTS: u32 = 16;
pub const TCP_THIN_DUPACK: u32 = 17;
pub const TCP_USER_TIMEOUT: u32 = 18;
pub const TCP_REPAIR: u32 = 19;
pub const TCP_REPAIR_QUEUE: u32 = 20;
pub const TCP_QUEUE_SEQ: u32 = 21;
pub const TCP_REPAIR_OPTIONS: u32 = 22;
pub const TCP_FASTOPEN: u32 = 23;
pub const TCP_TIMESTAMP: u32 = 24;
pub const TCP_NOTSENT_LOWAT: u32 = 25;
pub const TCP_CC_INFO: u32 = 26;
pub const TCP_SAVE_SYN: u32 = 27;
pub const TCP_SAVED_SYN: u32 = 28;
pub const TCP_REPAIR_WINDOW: u32 = 29;
pub const TCP_FASTOPEN_CONNECT: u32 = 30;
pub const TCP_ULP: u32 = 31;
pub const TCP_MD5SIG_EXT: u32 = 32;
pub const TCP_FASTOPEN_KEY: u32 = 33;
pub const TCP_FASTOPEN_NO_COOKIE: u32 = 34;
pub const TCP_ZEROCOPY_RECEIVE: u32 = 35;
pub const TCP_INQ: u32 = 36;
pub const TCP_CM_INQ: u32 = 36;
pub const TCP_TX_DELAY: u32 = 37;
pub const TCP_REPAIR_ON: u32 = 1;
pub const TCP_REPAIR_OFF: u32 = 0;
pub const TCP_REPAIR_OFF_NO_WP: i32 = -1;
pub const TH_FIN: u32 = 1;
pub const TH_SYN: u32 = 2;
pub const TH_RST: u32 = 4;
pub const TH_PUSH: u32 = 8;
pub const TH_ACK: u32 = 16;
pub const TH_URG: u32 = 32;
pub const TCPOPT_EOL: u32 = 0;
pub const TCPOPT_NOP: u32 = 1;
pub const TCPOPT_MAXSEG: u32 = 2;
pub const TCPOLEN_MAXSEG: u32 = 4;
pub const TCPOPT_WINDOW: u32 = 3;
pub const TCPOLEN_WINDOW: u32 = 3;
pub const TCPOPT_SACK_PERMITTED: u32 = 4;
pub const TCPOLEN_SACK_PERMITTED: u32 = 2;
pub const TCPOPT_SACK: u32 = 5;
pub const TCPOPT_TIMESTAMP: u32 = 8;
pub const TCPOLEN_TIMESTAMP: u32 = 10;
pub const TCPOLEN_TSTAMP_APPA: u32 = 12;
pub const TCPOPT_TSTAMP_HDR: u32 = 16844810;
pub const TCP_MSS: u32 = 512;
pub const TCP_MAXWIN: u32 = 65535;
pub const TCP_MAX_WINSHIFT: u32 = 14;
pub const SOL_TCP: u32 = 6;
pub const TCPI_OPT_TIMESTAMPS: u32 = 1;
pub const TCPI_OPT_SACK: u32 = 2;
pub const TCPI_OPT_WSCALE: u32 = 4;
pub const TCPI_OPT_ECN: u32 = 8;
pub const TCPI_OPT_ECN_SEEN: u32 = 16;
pub const TCPI_OPT_SYN_DATA: u32 = 32;
pub const TCP_MD5SIG_MAXKEYLEN: u32 = 80;
pub const TCP_MD5SIG_FLAG_PREFIX: u32 = 1;
pub const TCP_COOKIE_MIN: u32 = 8;
pub const TCP_COOKIE_MAX: u32 = 16;
pub const TCP_COOKIE_PAIR_SIZE: u32 = 32;
pub const TCP_COOKIE_IN_ALWAYS: u32 = 1;
pub const TCP_COOKIE_OUT_NEVER: u32 = 2;
pub const TCP_S_DATA_IN: u32 = 4;
pub const TCP_S_DATA_OUT: u32 = 8;
pub const TCP_MSS_DEFAULT: u32 = 536;
pub const TCP_MSS_DESIRED: u32 = 1220;
pub const _ARPA_INET_H: u32 = 1;
pub const _SYS_UN_H: u32 = 1;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_SYSMACROS_H: u32 = 1;
pub const _SEMAPHORE_H: u32 = 1;
pub const __SIZEOF_SEM_T: u32 = 32;
pub const _DLFCN_H: u32 = 1;
pub const RTLD_LAZY: u32 = 1;
pub const RTLD_NOW: u32 = 2;
pub const RTLD_BINDING_MASK: u32 = 3;
pub const RTLD_NOLOAD: u32 = 4;
pub const RTLD_DEEPBIND: u32 = 8;
pub const RTLD_GLOBAL: u32 = 256;
pub const RTLD_LOCAL: u32 = 0;
pub const RTLD_NODELETE: u32 = 4096;
pub const DLFO_STRUCT_HAS_EH_DBASE: u32 = 0;
pub const DLFO_STRUCT_HAS_EH_COUNT: u32 = 0;
pub const LM_ID_BASE: u32 = 0;
pub const LM_ID_NEWLM: i32 = -1;
pub const _NETDB_H: u32 = 1;
pub const _RPC_NETDB_H: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _PATH_HEQUIV: &[u8; 17] = b"/etc/hosts.equiv\0";
pub const _PATH_HOSTS: &[u8; 11] = b"/etc/hosts\0";
pub const _PATH_NETWORKS: &[u8; 14] = b"/etc/networks\0";
pub const _PATH_NSSWITCH_CONF: &[u8; 19] = b"/etc/nsswitch.conf\0";
pub const _PATH_PROTOCOLS: &[u8; 15] = b"/etc/protocols\0";
pub const _PATH_SERVICES: &[u8; 14] = b"/etc/services\0";
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const NO_ADDRESS: u32 = 4;
pub const SCOPE_DELIMITER: u8 = 37u8;
pub const GAI_WAIT: u32 = 0;
pub const GAI_NOWAIT: u32 = 1;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_V4MAPPED: u32 = 8;
pub const AI_ALL: u32 = 16;
pub const AI_ADDRCONFIG: u32 = 32;
pub const AI_IDN: u32 = 64;
pub const AI_CANONIDN: u32 = 128;
pub const AI_NUMERICSERV: u32 = 1024;
pub const EAI_BADFLAGS: i32 = -1;
pub const EAI_NONAME: i32 = -2;
pub const EAI_AGAIN: i32 = -3;
pub const EAI_FAIL: i32 = -4;
pub const EAI_FAMILY: i32 = -6;
pub const EAI_SOCKTYPE: i32 = -7;
pub const EAI_SERVICE: i32 = -8;
pub const EAI_MEMORY: i32 = -10;
pub const EAI_SYSTEM: i32 = -11;
pub const EAI_OVERFLOW: i32 = -12;
pub const EAI_NODATA: i32 = -5;
pub const EAI_ADDRFAMILY: i32 = -9;
pub const EAI_INPROGRESS: i32 = -100;
pub const EAI_CANCELED: i32 = -101;
pub const EAI_NOTCANCELED: i32 = -102;
pub const EAI_ALLDONE: i32 = -103;
pub const EAI_INTR: i32 = -104;
pub const EAI_IDN_ENCODE: i32 = -105;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NUMERICHOST: u32 = 1;
pub const NI_NUMERICSERV: u32 = 2;
pub const NI_NOFQDN: u32 = 4;
pub const NI_NAMEREQD: u32 = 8;
pub const NI_DGRAM: u32 = 16;
pub const NI_IDN: u32 = 32;
pub const _PWD_H: u32 = 1;
pub const NSS_BUFLEN_PASSWD: u32 = 1024;
pub const _ASSERT_H: u32 = 1;
pub const _SETJMP_H: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const _BITS_SIGNUM_ARCH_H: u32 = 1;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const SIGBUS: u32 = 7;
pub const SIGSYS: u32 = 31;
pub const SIGURG: u32 = 23;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGCONT: u32 = 18;
pub const SIGCHLD: u32 = 17;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 29;
pub const SIGXFSZ: u32 = 25;
pub const SIGXCPU: u32 = 24;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 10;
pub const SIGUSR2: u32 = 12;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGCLD: u32 = 17;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const _NSIG: u32 = 65;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_ARCH_H: u32 = 1;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 65;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const _SYS_UIO_H: u32 = 1;
pub const UIO_MAXIOV: u32 = 1024;
pub const _BITS_UIO_EXT_H: u32 = 1;
pub const RWF_HIPRI: u32 = 1;
pub const RWF_DSYNC: u32 = 2;
pub const RWF_SYNC: u32 = 4;
pub const RWF_NOWAIT: u32 = 8;
pub const RWF_APPEND: u32 = 16;
pub const _SYS_WAIT_H: u32 = 1;
pub const WCOREFLAG: u32 = 128;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _SYS_STAT_H: u32 = 1;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const STATX_TYPE: u32 = 1;
pub const STATX_MODE: u32 = 2;
pub const STATX_NLINK: u32 = 4;
pub const STATX_UID: u32 = 8;
pub const STATX_GID: u32 = 16;
pub const STATX_ATIME: u32 = 32;
pub const STATX_MTIME: u32 = 64;
pub const STATX_CTIME: u32 = 128;
pub const STATX_INO: u32 = 256;
pub const STATX_SIZE: u32 = 512;
pub const STATX_BLOCKS: u32 = 1024;
pub const STATX_BASIC_STATS: u32 = 2047;
pub const STATX_BTIME: u32 = 2048;
pub const STATX_MNT_ID: u32 = 4096;
pub const STATX__RESERVED: u32 = 2147483648;
pub const STATX_ALL: u32 = 4095;
pub const STATX_ATTR_COMPRESSED: u32 = 4;
pub const STATX_ATTR_IMMUTABLE: u32 = 16;
pub const STATX_ATTR_APPEND: u32 = 32;
pub const STATX_ATTR_NODUMP: u32 = 64;
pub const STATX_ATTR_ENCRYPTED: u32 = 2048;
pub const STATX_ATTR_AUTOMOUNT: u32 = 4096;
pub const STATX_ATTR_MOUNT_ROOT: u32 = 8192;
pub const STATX_ATTR_VERITY: u32 = 1048576;
pub const STATX_ATTR_DAX: u32 = 2097152;
pub const __statx_timestamp_defined: u32 = 1;
pub const __statx_defined: u32 = 1;
pub const _SYS_TIME_H: u32 = 1;
pub const _SYS_MMAN_H: u32 = 1;
pub const MAP_32BIT: u32 = 64;
pub const MAP_GROWSDOWN: u32 = 256;
pub const MAP_DENYWRITE: u32 = 2048;
pub const MAP_EXECUTABLE: u32 = 4096;
pub const MAP_LOCKED: u32 = 8192;
pub const MAP_NORESERVE: u32 = 16384;
pub const MAP_POPULATE: u32 = 32768;
pub const MAP_NONBLOCK: u32 = 65536;
pub const MAP_STACK: u32 = 131072;
pub const MAP_HUGETLB: u32 = 262144;
pub const MAP_SYNC: u32 = 524288;
pub const MAP_FIXED_NOREPLACE: u32 = 1048576;
pub const PROT_READ: u32 = 1;
pub const PROT_WRITE: u32 = 2;
pub const PROT_EXEC: u32 = 4;
pub const PROT_NONE: u32 = 0;
pub const PROT_GROWSDOWN: u32 = 16777216;
pub const PROT_GROWSUP: u32 = 33554432;
pub const MAP_SHARED: u32 = 1;
pub const MAP_PRIVATE: u32 = 2;
pub const MAP_SHARED_VALIDATE: u32 = 3;
pub const MAP_TYPE: u32 = 15;
pub const MAP_FIXED: u32 = 16;
pub const MAP_FILE: u32 = 0;
pub const MAP_ANONYMOUS: u32 = 32;
pub const MAP_ANON: u32 = 32;
pub const MAP_HUGE_SHIFT: u32 = 26;
pub const MAP_HUGE_MASK: u32 = 63;
pub const MS_ASYNC: u32 = 1;
pub const MS_SYNC: u32 = 4;
pub const MS_INVALIDATE: u32 = 2;
pub const MADV_NORMAL: u32 = 0;
pub const MADV_RANDOM: u32 = 1;
pub const MADV_SEQUENTIAL: u32 = 2;
pub const MADV_WILLNEED: u32 = 3;
pub const MADV_DONTNEED: u32 = 4;
pub const MADV_FREE: u32 = 8;
pub const MADV_REMOVE: u32 = 9;
pub const MADV_DONTFORK: u32 = 10;
pub const MADV_DOFORK: u32 = 11;
pub const MADV_MERGEABLE: u32 = 12;
pub const MADV_UNMERGEABLE: u32 = 13;
pub const MADV_HUGEPAGE: u32 = 14;
pub const MADV_NOHUGEPAGE: u32 = 15;
pub const MADV_DONTDUMP: u32 = 16;
pub const MADV_DODUMP: u32 = 17;
pub const MADV_WIPEONFORK: u32 = 18;
pub const MADV_KEEPONFORK: u32 = 19;
pub const MADV_COLD: u32 = 20;
pub const MADV_PAGEOUT: u32 = 21;
pub const MADV_POPULATE_READ: u32 = 22;
pub const MADV_POPULATE_WRITE: u32 = 23;
pub const MADV_HWPOISON: u32 = 100;
pub const POSIX_MADV_NORMAL: u32 = 0;
pub const POSIX_MADV_RANDOM: u32 = 1;
pub const POSIX_MADV_SEQUENTIAL: u32 = 2;
pub const POSIX_MADV_WILLNEED: u32 = 3;
pub const POSIX_MADV_DONTNEED: u32 = 4;
pub const MCL_CURRENT: u32 = 1;
pub const MCL_FUTURE: u32 = 2;
pub const MCL_ONFAULT: u32 = 4;
pub const MREMAP_MAYMOVE: u32 = 1;
pub const MREMAP_FIXED: u32 = 2;
pub const MREMAP_DONTUNMAP: u32 = 4;
pub const MFD_CLOEXEC: u32 = 1;
pub const MFD_ALLOW_SEALING: u32 = 2;
pub const MFD_HUGETLB: u32 = 4;
pub const MLOCK_ONFAULT: u32 = 1;
pub const PKEY_DISABLE_ACCESS: u32 = 1;
pub const PKEY_DISABLE_WRITE: u32 = 2;
pub const G_ANALYZER_ANALYZING: u32 = 0;
pub const FALSE: u32 = 0;
pub const G_GINT16_MODIFIER: &[u8; 2] = b"h\0";
pub const G_GINT16_FORMAT: &[u8; 3] = b"hi\0";
pub const G_GUINT16_FORMAT: &[u8; 3] = b"hu\0";
pub const G_GINT32_MODIFIER: &[u8; 1] = b"\0";
pub const G_GINT32_FORMAT: &[u8; 2] = b"i\0";
pub const G_GUINT32_FORMAT: &[u8; 2] = b"u\0";
pub const G_HAVE_GINT64: u32 = 1;
pub const G_GINT64_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GINT64_FORMAT: &[u8; 3] = b"li\0";
pub const G_GUINT64_FORMAT: &[u8; 3] = b"lu\0";
pub const GLIB_SIZEOF_VOID_P: u32 = 8;
pub const GLIB_SIZEOF_LONG: u32 = 8;
pub const GLIB_SIZEOF_SIZE_T: u32 = 8;
pub const GLIB_SIZEOF_SSIZE_T: u32 = 8;
pub const G_GSIZE_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GSSIZE_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GSIZE_FORMAT: &[u8; 3] = b"lu\0";
pub const G_GSSIZE_FORMAT: &[u8; 3] = b"li\0";
pub const G_GOFFSET_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GOFFSET_FORMAT: &[u8; 3] = b"li\0";
pub const G_POLLFD_FORMAT: &[u8; 3] = b"%d\0";
pub const G_GINTPTR_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GINTPTR_FORMAT: &[u8; 3] = b"li\0";
pub const G_GUINTPTR_FORMAT: &[u8; 3] = b"lu\0";
pub const GLIB_MAJOR_VERSION: u32 = 2;
pub const GLIB_MINOR_VERSION: u32 = 72;
pub const GLIB_MICRO_VERSION: u32 = 4;
pub const G_VA_COPY_AS_ARRAY: u32 = 1;
pub const G_HAVE_ISO_VARARGS: u32 = 1;
pub const G_HAVE_GROWING_STACK: u32 = 0;
pub const G_HAVE_GNUC_VISIBILITY: u32 = 1;
pub const G_HAVE_GNUC_VARARGS: u32 = 1;
pub const G_MODULE_SUFFIX: &[u8; 3] = b"so\0";
pub const G_PID_FORMAT: &[u8; 2] = b"i\0";
pub const GLIB_SYSDEF_AF_UNIX: u32 = 1;
pub const GLIB_SYSDEF_AF_INET: u32 = 2;
pub const GLIB_SYSDEF_AF_INET6: u32 = 10;
pub const GLIB_SYSDEF_MSG_OOB: u32 = 1;
pub const GLIB_SYSDEF_MSG_PEEK: u32 = 2;
pub const GLIB_SYSDEF_MSG_DONTROUTE: u32 = 4;
pub const G_DIR_SEPARATOR: u8 = 47u8;
pub const G_DIR_SEPARATOR_S: &[u8; 2] = b"/\0";
pub const G_SEARCHPATH_SEPARATOR: u8 = 58u8;
pub const G_SEARCHPATH_SEPARATOR_S: &[u8; 2] = b":\0";
pub const G_E: f64 = 2.718281828459045;
pub const G_LN2: f64 = 0.6931471805599453;
pub const G_LN10: f64 = 2.302585092994046;
pub const G_PI: f64 = 3.141592653589793;
pub const G_PI_2: f64 = 1.5707963267948966;
pub const G_PI_4: f64 = 0.7853981633974483;
pub const G_SQRT2: f64 = 1.4142135623730951;
pub const G_LITTLE_ENDIAN: u32 = 1234;
pub const G_BIG_ENDIAN: u32 = 4321;
pub const G_PDP_ENDIAN: u32 = 3412;
pub const G_IEEE754_FLOAT_BIAS: u32 = 127;
pub const G_IEEE754_DOUBLE_BIAS: u32 = 1023;
pub const G_LOG_2_BASE_10: f64 = 0.3010299956639812;
pub const G_DATALIST_FLAGS_MASK: u32 = 3;
pub const G_DATE_BAD_JULIAN: u32 = 0;
pub const G_DATE_BAD_DAY: u32 = 0;
pub const G_DATE_BAD_YEAR: u32 = 0;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 1;
pub const MAXNAMLEN: u32 = 255;
pub const G_MEM_ALIGN: u32 = 8;
pub const G_HOOK_FLAG_USER_SHIFT: u32 = 4;
pub const G_PRIORITY_HIGH: i32 = -100;
pub const G_PRIORITY_DEFAULT: u32 = 0;
pub const G_PRIORITY_HIGH_IDLE: u32 = 100;
pub const G_PRIORITY_DEFAULT_IDLE: u32 = 200;
pub const G_PRIORITY_LOW: u32 = 300;
pub const G_SOURCE_REMOVE: u32 = 0;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: u32 = 18;
pub const G_KEY_FILE_DESKTOP_GROUP: &[u8; 14] = b"Desktop Entry\0";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &[u8; 5] = b"Type\0";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &[u8; 8] = b"Version\0";
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &[u8; 5] = b"Name\0";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &[u8; 12] = b"GenericName\0";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &[u8; 10] = b"NoDisplay\0";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &[u8; 8] = b"Comment\0";
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &[u8; 5] = b"Icon\0";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &[u8; 7] = b"Hidden\0";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &[u8; 11] = b"OnlyShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &[u8; 10] = b"NotShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &[u8; 8] = b"TryExec\0";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &[u8; 5] = b"Exec\0";
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &[u8; 5] = b"Path\0";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &[u8; 9] = b"Terminal\0";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &[u8; 9] = b"MimeType\0";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &[u8; 11] = b"Categories\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &[u8; 14] = b"StartupNotify\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &[u8; 15] = b"StartupWMClass\0";
pub const G_KEY_FILE_DESKTOP_KEY_URL: &[u8; 4] = b"URL\0";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &[u8; 16] = b"DBusActivatable\0";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &[u8; 8] = b"Actions\0";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &[u8; 12] = b"Application\0";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &[u8; 5] = b"Link\0";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &[u8; 10] = b"Directory\0";
pub const G_LOG_LEVEL_USER_SHIFT: u32 = 8;
pub const G_OPTION_REMAINING: &[u8; 1] = b"\0";
pub const G_CSET_A_2_Z: &[u8; 27] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";
pub const G_CSET_a_2_z: &[u8; 27] = b"abcdefghijklmnopqrstuvwxyz\0";
pub const G_CSET_DIGITS: &[u8; 11] = b"0123456789\0";
pub const G_CSET_LATINC : & [u8 ; 31] = b"\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD8\xD9\xDA\xDB\xDC\xDD\xDE\0" ;
pub const G_CSET_LATINS : & [u8 ; 33] = b"\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF\0" ;
pub const G_STR_DELIMITERS: &[u8; 8] = b"_-|> <.\0";
pub const G_ASCII_DTOSTR_BUF_SIZE: u32 = 39;
pub const G_TEST_OPTION_ISOLATE_DIRS: &[u8; 13] = b"isolate_dirs\0";
pub const G_USEC_PER_SEC: u32 = 1000000;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &[u8; 8] = b":/?#[]@\0";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &[u8; 12] = b"!$&'()*+,;=\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT: &[u8; 14] = b"!$&'()*+,;=:@\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH: &[u8; 15] = b"!$&'()*+,;=:@/\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO: &[u8; 13] = b"!$&'()*+,;=:\0";
pub const G_ALLOC_ONLY: u32 = 1;
pub const G_ALLOC_AND_FREE: u32 = 2;
pub const G_ALLOCATOR_LIST: u32 = 1;
pub const G_ALLOCATOR_SLIST: u32 = 2;
pub const G_ALLOCATOR_NODE: u32 = 3;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_ISO: u32 = 4;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const CSIGNAL: u32 = 255;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const CPU_SETSIZE: u32 = 1024;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const PTHREAD_ATTR_NO_SIGMASK_NP: i32 = -1;
pub const CONFIG_I386_DIS: u32 = 1;
pub const CONFIG_MIPS_DIS: u32 = 1;
pub const CONFIG_SOFTMMU: u32 = 1;
pub const CONFIG_SYSTEM_ONLY: u32 = 1;
pub const CONFIG_TCG: u32 = 1;
pub const CONFIG_TCG_BUILTIN: u32 = 1;
pub const TARGET_BIG_ENDIAN: u32 = 1;
pub const TARGET_MIPS: u32 = 1;
pub const TARGET_NAME: &[u8; 5] = b"mips\0";
pub const TARGET_SUPPORTS_MTTCG: u32 = 1;
pub const TARGET_LONG_BITS: u32 = 32;
pub const TARGET_PHYS_ADDR_SPACE_BITS: u32 = 40;
pub const TARGET_VIRT_ADDR_SPACE_BITS: u32 = 32;
pub const TARGET_PAGE_BITS_MIN: u32 = 12;
pub const TCG_GUEST_DEFAULT_MO: u32 = 0;
pub const PPP_MAX_CB: u32 = 256;
pub const PANDA_CORE_NAME: &[u8; 5] = b"core\0";
pub const PANDA_MSG_PREFIX: &[u8; 7] = b"PANDA[\0";
pub const PANDA_MSG_SUFFIX: &[u8; 3] = b"]:\0";
pub const PANDA_MSG_FMT: &[u8; 11] = b"PANDA[%s]:\0";
pub const PANDA_MSG: &[u8; 13] = b"PANDA[core]:\0";
pub const PANDA_LOG_NOTHING: u32 = 0;
pub const PANDA_LOG_ERROR: u32 = 1;
pub const PANDA_LOG_WARNING: u32 = 2;
pub const PANDA_LOG_INFO: u32 = 3;
pub const PANDA_LOG_DEBUG: u32 = 4;
pub const PANDA_LOG_LEVEL: u32 = 2;
pub const MEMTX_OK: u32 = 0;
pub const TARGET_LONG_SIZE: u32 = 4;
pub const TARGET_FMT_lx: &[u8; 5] = b"%08x\0";
pub const TARGET_FMT_ld: &[u8; 3] = b"%d\0";
pub const TARGET_FMT_lu: &[u8; 3] = b"%u\0";
pub const TARGET_PTR_FMT: &[u8; 5] = b"%08x\0";
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtof32(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float32;
}
unsafe extern "C" {
    pub fn strtof64(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float64;
}
unsafe extern "C" {
    pub fn strtof32x(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float32x;
}
unsafe extern "C" {
    pub fn strtof64x(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float64x;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strfromd(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfroml(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: u128,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf32(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf64(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf32x(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float32x,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfromf64x(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float64x,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::std::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::std::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::std::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::std::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::std::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::std::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::std::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn strtol_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoll_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtod_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtof32_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float32;
}
unsafe extern "C" {
    pub fn strtof64_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float64;
}
unsafe extern "C" {
    pub fn strtof32x_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float32x;
}
unsafe extern "C" {
    pub fn strtof64x_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float64x;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::fds_bits"][::std::mem::offset_of!(fd_set, fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>() - 8usize];
    ["Alignment of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>() - 4usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter"][::std::mem::size_of::<__atomic_wide_counter>() - 8usize];
    ["Alignment of __atomic_wide_counter"]
        [::std::mem::align_of::<__atomic_wide_counter>() - 8usize];
    ["Offset of field: __atomic_wide_counter::__value64"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value64) - 0usize];
    ["Offset of field: __atomic_wide_counter::__value32"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value32) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__wseq"]
        [::std::mem::offset_of!(__pthread_cond_s, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s::__g1_start"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_start) - 8usize];
    ["Offset of field: __pthread_cond_s::__g_refs"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_refs) - 16usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 32usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 36usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 40usize];
};
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __once_flag"][::std::mem::size_of::<__once_flag>() - 4usize];
    ["Alignment of __once_flag"][::std::mem::align_of::<__once_flag>() - 4usize];
    ["Offset of field: __once_flag::__data"][::std::mem::offset_of!(__once_flag, __data) - 0usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
    ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
    ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
    ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
    ["Offset of field: random_data::rand_type"]
        [::std::mem::offset_of!(random_data, rand_type) - 24usize];
    ["Offset of field: random_data::rand_deg"]
        [::std::mem::offset_of!(random_data, rand_deg) - 28usize];
    ["Offset of field: random_data::rand_sep"]
        [::std::mem::offset_of!(random_data, rand_sep) - 32usize];
    ["Offset of field: random_data::end_ptr"]
        [::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::std::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn secure_getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemp64(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkostemp(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkostemp64(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkostemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkostemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn canonicalize_file_name(
        __name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_d_fn_t,
        __arg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn posix_openpt(__oflag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn grantpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unlockpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ptsname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ptsname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpt() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::std::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::std::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos_t"][::std::mem::size_of::<_G_fpos_t>() - 16usize];
    ["Alignment of _G_fpos_t"][::std::mem::align_of::<_G_fpos_t>() - 8usize];
    ["Offset of field: _G_fpos_t::__pos"][::std::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::std::mem::offset_of!(_G_fpos_t, __state) - 8usize];
};
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::std::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::std::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_flags2"][::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::__pad5"][::std::mem::offset_of!(_IO_FILE, __pad5) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_cookie_io_functions_t"]
        [::std::mem::size_of::<_IO_cookie_io_functions_t>() - 32usize];
    ["Alignment of _IO_cookie_io_functions_t"]
        [::std::mem::align_of::<_IO_cookie_io_functions_t>() - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::read"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, read) - 0usize];
    ["Offset of field: _IO_cookie_io_functions_t::write"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, write) - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::seek"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, seek) - 16usize];
    ["Offset of field: _IO_cookie_io_functions_t::close"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, close) - 24usize];
};
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type fpos_t = __fpos_t;
pub type fpos64_t = __fpos64_t;
unsafe extern "C" {
    pub static mut stdin: *mut FILE;
}
unsafe extern "C" {
    pub static mut stdout: *mut FILE;
}
unsafe extern "C" {
    pub static mut stderr: *mut FILE;
}
unsafe extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat2(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
unsafe extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
unsafe extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fgets_unlocked(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fputs_unlocked(
        __s: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
unsafe extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fseeko64(
        __stream: *mut FILE,
        __off: __off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
}
unsafe extern "C" {
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos64(__stream: *mut FILE, __pos: *const fpos64_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn cuserid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn obstack_printf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn obstack_vprintf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        __args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn rawmemchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memrchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strerrordesc_np(__err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strerrorname_np(__err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn sigabbrev_np(__sig: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn sigdescr_np(__sig: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strverscmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strfry(__string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memfrob(__s: *mut ::std::os::raw::c_void, __n: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn basename(__filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::std::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::std::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::std::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::std::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
unsafe extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn __sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
pub type socklen_t = __socklen_t;
unsafe extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn euidaccess(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn eaccess(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execveat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
unsafe extern "C" {
    pub fn lseek64(
        __fd: ::std::os::raw::c_int,
        __offset: __off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off64_t;
}
unsafe extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn closefrom(__lowfd: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pread64(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off64_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pwrite64(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off64_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pipe2(
        __pipedes: *mut ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
unsafe extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn get_current_dir_name() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dup3(
        __fd: ::std::os::raw::c_int,
        __fd2: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut environ: *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execvpe(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_1 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_1 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_1 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_1 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_1 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_1 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_1 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_1 = 7;
pub const _PC_VDISABLE: _bindgen_ty_1 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_1 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_1 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_1 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_1 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_1 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_1 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_1 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_1 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_1 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_1 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_1 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_1 = 20;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_2 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_2 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_2 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_2 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_2 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_2 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_2 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_2 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_2 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_2 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_2 = 10;
pub const _SC_TIMERS: _bindgen_ty_2 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_2 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_2 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_2 = 14;
pub const _SC_FSYNC: _bindgen_ty_2 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_2 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_2 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_2 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_2 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_2 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_2 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_2 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_2 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_2 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_2 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_2 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_2 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_2 = 28;
pub const _SC_VERSION: _bindgen_ty_2 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_2 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_2 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_2 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_2 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_2 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_2 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_2 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_2 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_2 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_2 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_2 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_2 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_2 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_2 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_2 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_2 = 45;
pub const _SC_2_VERSION: _bindgen_ty_2 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_2 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_2 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_2 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_2 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_2 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_2 = 52;
pub const _SC_PII: _bindgen_ty_2 = 53;
pub const _SC_PII_XTI: _bindgen_ty_2 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_2 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_2 = 56;
pub const _SC_PII_OSI: _bindgen_ty_2 = 57;
pub const _SC_POLL: _bindgen_ty_2 = 58;
pub const _SC_SELECT: _bindgen_ty_2 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_2 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_2 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_2 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_2 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_2 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_2 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_2 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_2 = 66;
pub const _SC_THREADS: _bindgen_ty_2 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_2 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_2 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_2 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_2 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_2 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_2 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_2 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_2 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_2 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_2 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_2 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_2 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_2 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_2 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_2 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_2 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_2 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_2 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_2 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_2 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_2 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_2 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_2 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_2 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_2 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_2 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_2 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_2 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_2 = 96;
pub const _SC_2_UPE: _bindgen_ty_2 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_2 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_2 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_2 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_2 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_2 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_2 = 103;
pub const _SC_INT_MAX: _bindgen_ty_2 = 104;
pub const _SC_INT_MIN: _bindgen_ty_2 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_2 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_2 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_2 = 108;
pub const _SC_NZERO: _bindgen_ty_2 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_2 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_2 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_2 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_2 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_2 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_2 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_2 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_2 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_2 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_2 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_2 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_2 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_2 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_2 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_2 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_2 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_2 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_2 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_2 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_2 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_2 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_2 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_2 = 132;
pub const _SC_BARRIERS: _bindgen_ty_2 = 133;
pub const _SC_BASE: _bindgen_ty_2 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_2 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_2 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_2 = 137;
pub const _SC_CPUTIME: _bindgen_ty_2 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_2 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_2 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_2 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_2 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_2 = 143;
pub const _SC_FIFO: _bindgen_ty_2 = 144;
pub const _SC_PIPE: _bindgen_ty_2 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_2 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_2 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_2 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_2 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_2 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_2 = 151;
pub const _SC_NETWORKING: _bindgen_ty_2 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_2 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_2 = 154;
pub const _SC_REGEXP: _bindgen_ty_2 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_2 = 156;
pub const _SC_SHELL: _bindgen_ty_2 = 157;
pub const _SC_SIGNALS: _bindgen_ty_2 = 158;
pub const _SC_SPAWN: _bindgen_ty_2 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_2 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_2 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_2 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_2 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_2 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_2 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_2 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_2 = 167;
pub const _SC_2_PBS: _bindgen_ty_2 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_2 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_2 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_2 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_2 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_2 = 173;
pub const _SC_STREAMS: _bindgen_ty_2 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_2 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_2 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_2 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_2 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_2 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_2 = 180;
pub const _SC_TRACE: _bindgen_ty_2 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_2 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_2 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_2 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_2 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_2 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_2 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_2 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_2 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_2 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_2 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_2 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_2 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_2 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_2 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_2 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_2 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_2 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_2 = 199;
pub const _SC_IPV6: _bindgen_ty_2 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_2 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_2 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_2 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_2 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_2 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_2 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_2 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_2 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_2 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_2 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_2 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_2 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_2 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_2 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_2 = 250;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const _CS_PATH: _bindgen_ty_3 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_3 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_3 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_3 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_3 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_3 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_3 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_3 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_3 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_3 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_3 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_3 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_3 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_3 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_3 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_3 = 1149;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn getpid() -> __pid_t;
}
unsafe extern "C" {
    pub fn getppid() -> __pid_t;
}
unsafe extern "C" {
    pub fn getpgrp() -> __pid_t;
}
unsafe extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
unsafe extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
unsafe extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setsid() -> __pid_t;
}
unsafe extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
unsafe extern "C" {
    pub fn getuid() -> __uid_t;
}
unsafe extern "C" {
    pub fn geteuid() -> __uid_t;
}
unsafe extern "C" {
    pub fn getgid() -> __gid_t;
}
unsafe extern "C" {
    pub fn getegid() -> __gid_t;
}
unsafe extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn group_member(__gid: __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getresuid(
        __ruid: *mut __uid_t,
        __euid: *mut __uid_t,
        __suid: *mut __uid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getresgid(
        __rgid: *mut __gid_t,
        __egid: *mut __gid_t,
        __sgid: *mut __gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setresuid(__ruid: __uid_t, __euid: __uid_t, __suid: __uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setresgid(__rgid: __gid_t, __egid: __gid_t, __sgid: __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fork() -> __pid_t;
}
unsafe extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _Fork() -> __pid_t;
}
unsafe extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
unsafe extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn endusershell();
}
unsafe extern "C" {
    pub fn setusershell();
}
unsafe extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn syncfs(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn sync();
}
unsafe extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn truncate64(
        __file: *const ::std::os::raw::c_char,
        __length: __off64_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftruncate64(__fd: ::std::os::raw::c_int, __length: __off64_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lockf64(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off64_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn copy_file_range(
        __infd: ::std::os::raw::c_int,
        __pinoff: *mut __off64_t,
        __outfd: ::std::os::raw::c_int,
        __poutoff: *mut __off64_t,
        __length: usize,
        __flags: ::std::os::raw::c_uint,
    ) -> isize;
}
unsafe extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn swab(
        __from: *const ::std::os::raw::c_void,
        __to: *mut ::std::os::raw::c_void,
        __n: isize,
    );
}
unsafe extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn close_range(
        __fd: ::std::os::raw::c_uint,
        __max_fd: ::std::os::raw::c_uint,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gettid() -> __pid_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timex {
    pub modes: ::std::os::raw::c_uint,
    pub offset: __syscall_slong_t,
    pub freq: __syscall_slong_t,
    pub maxerror: __syscall_slong_t,
    pub esterror: __syscall_slong_t,
    pub status: ::std::os::raw::c_int,
    pub constant: __syscall_slong_t,
    pub precision: __syscall_slong_t,
    pub tolerance: __syscall_slong_t,
    pub time: timeval,
    pub tick: __syscall_slong_t,
    pub ppsfreq: __syscall_slong_t,
    pub jitter: __syscall_slong_t,
    pub shift: ::std::os::raw::c_int,
    pub stabil: __syscall_slong_t,
    pub jitcnt: __syscall_slong_t,
    pub calcnt: __syscall_slong_t,
    pub errcnt: __syscall_slong_t,
    pub stbcnt: __syscall_slong_t,
    pub tai: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 44usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timex"][::std::mem::size_of::<timex>() - 208usize];
    ["Alignment of timex"][::std::mem::align_of::<timex>() - 8usize];
    ["Offset of field: timex::modes"][::std::mem::offset_of!(timex, modes) - 0usize];
    ["Offset of field: timex::offset"][::std::mem::offset_of!(timex, offset) - 8usize];
    ["Offset of field: timex::freq"][::std::mem::offset_of!(timex, freq) - 16usize];
    ["Offset of field: timex::maxerror"][::std::mem::offset_of!(timex, maxerror) - 24usize];
    ["Offset of field: timex::esterror"][::std::mem::offset_of!(timex, esterror) - 32usize];
    ["Offset of field: timex::status"][::std::mem::offset_of!(timex, status) - 40usize];
    ["Offset of field: timex::constant"][::std::mem::offset_of!(timex, constant) - 48usize];
    ["Offset of field: timex::precision"][::std::mem::offset_of!(timex, precision) - 56usize];
    ["Offset of field: timex::tolerance"][::std::mem::offset_of!(timex, tolerance) - 64usize];
    ["Offset of field: timex::time"][::std::mem::offset_of!(timex, time) - 72usize];
    ["Offset of field: timex::tick"][::std::mem::offset_of!(timex, tick) - 88usize];
    ["Offset of field: timex::ppsfreq"][::std::mem::offset_of!(timex, ppsfreq) - 96usize];
    ["Offset of field: timex::jitter"][::std::mem::offset_of!(timex, jitter) - 104usize];
    ["Offset of field: timex::shift"][::std::mem::offset_of!(timex, shift) - 112usize];
    ["Offset of field: timex::stabil"][::std::mem::offset_of!(timex, stabil) - 120usize];
    ["Offset of field: timex::jitcnt"][::std::mem::offset_of!(timex, jitcnt) - 128usize];
    ["Offset of field: timex::calcnt"][::std::mem::offset_of!(timex, calcnt) - 136usize];
    ["Offset of field: timex::errcnt"][::std::mem::offset_of!(timex, errcnt) - 144usize];
    ["Offset of field: timex::stbcnt"][::std::mem::offset_of!(timex, stbcnt) - 152usize];
    ["Offset of field: timex::tai"][::std::mem::offset_of!(timex, tai) - 160usize];
};
unsafe extern "C" {
    pub fn clock_adjtime(__clock_id: __clockid_t, __utx: *mut timex) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::std::mem::size_of::<tm>() - 56usize];
    ["Alignment of tm"][::std::mem::align_of::<tm>() - 8usize];
    ["Offset of field: tm::tm_sec"][::std::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::std::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::std::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::std::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::std::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::std::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::std::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::std::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::std::mem::offset_of!(tm, tm_isdst) - 32usize];
    ["Offset of field: tm::tm_gmtoff"][::std::mem::offset_of!(tm, tm_gmtoff) - 40usize];
    ["Offset of field: tm::tm_zone"][::std::mem::offset_of!(tm, tm_zone) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerspec"][::std::mem::size_of::<itimerspec>() - 32usize];
    ["Alignment of itimerspec"][::std::mem::align_of::<itimerspec>() - 8usize];
    ["Offset of field: itimerspec::it_interval"]
        [::std::mem::offset_of!(itimerspec, it_interval) - 0usize];
    ["Offset of field: itimerspec::it_value"]
        [::std::mem::offset_of!(itimerspec, it_value) - 16usize];
};
unsafe extern "C" {
    pub fn clock() -> clock_t;
}
unsafe extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
unsafe extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
unsafe extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strptime(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tp: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strptime_l(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tp: *mut tm,
        __loc: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub fn tzset();
}
unsafe extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timespec_getres(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdate(__string: *const ::std::os::raw::c_char) -> *mut tm;
}
unsafe extern "C" {
    pub fn getdate_r(
        __string: *const ::std::os::raw::c_char,
        __resbufp: *mut tm,
    ) -> ::std::os::raw::c_int;
}
pub const _ISupper: _bindgen_ty_4 = 256;
pub const _ISlower: _bindgen_ty_4 = 512;
pub const _ISalpha: _bindgen_ty_4 = 1024;
pub const _ISdigit: _bindgen_ty_4 = 2048;
pub const _ISxdigit: _bindgen_ty_4 = 4096;
pub const _ISspace: _bindgen_ty_4 = 8192;
pub const _ISprint: _bindgen_ty_4 = 16384;
pub const _ISgraph: _bindgen_ty_4 = 32768;
pub const _ISblank: _bindgen_ty_4 = 1;
pub const _IScntrl: _bindgen_ty_4 = 2;
pub const _ISpunct: _bindgen_ty_4 = 4;
pub const _ISalnum: _bindgen_ty_4 = 8;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
unsafe extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
unsafe extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isctype(
        __c: ::std::os::raw::c_int,
        __mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut program_invocation_name: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut program_invocation_short_name: *mut ::std::os::raw::c_char;
}
pub type error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of flock"][::std::mem::size_of::<flock>() - 32usize];
    ["Alignment of flock"][::std::mem::align_of::<flock>() - 8usize];
    ["Offset of field: flock::l_type"][::std::mem::offset_of!(flock, l_type) - 0usize];
    ["Offset of field: flock::l_whence"][::std::mem::offset_of!(flock, l_whence) - 2usize];
    ["Offset of field: flock::l_start"][::std::mem::offset_of!(flock, l_start) - 8usize];
    ["Offset of field: flock::l_len"][::std::mem::offset_of!(flock, l_len) - 16usize];
    ["Offset of field: flock::l_pid"][::std::mem::offset_of!(flock, l_pid) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock64 {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __off64_t,
    pub l_len: __off64_t,
    pub l_pid: __pid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of flock64"][::std::mem::size_of::<flock64>() - 32usize];
    ["Alignment of flock64"][::std::mem::align_of::<flock64>() - 8usize];
    ["Offset of field: flock64::l_type"][::std::mem::offset_of!(flock64, l_type) - 0usize];
    ["Offset of field: flock64::l_whence"][::std::mem::offset_of!(flock64, l_whence) - 2usize];
    ["Offset of field: flock64::l_start"][::std::mem::offset_of!(flock64, l_start) - 8usize];
    ["Offset of field: flock64::l_len"][::std::mem::offset_of!(flock64, l_len) - 16usize];
    ["Offset of field: flock64::l_pid"][::std::mem::offset_of!(flock64, l_pid) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iovec"][::std::mem::size_of::<iovec>() - 16usize];
    ["Alignment of iovec"][::std::mem::align_of::<iovec>() - 8usize];
    ["Offset of field: iovec::iov_base"][::std::mem::offset_of!(iovec, iov_base) - 0usize];
    ["Offset of field: iovec::iov_len"][::std::mem::offset_of!(iovec, iov_len) - 8usize];
};
pub const F_OWNER_TID: __pid_type = 0;
pub const F_OWNER_PID: __pid_type = 1;
pub const F_OWNER_PGRP: __pid_type = 2;
pub const F_OWNER_GID: __pid_type = 2;
pub type __pid_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct f_owner_ex {
    pub type_: __pid_type,
    pub pid: __pid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of f_owner_ex"][::std::mem::size_of::<f_owner_ex>() - 8usize];
    ["Alignment of f_owner_ex"][::std::mem::align_of::<f_owner_ex>() - 4usize];
    ["Offset of field: f_owner_ex::type_"][::std::mem::offset_of!(f_owner_ex, type_) - 0usize];
    ["Offset of field: f_owner_ex::pid"][::std::mem::offset_of!(f_owner_ex, pid) - 4usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct file_handle {
    pub handle_bytes: ::std::os::raw::c_uint,
    pub handle_type: ::std::os::raw::c_int,
    pub f_handle: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of file_handle"][::std::mem::size_of::<file_handle>() - 8usize];
    ["Alignment of file_handle"][::std::mem::align_of::<file_handle>() - 4usize];
    ["Offset of field: file_handle::handle_bytes"]
        [::std::mem::offset_of!(file_handle, handle_bytes) - 0usize];
    ["Offset of field: file_handle::handle_type"]
        [::std::mem::offset_of!(file_handle, handle_type) - 4usize];
    ["Offset of field: file_handle::f_handle"]
        [::std::mem::offset_of!(file_handle, f_handle) - 8usize];
};
unsafe extern "C" {
    pub fn readahead(__fd: ::std::os::raw::c_int, __offset: __off64_t, __count: usize)
        -> __ssize_t;
}
unsafe extern "C" {
    pub fn sync_file_range(
        __fd: ::std::os::raw::c_int,
        __offset: __off64_t,
        __count: __off64_t,
        __flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vmsplice(
        __fdout: ::std::os::raw::c_int,
        __iov: *const iovec,
        __count: usize,
        __flags: ::std::os::raw::c_uint,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn splice(
        __fdin: ::std::os::raw::c_int,
        __offin: *mut __off64_t,
        __fdout: ::std::os::raw::c_int,
        __offout: *mut __off64_t,
        __len: usize,
        __flags: ::std::os::raw::c_uint,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn tee(
        __fdin: ::std::os::raw::c_int,
        __fdout: ::std::os::raw::c_int,
        __len: usize,
        __flags: ::std::os::raw::c_uint,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn fallocate(
        __fd: ::std::os::raw::c_int,
        __mode: ::std::os::raw::c_int,
        __offset: __off_t,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fallocate64(
        __fd: ::std::os::raw::c_int,
        __mode: ::std::os::raw::c_int,
        __offset: __off64_t,
        __len: __off64_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn name_to_handle_at(
        __dfd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __handle: *mut file_handle,
        __mnt_id: *mut ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn open_by_handle_at(
        __mountdirfd: ::std::os::raw::c_int,
        __handle: *mut file_handle,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stat"][::std::mem::size_of::<stat>() - 144usize];
    ["Alignment of stat"][::std::mem::align_of::<stat>() - 8usize];
    ["Offset of field: stat::st_dev"][::std::mem::offset_of!(stat, st_dev) - 0usize];
    ["Offset of field: stat::st_ino"][::std::mem::offset_of!(stat, st_ino) - 8usize];
    ["Offset of field: stat::st_nlink"][::std::mem::offset_of!(stat, st_nlink) - 16usize];
    ["Offset of field: stat::st_mode"][::std::mem::offset_of!(stat, st_mode) - 24usize];
    ["Offset of field: stat::st_uid"][::std::mem::offset_of!(stat, st_uid) - 28usize];
    ["Offset of field: stat::st_gid"][::std::mem::offset_of!(stat, st_gid) - 32usize];
    ["Offset of field: stat::__pad0"][::std::mem::offset_of!(stat, __pad0) - 36usize];
    ["Offset of field: stat::st_rdev"][::std::mem::offset_of!(stat, st_rdev) - 40usize];
    ["Offset of field: stat::st_size"][::std::mem::offset_of!(stat, st_size) - 48usize];
    ["Offset of field: stat::st_blksize"][::std::mem::offset_of!(stat, st_blksize) - 56usize];
    ["Offset of field: stat::st_blocks"][::std::mem::offset_of!(stat, st_blocks) - 64usize];
    ["Offset of field: stat::st_atim"][::std::mem::offset_of!(stat, st_atim) - 72usize];
    ["Offset of field: stat::st_mtim"][::std::mem::offset_of!(stat, st_mtim) - 88usize];
    ["Offset of field: stat::st_ctim"][::std::mem::offset_of!(stat, st_ctim) - 104usize];
    ["Offset of field: stat::__glibc_reserved"]
        [::std::mem::offset_of!(stat, __glibc_reserved) - 120usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat64 {
    pub st_dev: __dev_t,
    pub st_ino: __ino64_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt64_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stat64"][::std::mem::size_of::<stat64>() - 144usize];
    ["Alignment of stat64"][::std::mem::align_of::<stat64>() - 8usize];
    ["Offset of field: stat64::st_dev"][::std::mem::offset_of!(stat64, st_dev) - 0usize];
    ["Offset of field: stat64::st_ino"][::std::mem::offset_of!(stat64, st_ino) - 8usize];
    ["Offset of field: stat64::st_nlink"][::std::mem::offset_of!(stat64, st_nlink) - 16usize];
    ["Offset of field: stat64::st_mode"][::std::mem::offset_of!(stat64, st_mode) - 24usize];
    ["Offset of field: stat64::st_uid"][::std::mem::offset_of!(stat64, st_uid) - 28usize];
    ["Offset of field: stat64::st_gid"][::std::mem::offset_of!(stat64, st_gid) - 32usize];
    ["Offset of field: stat64::__pad0"][::std::mem::offset_of!(stat64, __pad0) - 36usize];
    ["Offset of field: stat64::st_rdev"][::std::mem::offset_of!(stat64, st_rdev) - 40usize];
    ["Offset of field: stat64::st_size"][::std::mem::offset_of!(stat64, st_size) - 48usize];
    ["Offset of field: stat64::st_blksize"][::std::mem::offset_of!(stat64, st_blksize) - 56usize];
    ["Offset of field: stat64::st_blocks"][::std::mem::offset_of!(stat64, st_blocks) - 64usize];
    ["Offset of field: stat64::st_atim"][::std::mem::offset_of!(stat64, st_atim) - 72usize];
    ["Offset of field: stat64::st_mtim"][::std::mem::offset_of!(stat64, st_mtim) - 88usize];
    ["Offset of field: stat64::st_ctim"][::std::mem::offset_of!(stat64, st_ctim) - 104usize];
    ["Offset of field: stat64::__glibc_reserved"]
        [::std::mem::offset_of!(stat64, __glibc_reserved) - 120usize];
};
unsafe extern "C" {
    pub fn fcntl(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcntl64(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn open(
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn open64(
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn openat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn openat64(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn creat(__file: *const ::std::os::raw::c_char, __mode: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn creat64(__file: *const ::std::os::raw::c_char, __mode: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn posix_fadvise(
        __fd: ::std::os::raw::c_int,
        __offset: off_t,
        __len: off_t,
        __advise: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn posix_fadvise64(
        __fd: ::std::os::raw::c_int,
        __offset: off64_t,
        __len: off64_t,
        __advise: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn posix_fallocate(
        __fd: ::std::os::raw::c_int,
        __offset: off_t,
        __len: off_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn posix_fallocate64(
        __fd: ::std::os::raw::c_int,
        __offset: off64_t,
        __len: off64_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct option {
    pub name: *const ::std::os::raw::c_char,
    pub has_arg: ::std::os::raw::c_int,
    pub flag: *mut ::std::os::raw::c_int,
    pub val: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of option"][::std::mem::size_of::<option>() - 32usize];
    ["Alignment of option"][::std::mem::align_of::<option>() - 8usize];
    ["Offset of field: option::name"][::std::mem::offset_of!(option, name) - 0usize];
    ["Offset of field: option::has_arg"][::std::mem::offset_of!(option, has_arg) - 8usize];
    ["Offset of field: option::flag"][::std::mem::offset_of!(option, flag) - 16usize];
    ["Offset of field: option::val"][::std::mem::offset_of!(option, val) - 24usize];
};
unsafe extern "C" {
    pub fn getopt_long(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
        __longopts: *const option,
        __longind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getopt_long_only(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
        __longopts: *const option,
        __longind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const SOCK_STREAM: __socket_type = 1;
pub const SOCK_DGRAM: __socket_type = 2;
pub const SOCK_RAW: __socket_type = 3;
pub const SOCK_RDM: __socket_type = 4;
pub const SOCK_SEQPACKET: __socket_type = 5;
pub const SOCK_DCCP: __socket_type = 6;
pub const SOCK_PACKET: __socket_type = 10;
pub const SOCK_CLOEXEC: __socket_type = 524288;
pub const SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = ::std::os::raw::c_uint;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sockaddr"][::std::mem::size_of::<sockaddr>() - 16usize];
    ["Alignment of sockaddr"][::std::mem::align_of::<sockaddr>() - 2usize];
    ["Offset of field: sockaddr::sa_family"][::std::mem::offset_of!(sockaddr, sa_family) - 0usize];
    ["Offset of field: sockaddr::sa_data"][::std::mem::offset_of!(sockaddr, sa_data) - 2usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sockaddr_storage"][::std::mem::size_of::<sockaddr_storage>() - 128usize];
    ["Alignment of sockaddr_storage"][::std::mem::align_of::<sockaddr_storage>() - 8usize];
    ["Offset of field: sockaddr_storage::ss_family"]
        [::std::mem::offset_of!(sockaddr_storage, ss_family) - 0usize];
    ["Offset of field: sockaddr_storage::__ss_padding"]
        [::std::mem::offset_of!(sockaddr_storage, __ss_padding) - 2usize];
    ["Offset of field: sockaddr_storage::__ss_align"]
        [::std::mem::offset_of!(sockaddr_storage, __ss_align) - 120usize];
};
pub const MSG_OOB: _bindgen_ty_5 = 1;
pub const MSG_PEEK: _bindgen_ty_5 = 2;
pub const MSG_DONTROUTE: _bindgen_ty_5 = 4;
pub const MSG_TRYHARD: _bindgen_ty_5 = 4;
pub const MSG_CTRUNC: _bindgen_ty_5 = 8;
pub const MSG_PROXY: _bindgen_ty_5 = 16;
pub const MSG_TRUNC: _bindgen_ty_5 = 32;
pub const MSG_DONTWAIT: _bindgen_ty_5 = 64;
pub const MSG_EOR: _bindgen_ty_5 = 128;
pub const MSG_WAITALL: _bindgen_ty_5 = 256;
pub const MSG_FIN: _bindgen_ty_5 = 512;
pub const MSG_SYN: _bindgen_ty_5 = 1024;
pub const MSG_CONFIRM: _bindgen_ty_5 = 2048;
pub const MSG_RST: _bindgen_ty_5 = 4096;
pub const MSG_ERRQUEUE: _bindgen_ty_5 = 8192;
pub const MSG_NOSIGNAL: _bindgen_ty_5 = 16384;
pub const MSG_MORE: _bindgen_ty_5 = 32768;
pub const MSG_WAITFORONE: _bindgen_ty_5 = 65536;
pub const MSG_BATCH: _bindgen_ty_5 = 262144;
pub const MSG_ZEROCOPY: _bindgen_ty_5 = 67108864;
pub const MSG_FASTOPEN: _bindgen_ty_5 = 536870912;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_5 = 1073741824;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of msghdr"][::std::mem::size_of::<msghdr>() - 56usize];
    ["Alignment of msghdr"][::std::mem::align_of::<msghdr>() - 8usize];
    ["Offset of field: msghdr::msg_name"][::std::mem::offset_of!(msghdr, msg_name) - 0usize];
    ["Offset of field: msghdr::msg_namelen"][::std::mem::offset_of!(msghdr, msg_namelen) - 8usize];
    ["Offset of field: msghdr::msg_iov"][::std::mem::offset_of!(msghdr, msg_iov) - 16usize];
    ["Offset of field: msghdr::msg_iovlen"][::std::mem::offset_of!(msghdr, msg_iovlen) - 24usize];
    ["Offset of field: msghdr::msg_control"][::std::mem::offset_of!(msghdr, msg_control) - 32usize];
    ["Offset of field: msghdr::msg_controllen"]
        [::std::mem::offset_of!(msghdr, msg_controllen) - 40usize];
    ["Offset of field: msghdr::msg_flags"][::std::mem::offset_of!(msghdr, msg_flags) - 48usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cmsghdr"][::std::mem::size_of::<cmsghdr>() - 16usize];
    ["Alignment of cmsghdr"][::std::mem::align_of::<cmsghdr>() - 8usize];
    ["Offset of field: cmsghdr::cmsg_len"][::std::mem::offset_of!(cmsghdr, cmsg_len) - 0usize];
    ["Offset of field: cmsghdr::cmsg_level"][::std::mem::offset_of!(cmsghdr, cmsg_level) - 8usize];
    ["Offset of field: cmsghdr::cmsg_type"][::std::mem::offset_of!(cmsghdr, cmsg_type) - 12usize];
    ["Offset of field: cmsghdr::__cmsg_data"]
        [::std::mem::offset_of!(cmsghdr, __cmsg_data) - 16usize];
};
unsafe extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_6 = 1;
pub const SCM_CREDENTIALS: _bindgen_ty_6 = 2;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    pub pid: pid_t,
    pub uid: uid_t,
    pub gid: gid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ucred"][::std::mem::size_of::<ucred>() - 12usize];
    ["Alignment of ucred"][::std::mem::align_of::<ucred>() - 4usize];
    ["Offset of field: ucred::pid"][::std::mem::offset_of!(ucred, pid) - 0usize];
    ["Offset of field: ucred::uid"][::std::mem::offset_of!(ucred, uid) - 4usize];
    ["Offset of field: ucred::gid"][::std::mem::offset_of!(ucred, gid) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fd_set"][::std::mem::size_of::<__kernel_fd_set>() - 128usize];
    ["Alignment of __kernel_fd_set"][::std::mem::align_of::<__kernel_fd_set>() - 8usize];
    ["Offset of field: __kernel_fd_set::fds_bits"]
        [::std::mem::offset_of!(__kernel_fd_set, fds_bits) - 0usize];
};
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fsid_t"][::std::mem::size_of::<__kernel_fsid_t>() - 8usize];
    ["Alignment of __kernel_fsid_t"][::std::mem::align_of::<__kernel_fsid_t>() - 4usize];
    ["Offset of field: __kernel_fsid_t::val"]
        [::std::mem::offset_of!(__kernel_fsid_t, val) - 0usize];
};
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of linger"][::std::mem::size_of::<linger>() - 8usize];
    ["Alignment of linger"][::std::mem::align_of::<linger>() - 4usize];
    ["Offset of field: linger::l_onoff"][::std::mem::offset_of!(linger, l_onoff) - 0usize];
    ["Offset of field: linger::l_linger"][::std::mem::offset_of!(linger, l_linger) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of osockaddr"][::std::mem::size_of::<osockaddr>() - 16usize];
    ["Alignment of osockaddr"][::std::mem::align_of::<osockaddr>() - 2usize];
    ["Offset of field: osockaddr::sa_family"]
        [::std::mem::offset_of!(osockaddr, sa_family) - 0usize];
    ["Offset of field: osockaddr::sa_data"][::std::mem::offset_of!(osockaddr, sa_data) - 2usize];
};
pub const SHUT_RD: _bindgen_ty_7 = 0;
pub const SHUT_WR: _bindgen_ty_7 = 1;
pub const SHUT_RDWR: _bindgen_ty_7 = 2;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __SOCKADDR_ARG {
    pub __sockaddr__: *mut sockaddr,
    pub __sockaddr_at__: *mut sockaddr_at,
    pub __sockaddr_ax25__: *mut sockaddr_ax25,
    pub __sockaddr_dl__: *mut sockaddr_dl,
    pub __sockaddr_eon__: *mut sockaddr_eon,
    pub __sockaddr_in__: *mut sockaddr_in,
    pub __sockaddr_in6__: *mut sockaddr_in6,
    pub __sockaddr_inarp__: *mut sockaddr_inarp,
    pub __sockaddr_ipx__: *mut sockaddr_ipx,
    pub __sockaddr_iso__: *mut sockaddr_iso,
    pub __sockaddr_ns__: *mut sockaddr_ns,
    pub __sockaddr_un__: *mut sockaddr_un,
    pub __sockaddr_x25__: *mut sockaddr_x25,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __SOCKADDR_ARG"][::std::mem::size_of::<__SOCKADDR_ARG>() - 8usize];
    ["Alignment of __SOCKADDR_ARG"][::std::mem::align_of::<__SOCKADDR_ARG>() - 8usize];
    ["Offset of field: __SOCKADDR_ARG::__sockaddr__"]
        [::std::mem::offset_of!(__SOCKADDR_ARG, __sockaddr__) - 0usize];
    ["Offset of field: __SOCKADDR_ARG::__sockaddr_at__"]
        [::std::mem::offset_of!(__SOCKADDR_ARG, __sockaddr_at__) - 0usize];
    ["Offset of field: __SOCKADDR_ARG::__sockaddr_ax25__"]
        [::std::mem::offset_of!(__SOCKADDR_ARG, __sockaddr_ax25__) - 0usize];
    ["Offset of field: __SOCKADDR_ARG::__sockaddr_dl__"]
        [::std::mem::offset_of!(__SOCKADDR_ARG, __sockaddr_dl__) - 0usize];
    ["Offset of field: __SOCKADDR_ARG::__sockaddr_eon__"]
        [::std::mem::offset_of!(__SOCKADDR_ARG, __sockaddr_eon__) - 0usize];
    ["Offset of field: __SOCKADDR_ARG::__sockaddr_in__"]
        [::std::mem::offset_of!(__SOCKADDR_ARG, __sockaddr_in__) - 0usize];
    ["Offset of field: __SOCKADDR_ARG::__sockaddr_in6__"]
        [::std::mem::offset_of!(__SOCKADDR_ARG, __sockaddr_in6__) - 0usize];
    ["Offset of field: __SOCKADDR_ARG::__sockaddr_inarp__"]
        [::std::mem::offset_of!(__SOCKADDR_ARG, __sockaddr_inarp__) - 0usize];
    ["Offset of field: __SOCKADDR_ARG::__sockaddr_ipx__"]
        [::std::mem::offset_of!(__SOCKADDR_ARG, __sockaddr_ipx__) - 0usize];
    ["Offset of field: __SOCKADDR_ARG::__sockaddr_iso__"]
        [::std::mem::offset_of!(__SOCKADDR_ARG, __sockaddr_iso__) - 0usize];
    ["Offset of field: __SOCKADDR_ARG::__sockaddr_ns__"]
        [::std::mem::offset_of!(__SOCKADDR_ARG, __sockaddr_ns__) - 0usize];
    ["Offset of field: __SOCKADDR_ARG::__sockaddr_un__"]
        [::std::mem::offset_of!(__SOCKADDR_ARG, __sockaddr_un__) - 0usize];
    ["Offset of field: __SOCKADDR_ARG::__sockaddr_x25__"]
        [::std::mem::offset_of!(__SOCKADDR_ARG, __sockaddr_x25__) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union __CONST_SOCKADDR_ARG {
    pub __sockaddr__: *const sockaddr,
    pub __sockaddr_at__: *const sockaddr_at,
    pub __sockaddr_ax25__: *const sockaddr_ax25,
    pub __sockaddr_dl__: *const sockaddr_dl,
    pub __sockaddr_eon__: *const sockaddr_eon,
    pub __sockaddr_in__: *const sockaddr_in,
    pub __sockaddr_in6__: *const sockaddr_in6,
    pub __sockaddr_inarp__: *const sockaddr_inarp,
    pub __sockaddr_ipx__: *const sockaddr_ipx,
    pub __sockaddr_iso__: *const sockaddr_iso,
    pub __sockaddr_ns__: *const sockaddr_ns,
    pub __sockaddr_un__: *const sockaddr_un,
    pub __sockaddr_x25__: *const sockaddr_x25,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __CONST_SOCKADDR_ARG"][::std::mem::size_of::<__CONST_SOCKADDR_ARG>() - 8usize];
    ["Alignment of __CONST_SOCKADDR_ARG"][::std::mem::align_of::<__CONST_SOCKADDR_ARG>() - 8usize];
    ["Offset of field: __CONST_SOCKADDR_ARG::__sockaddr__"]
        [::std::mem::offset_of!(__CONST_SOCKADDR_ARG, __sockaddr__) - 0usize];
    ["Offset of field: __CONST_SOCKADDR_ARG::__sockaddr_at__"]
        [::std::mem::offset_of!(__CONST_SOCKADDR_ARG, __sockaddr_at__) - 0usize];
    ["Offset of field: __CONST_SOCKADDR_ARG::__sockaddr_ax25__"]
        [::std::mem::offset_of!(__CONST_SOCKADDR_ARG, __sockaddr_ax25__) - 0usize];
    ["Offset of field: __CONST_SOCKADDR_ARG::__sockaddr_dl__"]
        [::std::mem::offset_of!(__CONST_SOCKADDR_ARG, __sockaddr_dl__) - 0usize];
    ["Offset of field: __CONST_SOCKADDR_ARG::__sockaddr_eon__"]
        [::std::mem::offset_of!(__CONST_SOCKADDR_ARG, __sockaddr_eon__) - 0usize];
    ["Offset of field: __CONST_SOCKADDR_ARG::__sockaddr_in__"]
        [::std::mem::offset_of!(__CONST_SOCKADDR_ARG, __sockaddr_in__) - 0usize];
    ["Offset of field: __CONST_SOCKADDR_ARG::__sockaddr_in6__"]
        [::std::mem::offset_of!(__CONST_SOCKADDR_ARG, __sockaddr_in6__) - 0usize];
    ["Offset of field: __CONST_SOCKADDR_ARG::__sockaddr_inarp__"]
        [::std::mem::offset_of!(__CONST_SOCKADDR_ARG, __sockaddr_inarp__) - 0usize];
    ["Offset of field: __CONST_SOCKADDR_ARG::__sockaddr_ipx__"]
        [::std::mem::offset_of!(__CONST_SOCKADDR_ARG, __sockaddr_ipx__) - 0usize];
    ["Offset of field: __CONST_SOCKADDR_ARG::__sockaddr_iso__"]
        [::std::mem::offset_of!(__CONST_SOCKADDR_ARG, __sockaddr_iso__) - 0usize];
    ["Offset of field: __CONST_SOCKADDR_ARG::__sockaddr_ns__"]
        [::std::mem::offset_of!(__CONST_SOCKADDR_ARG, __sockaddr_ns__) - 0usize];
    ["Offset of field: __CONST_SOCKADDR_ARG::__sockaddr_un__"]
        [::std::mem::offset_of!(__CONST_SOCKADDR_ARG, __sockaddr_un__) - 0usize];
    ["Offset of field: __CONST_SOCKADDR_ARG::__sockaddr_x25__"]
        [::std::mem::offset_of!(__CONST_SOCKADDR_ARG, __sockaddr_x25__) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmsghdr {
    pub msg_hdr: msghdr,
    pub msg_len: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mmsghdr"][::std::mem::size_of::<mmsghdr>() - 64usize];
    ["Alignment of mmsghdr"][::std::mem::align_of::<mmsghdr>() - 8usize];
    ["Offset of field: mmsghdr::msg_hdr"][::std::mem::offset_of!(mmsghdr, msg_hdr) - 0usize];
    ["Offset of field: mmsghdr::msg_len"][::std::mem::offset_of!(mmsghdr, msg_len) - 56usize];
};
unsafe extern "C" {
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __addr_len: socklen_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn sendmmsg(
        __fd: ::std::os::raw::c_int,
        __vmessages: *mut mmsghdr,
        __vlen: ::std::os::raw::c_uint,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn recvmmsg(
        __fd: ::std::os::raw::c_int,
        __vmessages: *mut mmsghdr,
        __vlen: ::std::os::raw::c_uint,
        __flags: ::std::os::raw::c_int,
        __tmo: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn accept4(
        __fd: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of in_addr"][::std::mem::size_of::<in_addr>() - 4usize];
    ["Alignment of in_addr"][::std::mem::align_of::<in_addr>() - 4usize];
    ["Offset of field: in_addr::s_addr"][::std::mem::offset_of!(in_addr, s_addr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_opts"][::std::mem::size_of::<ip_opts>() - 44usize];
    ["Alignment of ip_opts"][::std::mem::align_of::<ip_opts>() - 4usize];
    ["Offset of field: ip_opts::ip_dst"][::std::mem::offset_of!(ip_opts, ip_dst) - 0usize];
    ["Offset of field: ip_opts::ip_opts"][::std::mem::offset_of!(ip_opts, ip_opts) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_mreqn"][::std::mem::size_of::<ip_mreqn>() - 12usize];
    ["Alignment of ip_mreqn"][::std::mem::align_of::<ip_mreqn>() - 4usize];
    ["Offset of field: ip_mreqn::imr_multiaddr"]
        [::std::mem::offset_of!(ip_mreqn, imr_multiaddr) - 0usize];
    ["Offset of field: ip_mreqn::imr_address"]
        [::std::mem::offset_of!(ip_mreqn, imr_address) - 4usize];
    ["Offset of field: ip_mreqn::imr_ifindex"]
        [::std::mem::offset_of!(ip_mreqn, imr_ifindex) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of in_pktinfo"][::std::mem::size_of::<in_pktinfo>() - 12usize];
    ["Alignment of in_pktinfo"][::std::mem::align_of::<in_pktinfo>() - 4usize];
    ["Offset of field: in_pktinfo::ipi_ifindex"]
        [::std::mem::offset_of!(in_pktinfo, ipi_ifindex) - 0usize];
    ["Offset of field: in_pktinfo::ipi_spec_dst"]
        [::std::mem::offset_of!(in_pktinfo, ipi_spec_dst) - 4usize];
    ["Offset of field: in_pktinfo::ipi_addr"]
        [::std::mem::offset_of!(in_pktinfo, ipi_addr) - 8usize];
};
pub const IPPROTO_IP: _bindgen_ty_8 = 0;
pub const IPPROTO_ICMP: _bindgen_ty_8 = 1;
pub const IPPROTO_IGMP: _bindgen_ty_8 = 2;
pub const IPPROTO_IPIP: _bindgen_ty_8 = 4;
pub const IPPROTO_TCP: _bindgen_ty_8 = 6;
pub const IPPROTO_EGP: _bindgen_ty_8 = 8;
pub const IPPROTO_PUP: _bindgen_ty_8 = 12;
pub const IPPROTO_UDP: _bindgen_ty_8 = 17;
pub const IPPROTO_IDP: _bindgen_ty_8 = 22;
pub const IPPROTO_TP: _bindgen_ty_8 = 29;
pub const IPPROTO_DCCP: _bindgen_ty_8 = 33;
pub const IPPROTO_IPV6: _bindgen_ty_8 = 41;
pub const IPPROTO_RSVP: _bindgen_ty_8 = 46;
pub const IPPROTO_GRE: _bindgen_ty_8 = 47;
pub const IPPROTO_ESP: _bindgen_ty_8 = 50;
pub const IPPROTO_AH: _bindgen_ty_8 = 51;
pub const IPPROTO_MTP: _bindgen_ty_8 = 92;
pub const IPPROTO_BEETPH: _bindgen_ty_8 = 94;
pub const IPPROTO_ENCAP: _bindgen_ty_8 = 98;
pub const IPPROTO_PIM: _bindgen_ty_8 = 103;
pub const IPPROTO_COMP: _bindgen_ty_8 = 108;
pub const IPPROTO_SCTP: _bindgen_ty_8 = 132;
pub const IPPROTO_UDPLITE: _bindgen_ty_8 = 136;
pub const IPPROTO_MPLS: _bindgen_ty_8 = 137;
pub const IPPROTO_ETHERNET: _bindgen_ty_8 = 143;
pub const IPPROTO_RAW: _bindgen_ty_8 = 255;
pub const IPPROTO_MPTCP: _bindgen_ty_8 = 262;
pub const IPPROTO_MAX: _bindgen_ty_8 = 263;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const IPPROTO_HOPOPTS: _bindgen_ty_9 = 0;
pub const IPPROTO_ROUTING: _bindgen_ty_9 = 43;
pub const IPPROTO_FRAGMENT: _bindgen_ty_9 = 44;
pub const IPPROTO_ICMPV6: _bindgen_ty_9 = 58;
pub const IPPROTO_NONE: _bindgen_ty_9 = 59;
pub const IPPROTO_DSTOPTS: _bindgen_ty_9 = 60;
pub const IPPROTO_MH: _bindgen_ty_9 = 135;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_10 = 7;
pub const IPPORT_DISCARD: _bindgen_ty_10 = 9;
pub const IPPORT_SYSTAT: _bindgen_ty_10 = 11;
pub const IPPORT_DAYTIME: _bindgen_ty_10 = 13;
pub const IPPORT_NETSTAT: _bindgen_ty_10 = 15;
pub const IPPORT_FTP: _bindgen_ty_10 = 21;
pub const IPPORT_TELNET: _bindgen_ty_10 = 23;
pub const IPPORT_SMTP: _bindgen_ty_10 = 25;
pub const IPPORT_TIMESERVER: _bindgen_ty_10 = 37;
pub const IPPORT_NAMESERVER: _bindgen_ty_10 = 42;
pub const IPPORT_WHOIS: _bindgen_ty_10 = 43;
pub const IPPORT_MTP: _bindgen_ty_10 = 57;
pub const IPPORT_TFTP: _bindgen_ty_10 = 69;
pub const IPPORT_RJE: _bindgen_ty_10 = 77;
pub const IPPORT_FINGER: _bindgen_ty_10 = 79;
pub const IPPORT_TTYLINK: _bindgen_ty_10 = 87;
pub const IPPORT_SUPDUP: _bindgen_ty_10 = 95;
pub const IPPORT_EXECSERVER: _bindgen_ty_10 = 512;
pub const IPPORT_LOGINSERVER: _bindgen_ty_10 = 513;
pub const IPPORT_CMDSERVER: _bindgen_ty_10 = 514;
pub const IPPORT_EFSSERVER: _bindgen_ty_10 = 520;
pub const IPPORT_BIFFUDP: _bindgen_ty_10 = 512;
pub const IPPORT_WHOSERVER: _bindgen_ty_10 = 513;
pub const IPPORT_ROUTESERVER: _bindgen_ty_10 = 520;
pub const IPPORT_RESERVED: _bindgen_ty_10 = 1024;
pub const IPPORT_USERRESERVED: _bindgen_ty_10 = 5000;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of in6_addr__bindgen_ty_1"][::std::mem::size_of::<in6_addr__bindgen_ty_1>() - 16usize];
    ["Alignment of in6_addr__bindgen_ty_1"]
        [::std::mem::align_of::<in6_addr__bindgen_ty_1>() - 4usize];
    ["Offset of field: in6_addr__bindgen_ty_1::__u6_addr8"]
        [::std::mem::offset_of!(in6_addr__bindgen_ty_1, __u6_addr8) - 0usize];
    ["Offset of field: in6_addr__bindgen_ty_1::__u6_addr16"]
        [::std::mem::offset_of!(in6_addr__bindgen_ty_1, __u6_addr16) - 0usize];
    ["Offset of field: in6_addr__bindgen_ty_1::__u6_addr32"]
        [::std::mem::offset_of!(in6_addr__bindgen_ty_1, __u6_addr32) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of in6_addr"][::std::mem::size_of::<in6_addr>() - 16usize];
    ["Alignment of in6_addr"][::std::mem::align_of::<in6_addr>() - 4usize];
    ["Offset of field: in6_addr::__in6_u"][::std::mem::offset_of!(in6_addr, __in6_u) - 0usize];
};
unsafe extern "C" {
    pub static in6addr_any: in6_addr;
}
unsafe extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sockaddr_in"][::std::mem::size_of::<sockaddr_in>() - 16usize];
    ["Alignment of sockaddr_in"][::std::mem::align_of::<sockaddr_in>() - 4usize];
    ["Offset of field: sockaddr_in::sin_family"]
        [::std::mem::offset_of!(sockaddr_in, sin_family) - 0usize];
    ["Offset of field: sockaddr_in::sin_port"]
        [::std::mem::offset_of!(sockaddr_in, sin_port) - 2usize];
    ["Offset of field: sockaddr_in::sin_addr"]
        [::std::mem::offset_of!(sockaddr_in, sin_addr) - 4usize];
    ["Offset of field: sockaddr_in::sin_zero"]
        [::std::mem::offset_of!(sockaddr_in, sin_zero) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sockaddr_in6"][::std::mem::size_of::<sockaddr_in6>() - 28usize];
    ["Alignment of sockaddr_in6"][::std::mem::align_of::<sockaddr_in6>() - 4usize];
    ["Offset of field: sockaddr_in6::sin6_family"]
        [::std::mem::offset_of!(sockaddr_in6, sin6_family) - 0usize];
    ["Offset of field: sockaddr_in6::sin6_port"]
        [::std::mem::offset_of!(sockaddr_in6, sin6_port) - 2usize];
    ["Offset of field: sockaddr_in6::sin6_flowinfo"]
        [::std::mem::offset_of!(sockaddr_in6, sin6_flowinfo) - 4usize];
    ["Offset of field: sockaddr_in6::sin6_addr"]
        [::std::mem::offset_of!(sockaddr_in6, sin6_addr) - 8usize];
    ["Offset of field: sockaddr_in6::sin6_scope_id"]
        [::std::mem::offset_of!(sockaddr_in6, sin6_scope_id) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_mreq"][::std::mem::size_of::<ip_mreq>() - 8usize];
    ["Alignment of ip_mreq"][::std::mem::align_of::<ip_mreq>() - 4usize];
    ["Offset of field: ip_mreq::imr_multiaddr"]
        [::std::mem::offset_of!(ip_mreq, imr_multiaddr) - 0usize];
    ["Offset of field: ip_mreq::imr_interface"]
        [::std::mem::offset_of!(ip_mreq, imr_interface) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_mreq_source"][::std::mem::size_of::<ip_mreq_source>() - 12usize];
    ["Alignment of ip_mreq_source"][::std::mem::align_of::<ip_mreq_source>() - 4usize];
    ["Offset of field: ip_mreq_source::imr_multiaddr"]
        [::std::mem::offset_of!(ip_mreq_source, imr_multiaddr) - 0usize];
    ["Offset of field: ip_mreq_source::imr_interface"]
        [::std::mem::offset_of!(ip_mreq_source, imr_interface) - 4usize];
    ["Offset of field: ip_mreq_source::imr_sourceaddr"]
        [::std::mem::offset_of!(ip_mreq_source, imr_sourceaddr) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ipv6_mreq"][::std::mem::size_of::<ipv6_mreq>() - 20usize];
    ["Alignment of ipv6_mreq"][::std::mem::align_of::<ipv6_mreq>() - 4usize];
    ["Offset of field: ipv6_mreq::ipv6mr_multiaddr"]
        [::std::mem::offset_of!(ipv6_mreq, ipv6mr_multiaddr) - 0usize];
    ["Offset of field: ipv6_mreq::ipv6mr_interface"]
        [::std::mem::offset_of!(ipv6_mreq, ipv6mr_interface) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of group_req"][::std::mem::size_of::<group_req>() - 136usize];
    ["Alignment of group_req"][::std::mem::align_of::<group_req>() - 8usize];
    ["Offset of field: group_req::gr_interface"]
        [::std::mem::offset_of!(group_req, gr_interface) - 0usize];
    ["Offset of field: group_req::gr_group"][::std::mem::offset_of!(group_req, gr_group) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of group_source_req"][::std::mem::size_of::<group_source_req>() - 264usize];
    ["Alignment of group_source_req"][::std::mem::align_of::<group_source_req>() - 8usize];
    ["Offset of field: group_source_req::gsr_interface"]
        [::std::mem::offset_of!(group_source_req, gsr_interface) - 0usize];
    ["Offset of field: group_source_req::gsr_group"]
        [::std::mem::offset_of!(group_source_req, gsr_group) - 8usize];
    ["Offset of field: group_source_req::gsr_source"]
        [::std::mem::offset_of!(group_source_req, gsr_source) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_msfilter"][::std::mem::size_of::<ip_msfilter>() - 20usize];
    ["Alignment of ip_msfilter"][::std::mem::align_of::<ip_msfilter>() - 4usize];
    ["Offset of field: ip_msfilter::imsf_multiaddr"]
        [::std::mem::offset_of!(ip_msfilter, imsf_multiaddr) - 0usize];
    ["Offset of field: ip_msfilter::imsf_interface"]
        [::std::mem::offset_of!(ip_msfilter, imsf_interface) - 4usize];
    ["Offset of field: ip_msfilter::imsf_fmode"]
        [::std::mem::offset_of!(ip_msfilter, imsf_fmode) - 8usize];
    ["Offset of field: ip_msfilter::imsf_numsrc"]
        [::std::mem::offset_of!(ip_msfilter, imsf_numsrc) - 12usize];
    ["Offset of field: ip_msfilter::imsf_slist"]
        [::std::mem::offset_of!(ip_msfilter, imsf_slist) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of group_filter"][::std::mem::size_of::<group_filter>() - 272usize];
    ["Alignment of group_filter"][::std::mem::align_of::<group_filter>() - 8usize];
    ["Offset of field: group_filter::gf_interface"]
        [::std::mem::offset_of!(group_filter, gf_interface) - 0usize];
    ["Offset of field: group_filter::gf_group"]
        [::std::mem::offset_of!(group_filter, gf_group) - 8usize];
    ["Offset of field: group_filter::gf_fmode"]
        [::std::mem::offset_of!(group_filter, gf_fmode) - 136usize];
    ["Offset of field: group_filter::gf_numsrc"]
        [::std::mem::offset_of!(group_filter, gf_numsrc) - 140usize];
    ["Offset of field: group_filter::gf_slist"]
        [::std::mem::offset_of!(group_filter, gf_slist) - 144usize];
};
unsafe extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
unsafe extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
unsafe extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
unsafe extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
unsafe extern "C" {
    pub fn bindresvport(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bindresvport6(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of in6_pktinfo"][::std::mem::size_of::<in6_pktinfo>() - 20usize];
    ["Alignment of in6_pktinfo"][::std::mem::align_of::<in6_pktinfo>() - 4usize];
    ["Offset of field: in6_pktinfo::ipi6_addr"]
        [::std::mem::offset_of!(in6_pktinfo, ipi6_addr) - 0usize];
    ["Offset of field: in6_pktinfo::ipi6_ifindex"]
        [::std::mem::offset_of!(in6_pktinfo, ipi6_ifindex) - 16usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip6_mtuinfo"][::std::mem::size_of::<ip6_mtuinfo>() - 32usize];
    ["Alignment of ip6_mtuinfo"][::std::mem::align_of::<ip6_mtuinfo>() - 4usize];
    ["Offset of field: ip6_mtuinfo::ip6m_addr"]
        [::std::mem::offset_of!(ip6_mtuinfo, ip6m_addr) - 0usize];
    ["Offset of field: ip6_mtuinfo::ip6m_mtu"]
        [::std::mem::offset_of!(ip6_mtuinfo, ip6m_mtu) - 28usize];
};
unsafe extern "C" {
    pub fn inet6_option_space(__nbytes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_option_init(
        __bp: *mut ::std::os::raw::c_void,
        __cmsgp: *mut *mut cmsghdr,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_option_append(
        __cmsg: *mut cmsghdr,
        __typep: *const u8,
        __multx: ::std::os::raw::c_int,
        __plusy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_option_alloc(
        __cmsg: *mut cmsghdr,
        __datalen: ::std::os::raw::c_int,
        __multx: ::std::os::raw::c_int,
        __plusy: ::std::os::raw::c_int,
    ) -> *mut u8;
}
unsafe extern "C" {
    pub fn inet6_option_next(
        __cmsg: *const cmsghdr,
        __tptrp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_option_find(
        __cmsg: *const cmsghdr,
        __tptrp: *mut *mut u8,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_opt_init(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_opt_append(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
        __offset: ::std::os::raw::c_int,
        __type: u8,
        __len: socklen_t,
        __align: u8,
        __databufp: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_opt_finish(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
        __offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_opt_set_val(
        __databuf: *mut ::std::os::raw::c_void,
        __offset: ::std::os::raw::c_int,
        __val: *mut ::std::os::raw::c_void,
        __vallen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_opt_next(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
        __offset: ::std::os::raw::c_int,
        __typep: *mut u8,
        __lenp: *mut socklen_t,
        __databufp: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_opt_find(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
        __offset: ::std::os::raw::c_int,
        __type: u8,
        __lenp: *mut socklen_t,
        __databufp: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_opt_get_val(
        __databuf: *mut ::std::os::raw::c_void,
        __offset: ::std::os::raw::c_int,
        __val: *mut ::std::os::raw::c_void,
        __vallen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_rth_space(
        __type: ::std::os::raw::c_int,
        __segments: ::std::os::raw::c_int,
    ) -> socklen_t;
}
unsafe extern "C" {
    pub fn inet6_rth_init(
        __bp: *mut ::std::os::raw::c_void,
        __bp_len: socklen_t,
        __type: ::std::os::raw::c_int,
        __segments: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn inet6_rth_add(
        __bp: *mut ::std::os::raw::c_void,
        __addr: *const in6_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_rth_reverse(
        __in: *const ::std::os::raw::c_void,
        __out: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_rth_segments(__bp: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet6_rth_getaddr(
        __bp: *const ::std::os::raw::c_void,
        __index: ::std::os::raw::c_int,
    ) -> *mut in6_addr;
}
unsafe extern "C" {
    pub fn getipv4sourcefilter(
        __s: ::std::os::raw::c_int,
        __interface_addr: in_addr,
        __group: in_addr,
        __fmode: *mut u32,
        __numsrc: *mut u32,
        __slist: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setipv4sourcefilter(
        __s: ::std::os::raw::c_int,
        __interface_addr: in_addr,
        __group: in_addr,
        __fmode: u32,
        __numsrc: u32,
        __slist: *const in_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsourcefilter(
        __s: ::std::os::raw::c_int,
        __interface_addr: u32,
        __group: *const sockaddr,
        __grouplen: socklen_t,
        __fmode: *mut u32,
        __numsrc: *mut u32,
        __slist: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setsourcefilter(
        __s: ::std::os::raw::c_int,
        __interface_addr: u32,
        __group: *const sockaddr,
        __grouplen: socklen_t,
        __fmode: u32,
        __numsrc: u32,
        __slist: *const sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
pub type tcp_seq = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcphdr {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcphdr__bindgen_ty_1 {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: tcphdr__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_1 {
    pub th_sport: u16,
    pub th_dport: u16,
    pub th_seq: tcp_seq,
    pub th_ack: tcp_seq,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub th_flags: u8,
    pub th_win: u16,
    pub th_sum: u16,
    pub th_urp: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcphdr__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<tcphdr__bindgen_ty_1__bindgen_ty_1>() - 20usize];
    ["Alignment of tcphdr__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<tcphdr__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_1::th_sport"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_1, th_sport) - 0usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_1::th_dport"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_1, th_dport) - 2usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_1::th_seq"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_1, th_seq) - 4usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_1::th_ack"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_1, th_ack) - 8usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_1::th_flags"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_1, th_flags) - 13usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_1::th_win"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_1, th_win) - 14usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_1::th_sum"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_1, th_sum) - 16usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_1::th_urp"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_1, th_urp) - 18usize];
};
impl tcphdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn th_x2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_x2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn th_x2_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_th_x2_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn th_off(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_off(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn th_off_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_th_off_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(th_x2: u8, th_off: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let th_x2: u8 = unsafe { ::std::mem::transmute(th_x2) };
            th_x2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let th_off: u8 = unsafe { ::std::mem::transmute(th_off) };
            th_off as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_2 {
    pub source: u16,
    pub dest: u16,
    pub seq: u32,
    pub ack_seq: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub window: u16,
    pub check: u16,
    pub urg_ptr: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcphdr__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::size_of::<tcphdr__bindgen_ty_1__bindgen_ty_2>() - 20usize];
    ["Alignment of tcphdr__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<tcphdr__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_2::source"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_2, source) - 0usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_2::dest"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_2, dest) - 2usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_2::seq"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_2, seq) - 4usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_2::ack_seq"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_2, ack_seq) - 8usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_2::window"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_2, window) - 14usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_2::check"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_2, check) - 16usize];
    ["Offset of field: tcphdr__bindgen_ty_1__bindgen_ty_2::urg_ptr"]
        [::std::mem::offset_of!(tcphdr__bindgen_ty_1__bindgen_ty_2, urg_ptr) - 18usize];
};
impl tcphdr__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn res1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res1_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_res1_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn doff(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_doff(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn doff_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_doff_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fin(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fin_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_fin_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn syn(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_syn(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn syn_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_syn_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rst(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rst(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rst_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_rst_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn psh(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_psh(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn psh_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_psh_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ack(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ack(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ack_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_ack_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn urg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_urg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn urg_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_urg_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res2_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_res2_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: u16,
        doff: u16,
        fin: u16,
        syn: u16,
        rst: u16,
        psh: u16,
        ack: u16,
        urg: u16,
        res2: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res1: u16 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let doff: u16 = unsafe { ::std::mem::transmute(doff) };
            doff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fin: u16 = unsafe { ::std::mem::transmute(fin) };
            fin as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let syn: u16 = unsafe { ::std::mem::transmute(syn) };
            syn as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rst: u16 = unsafe { ::std::mem::transmute(rst) };
            rst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let psh: u16 = unsafe { ::std::mem::transmute(psh) };
            psh as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ack: u16 = unsafe { ::std::mem::transmute(ack) };
            ack as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let urg: u16 = unsafe { ::std::mem::transmute(urg) };
            urg as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let res2: u16 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcphdr__bindgen_ty_1"][::std::mem::size_of::<tcphdr__bindgen_ty_1>() - 20usize];
    ["Alignment of tcphdr__bindgen_ty_1"][::std::mem::align_of::<tcphdr__bindgen_ty_1>() - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcphdr"][::std::mem::size_of::<tcphdr>() - 20usize];
    ["Alignment of tcphdr"][::std::mem::align_of::<tcphdr>() - 4usize];
};
pub const TCP_ESTABLISHED: _bindgen_ty_11 = 1;
pub const TCP_SYN_SENT: _bindgen_ty_11 = 2;
pub const TCP_SYN_RECV: _bindgen_ty_11 = 3;
pub const TCP_FIN_WAIT1: _bindgen_ty_11 = 4;
pub const TCP_FIN_WAIT2: _bindgen_ty_11 = 5;
pub const TCP_TIME_WAIT: _bindgen_ty_11 = 6;
pub const TCP_CLOSE: _bindgen_ty_11 = 7;
pub const TCP_CLOSE_WAIT: _bindgen_ty_11 = 8;
pub const TCP_LAST_ACK: _bindgen_ty_11 = 9;
pub const TCP_LISTEN: _bindgen_ty_11 = 10;
pub const TCP_CLOSING: _bindgen_ty_11 = 11;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const TCP_CA_Open: tcp_ca_state = 0;
pub const TCP_CA_Disorder: tcp_ca_state = 1;
pub const TCP_CA_CWR: tcp_ca_state = 2;
pub const TCP_CA_Recovery: tcp_ca_state = 3;
pub const TCP_CA_Loss: tcp_ca_state = 4;
pub type tcp_ca_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_info {
    pub tcpi_state: u8,
    pub tcpi_ca_state: u8,
    pub tcpi_retransmits: u8,
    pub tcpi_probes: u8,
    pub tcpi_backoff: u8,
    pub tcpi_options: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tcpi_rto: u32,
    pub tcpi_ato: u32,
    pub tcpi_snd_mss: u32,
    pub tcpi_rcv_mss: u32,
    pub tcpi_unacked: u32,
    pub tcpi_sacked: u32,
    pub tcpi_lost: u32,
    pub tcpi_retrans: u32,
    pub tcpi_fackets: u32,
    pub tcpi_last_data_sent: u32,
    pub tcpi_last_ack_sent: u32,
    pub tcpi_last_data_recv: u32,
    pub tcpi_last_ack_recv: u32,
    pub tcpi_pmtu: u32,
    pub tcpi_rcv_ssthresh: u32,
    pub tcpi_rtt: u32,
    pub tcpi_rttvar: u32,
    pub tcpi_snd_ssthresh: u32,
    pub tcpi_snd_cwnd: u32,
    pub tcpi_advmss: u32,
    pub tcpi_reordering: u32,
    pub tcpi_rcv_rtt: u32,
    pub tcpi_rcv_space: u32,
    pub tcpi_total_retrans: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcp_info"][::std::mem::size_of::<tcp_info>() - 104usize];
    ["Alignment of tcp_info"][::std::mem::align_of::<tcp_info>() - 4usize];
    ["Offset of field: tcp_info::tcpi_state"]
        [::std::mem::offset_of!(tcp_info, tcpi_state) - 0usize];
    ["Offset of field: tcp_info::tcpi_ca_state"]
        [::std::mem::offset_of!(tcp_info, tcpi_ca_state) - 1usize];
    ["Offset of field: tcp_info::tcpi_retransmits"]
        [::std::mem::offset_of!(tcp_info, tcpi_retransmits) - 2usize];
    ["Offset of field: tcp_info::tcpi_probes"]
        [::std::mem::offset_of!(tcp_info, tcpi_probes) - 3usize];
    ["Offset of field: tcp_info::tcpi_backoff"]
        [::std::mem::offset_of!(tcp_info, tcpi_backoff) - 4usize];
    ["Offset of field: tcp_info::tcpi_options"]
        [::std::mem::offset_of!(tcp_info, tcpi_options) - 5usize];
    ["Offset of field: tcp_info::tcpi_rto"][::std::mem::offset_of!(tcp_info, tcpi_rto) - 8usize];
    ["Offset of field: tcp_info::tcpi_ato"][::std::mem::offset_of!(tcp_info, tcpi_ato) - 12usize];
    ["Offset of field: tcp_info::tcpi_snd_mss"]
        [::std::mem::offset_of!(tcp_info, tcpi_snd_mss) - 16usize];
    ["Offset of field: tcp_info::tcpi_rcv_mss"]
        [::std::mem::offset_of!(tcp_info, tcpi_rcv_mss) - 20usize];
    ["Offset of field: tcp_info::tcpi_unacked"]
        [::std::mem::offset_of!(tcp_info, tcpi_unacked) - 24usize];
    ["Offset of field: tcp_info::tcpi_sacked"]
        [::std::mem::offset_of!(tcp_info, tcpi_sacked) - 28usize];
    ["Offset of field: tcp_info::tcpi_lost"][::std::mem::offset_of!(tcp_info, tcpi_lost) - 32usize];
    ["Offset of field: tcp_info::tcpi_retrans"]
        [::std::mem::offset_of!(tcp_info, tcpi_retrans) - 36usize];
    ["Offset of field: tcp_info::tcpi_fackets"]
        [::std::mem::offset_of!(tcp_info, tcpi_fackets) - 40usize];
    ["Offset of field: tcp_info::tcpi_last_data_sent"]
        [::std::mem::offset_of!(tcp_info, tcpi_last_data_sent) - 44usize];
    ["Offset of field: tcp_info::tcpi_last_ack_sent"]
        [::std::mem::offset_of!(tcp_info, tcpi_last_ack_sent) - 48usize];
    ["Offset of field: tcp_info::tcpi_last_data_recv"]
        [::std::mem::offset_of!(tcp_info, tcpi_last_data_recv) - 52usize];
    ["Offset of field: tcp_info::tcpi_last_ack_recv"]
        [::std::mem::offset_of!(tcp_info, tcpi_last_ack_recv) - 56usize];
    ["Offset of field: tcp_info::tcpi_pmtu"][::std::mem::offset_of!(tcp_info, tcpi_pmtu) - 60usize];
    ["Offset of field: tcp_info::tcpi_rcv_ssthresh"]
        [::std::mem::offset_of!(tcp_info, tcpi_rcv_ssthresh) - 64usize];
    ["Offset of field: tcp_info::tcpi_rtt"][::std::mem::offset_of!(tcp_info, tcpi_rtt) - 68usize];
    ["Offset of field: tcp_info::tcpi_rttvar"]
        [::std::mem::offset_of!(tcp_info, tcpi_rttvar) - 72usize];
    ["Offset of field: tcp_info::tcpi_snd_ssthresh"]
        [::std::mem::offset_of!(tcp_info, tcpi_snd_ssthresh) - 76usize];
    ["Offset of field: tcp_info::tcpi_snd_cwnd"]
        [::std::mem::offset_of!(tcp_info, tcpi_snd_cwnd) - 80usize];
    ["Offset of field: tcp_info::tcpi_advmss"]
        [::std::mem::offset_of!(tcp_info, tcpi_advmss) - 84usize];
    ["Offset of field: tcp_info::tcpi_reordering"]
        [::std::mem::offset_of!(tcp_info, tcpi_reordering) - 88usize];
    ["Offset of field: tcp_info::tcpi_rcv_rtt"]
        [::std::mem::offset_of!(tcp_info, tcpi_rcv_rtt) - 92usize];
    ["Offset of field: tcp_info::tcpi_rcv_space"]
        [::std::mem::offset_of!(tcp_info, tcpi_rcv_space) - 96usize];
    ["Offset of field: tcp_info::tcpi_total_retrans"]
        [::std::mem::offset_of!(tcp_info, tcpi_total_retrans) - 100usize];
};
impl tcp_info {
    #[inline]
    pub fn tcpi_snd_wscale(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_snd_wscale(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tcpi_snd_wscale_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tcpi_snd_wscale_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tcpi_rcv_wscale(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_rcv_wscale(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tcpi_rcv_wscale_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_tcpi_rcv_wscale_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tcpi_snd_wscale: u8,
        tcpi_rcv_wscale: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let tcpi_snd_wscale: u8 = unsafe { ::std::mem::transmute(tcpi_snd_wscale) };
            tcpi_snd_wscale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let tcpi_rcv_wscale: u8 = unsafe { ::std::mem::transmute(tcpi_rcv_wscale) };
            tcpi_rcv_wscale as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_md5sig {
    pub tcpm_addr: sockaddr_storage,
    pub tcpm_flags: u8,
    pub tcpm_prefixlen: u8,
    pub tcpm_keylen: u16,
    pub __tcpm_pad: u32,
    pub tcpm_key: [u8; 80usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcp_md5sig"][::std::mem::size_of::<tcp_md5sig>() - 216usize];
    ["Alignment of tcp_md5sig"][::std::mem::align_of::<tcp_md5sig>() - 8usize];
    ["Offset of field: tcp_md5sig::tcpm_addr"]
        [::std::mem::offset_of!(tcp_md5sig, tcpm_addr) - 0usize];
    ["Offset of field: tcp_md5sig::tcpm_flags"]
        [::std::mem::offset_of!(tcp_md5sig, tcpm_flags) - 128usize];
    ["Offset of field: tcp_md5sig::tcpm_prefixlen"]
        [::std::mem::offset_of!(tcp_md5sig, tcpm_prefixlen) - 129usize];
    ["Offset of field: tcp_md5sig::tcpm_keylen"]
        [::std::mem::offset_of!(tcp_md5sig, tcpm_keylen) - 130usize];
    ["Offset of field: tcp_md5sig::__tcpm_pad"]
        [::std::mem::offset_of!(tcp_md5sig, __tcpm_pad) - 132usize];
    ["Offset of field: tcp_md5sig::tcpm_key"]
        [::std::mem::offset_of!(tcp_md5sig, tcpm_key) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_repair_opt {
    pub opt_code: u32,
    pub opt_val: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcp_repair_opt"][::std::mem::size_of::<tcp_repair_opt>() - 8usize];
    ["Alignment of tcp_repair_opt"][::std::mem::align_of::<tcp_repair_opt>() - 4usize];
    ["Offset of field: tcp_repair_opt::opt_code"]
        [::std::mem::offset_of!(tcp_repair_opt, opt_code) - 0usize];
    ["Offset of field: tcp_repair_opt::opt_val"]
        [::std::mem::offset_of!(tcp_repair_opt, opt_val) - 4usize];
};
pub const TCP_NO_QUEUE: _bindgen_ty_12 = 0;
pub const TCP_RECV_QUEUE: _bindgen_ty_12 = 1;
pub const TCP_SEND_QUEUE: _bindgen_ty_12 = 2;
pub const TCP_QUEUES_NR: _bindgen_ty_12 = 3;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_cookie_transactions {
    pub tcpct_flags: u16,
    pub __tcpct_pad1: u8,
    pub tcpct_cookie_desired: u8,
    pub tcpct_s_data_desired: u16,
    pub tcpct_used: u16,
    pub tcpct_value: [u8; 536usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcp_cookie_transactions"]
        [::std::mem::size_of::<tcp_cookie_transactions>() - 544usize];
    ["Alignment of tcp_cookie_transactions"]
        [::std::mem::align_of::<tcp_cookie_transactions>() - 2usize];
    ["Offset of field: tcp_cookie_transactions::tcpct_flags"]
        [::std::mem::offset_of!(tcp_cookie_transactions, tcpct_flags) - 0usize];
    ["Offset of field: tcp_cookie_transactions::__tcpct_pad1"]
        [::std::mem::offset_of!(tcp_cookie_transactions, __tcpct_pad1) - 2usize];
    ["Offset of field: tcp_cookie_transactions::tcpct_cookie_desired"]
        [::std::mem::offset_of!(tcp_cookie_transactions, tcpct_cookie_desired) - 3usize];
    ["Offset of field: tcp_cookie_transactions::tcpct_s_data_desired"]
        [::std::mem::offset_of!(tcp_cookie_transactions, tcpct_s_data_desired) - 4usize];
    ["Offset of field: tcp_cookie_transactions::tcpct_used"]
        [::std::mem::offset_of!(tcp_cookie_transactions, tcpct_used) - 6usize];
    ["Offset of field: tcp_cookie_transactions::tcpct_value"]
        [::std::mem::offset_of!(tcp_cookie_transactions, tcpct_value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_repair_window {
    pub snd_wl1: u32,
    pub snd_wnd: u32,
    pub max_window: u32,
    pub rcv_wnd: u32,
    pub rcv_wup: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcp_repair_window"][::std::mem::size_of::<tcp_repair_window>() - 20usize];
    ["Alignment of tcp_repair_window"][::std::mem::align_of::<tcp_repair_window>() - 4usize];
    ["Offset of field: tcp_repair_window::snd_wl1"]
        [::std::mem::offset_of!(tcp_repair_window, snd_wl1) - 0usize];
    ["Offset of field: tcp_repair_window::snd_wnd"]
        [::std::mem::offset_of!(tcp_repair_window, snd_wnd) - 4usize];
    ["Offset of field: tcp_repair_window::max_window"]
        [::std::mem::offset_of!(tcp_repair_window, max_window) - 8usize];
    ["Offset of field: tcp_repair_window::rcv_wnd"]
        [::std::mem::offset_of!(tcp_repair_window, rcv_wnd) - 12usize];
    ["Offset of field: tcp_repair_window::rcv_wup"]
        [::std::mem::offset_of!(tcp_repair_window, rcv_wup) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_zerocopy_receive {
    pub address: u64,
    pub length: u32,
    pub recv_skip_hint: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tcp_zerocopy_receive"][::std::mem::size_of::<tcp_zerocopy_receive>() - 16usize];
    ["Alignment of tcp_zerocopy_receive"][::std::mem::align_of::<tcp_zerocopy_receive>() - 8usize];
    ["Offset of field: tcp_zerocopy_receive::address"]
        [::std::mem::offset_of!(tcp_zerocopy_receive, address) - 0usize];
    ["Offset of field: tcp_zerocopy_receive::length"]
        [::std::mem::offset_of!(tcp_zerocopy_receive, length) - 8usize];
    ["Offset of field: tcp_zerocopy_receive::recv_skip_hint"]
        [::std::mem::offset_of!(tcp_zerocopy_receive, recv_skip_hint) - 12usize];
};
unsafe extern "C" {
    pub fn inet_addr(__cp: *const ::std::os::raw::c_char) -> in_addr_t;
}
unsafe extern "C" {
    pub fn inet_lnaof(__in: in_addr) -> in_addr_t;
}
unsafe extern "C" {
    pub fn inet_makeaddr(__net: in_addr_t, __host: in_addr_t) -> in_addr;
}
unsafe extern "C" {
    pub fn inet_netof(__in: in_addr) -> in_addr_t;
}
unsafe extern "C" {
    pub fn inet_network(__cp: *const ::std::os::raw::c_char) -> in_addr_t;
}
unsafe extern "C" {
    pub fn inet_ntoa(__in: in_addr) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn inet_pton(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet_ntop(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __len: socklen_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn inet_aton(
        __cp: *const ::std::os::raw::c_char,
        __inp: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet_neta(
        __net: in_addr_t,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn inet_net_ntop(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_void,
        __bits: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn inet_net_pton(
        __af: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn inet_nsap_addr(
        __cp: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_uchar,
        __len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn inet_nsap_ntoa(
        __len: ::std::os::raw::c_int,
        __cp: *const ::std::os::raw::c_uchar,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub sun_family: sa_family_t,
    pub sun_path: [::std::os::raw::c_char; 108usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sockaddr_un"][::std::mem::size_of::<sockaddr_un>() - 110usize];
    ["Alignment of sockaddr_un"][::std::mem::align_of::<sockaddr_un>() - 2usize];
    ["Offset of field: sockaddr_un::sun_family"]
        [::std::mem::offset_of!(sockaddr_un, sun_family) - 0usize];
    ["Offset of field: sockaddr_un::sun_path"]
        [::std::mem::offset_of!(sockaddr_un, sun_path) - 2usize];
};
unsafe extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> __dev_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sem_t"][::std::mem::size_of::<sem_t>() - 32usize];
    ["Alignment of sem_t"][::std::mem::align_of::<sem_t>() - 8usize];
    ["Offset of field: sem_t::__size"][::std::mem::offset_of!(sem_t, __size) - 0usize];
    ["Offset of field: sem_t::__align"][::std::mem::offset_of!(sem_t, __align) - 0usize];
};
unsafe extern "C" {
    pub fn sem_init(
        __sem: *mut sem_t,
        __pshared: ::std::os::raw::c_int,
        __value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sem_destroy(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sem_open(
        __name: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> *mut sem_t;
}
unsafe extern "C" {
    pub fn sem_close(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sem_unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sem_wait(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sem_timedwait(__sem: *mut sem_t, __abstime: *const timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sem_clockwait(
        __sem: *mut sem_t,
        clock: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sem_trywait(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sem_post(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sem_getvalue(
        __sem: *mut sem_t,
        __sval: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _dl_mcount_wrapper_check(__selfpc: *mut ::std::os::raw::c_void);
}
pub type Lmid_t = ::std::os::raw::c_long;
unsafe extern "C" {
    pub fn dlopen(
        __file: *const ::std::os::raw::c_char,
        __mode: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn dlclose(__handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dlsym(
        __handle: *mut ::std::os::raw::c_void,
        __name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn dlmopen(
        __nsid: Lmid_t,
        __file: *const ::std::os::raw::c_char,
        __mode: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn dlvsym(
        __handle: *mut ::std::os::raw::c_void,
        __name: *const ::std::os::raw::c_char,
        __version: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn dlerror() -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dl_info {
    pub dli_fname: *const ::std::os::raw::c_char,
    pub dli_fbase: *mut ::std::os::raw::c_void,
    pub dli_sname: *const ::std::os::raw::c_char,
    pub dli_saddr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dl_info"][::std::mem::size_of::<Dl_info>() - 32usize];
    ["Alignment of Dl_info"][::std::mem::align_of::<Dl_info>() - 8usize];
    ["Offset of field: Dl_info::dli_fname"][::std::mem::offset_of!(Dl_info, dli_fname) - 0usize];
    ["Offset of field: Dl_info::dli_fbase"][::std::mem::offset_of!(Dl_info, dli_fbase) - 8usize];
    ["Offset of field: Dl_info::dli_sname"][::std::mem::offset_of!(Dl_info, dli_sname) - 16usize];
    ["Offset of field: Dl_info::dli_saddr"][::std::mem::offset_of!(Dl_info, dli_saddr) - 24usize];
};
unsafe extern "C" {
    pub fn dladdr(
        __address: *const ::std::os::raw::c_void,
        __info: *mut Dl_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dladdr1(
        __address: *const ::std::os::raw::c_void,
        __info: *mut Dl_info,
        __extra_info: *mut *mut ::std::os::raw::c_void,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const RTLD_DL_SYMENT: _bindgen_ty_13 = 1;
pub const RTLD_DL_LINKMAP: _bindgen_ty_13 = 2;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn dlinfo(
        __handle: *mut ::std::os::raw::c_void,
        __request: ::std::os::raw::c_int,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub const RTLD_DI_LMID: _bindgen_ty_14 = 1;
pub const RTLD_DI_LINKMAP: _bindgen_ty_14 = 2;
pub const RTLD_DI_CONFIGADDR: _bindgen_ty_14 = 3;
pub const RTLD_DI_SERINFO: _bindgen_ty_14 = 4;
pub const RTLD_DI_SERINFOSIZE: _bindgen_ty_14 = 5;
pub const RTLD_DI_ORIGIN: _bindgen_ty_14 = 6;
pub const RTLD_DI_PROFILENAME: _bindgen_ty_14 = 7;
pub const RTLD_DI_PROFILEOUT: _bindgen_ty_14 = 8;
pub const RTLD_DI_TLS_MODID: _bindgen_ty_14 = 9;
pub const RTLD_DI_TLS_DATA: _bindgen_ty_14 = 10;
pub const RTLD_DI_MAX: _bindgen_ty_14 = 10;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dl_serpath {
    pub dls_name: *mut ::std::os::raw::c_char,
    pub dls_flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dl_serpath"][::std::mem::size_of::<Dl_serpath>() - 16usize];
    ["Alignment of Dl_serpath"][::std::mem::align_of::<Dl_serpath>() - 8usize];
    ["Offset of field: Dl_serpath::dls_name"]
        [::std::mem::offset_of!(Dl_serpath, dls_name) - 0usize];
    ["Offset of field: Dl_serpath::dls_flags"]
        [::std::mem::offset_of!(Dl_serpath, dls_flags) - 8usize];
};
#[repr(C)]
pub struct Dl_serinfo {
    pub dls_size: usize,
    pub dls_cnt: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: Dl_serinfo__bindgen_ty_1,
}
#[repr(C)]
pub struct Dl_serinfo__bindgen_ty_1 {
    pub dls_serpath: __BindgenUnionField<[Dl_serpath; 0usize]>,
    pub __dls_serpath_pad: __BindgenUnionField<[Dl_serpath; 1usize]>,
    pub bindgen_union_field: [u64; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dl_serinfo__bindgen_ty_1"]
        [::std::mem::size_of::<Dl_serinfo__bindgen_ty_1>() - 16usize];
    ["Alignment of Dl_serinfo__bindgen_ty_1"]
        [::std::mem::align_of::<Dl_serinfo__bindgen_ty_1>() - 8usize];
    ["Offset of field: Dl_serinfo__bindgen_ty_1::dls_serpath"]
        [::std::mem::offset_of!(Dl_serinfo__bindgen_ty_1, dls_serpath) - 0usize];
    ["Offset of field: Dl_serinfo__bindgen_ty_1::__dls_serpath_pad"]
        [::std::mem::offset_of!(Dl_serinfo__bindgen_ty_1, __dls_serpath_pad) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Dl_serinfo"][::std::mem::size_of::<Dl_serinfo>() - 32usize];
    ["Alignment of Dl_serinfo"][::std::mem::align_of::<Dl_serinfo>() - 8usize];
    ["Offset of field: Dl_serinfo::dls_size"]
        [::std::mem::offset_of!(Dl_serinfo, dls_size) - 0usize];
    ["Offset of field: Dl_serinfo::dls_cnt"][::std::mem::offset_of!(Dl_serinfo, dls_cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dl_find_object {
    pub dlfo_flags: ::std::os::raw::c_ulonglong,
    pub dlfo_map_start: *mut ::std::os::raw::c_void,
    pub dlfo_map_end: *mut ::std::os::raw::c_void,
    pub dlfo_link_map: *mut link_map,
    pub dlfo_eh_frame: *mut ::std::os::raw::c_void,
    pub __dflo_reserved: [::std::os::raw::c_ulonglong; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of dl_find_object"][::std::mem::size_of::<dl_find_object>() - 96usize];
    ["Alignment of dl_find_object"][::std::mem::align_of::<dl_find_object>() - 8usize];
    ["Offset of field: dl_find_object::dlfo_flags"]
        [::std::mem::offset_of!(dl_find_object, dlfo_flags) - 0usize];
    ["Offset of field: dl_find_object::dlfo_map_start"]
        [::std::mem::offset_of!(dl_find_object, dlfo_map_start) - 8usize];
    ["Offset of field: dl_find_object::dlfo_map_end"]
        [::std::mem::offset_of!(dl_find_object, dlfo_map_end) - 16usize];
    ["Offset of field: dl_find_object::dlfo_link_map"]
        [::std::mem::offset_of!(dl_find_object, dlfo_link_map) - 24usize];
    ["Offset of field: dl_find_object::dlfo_eh_frame"]
        [::std::mem::offset_of!(dl_find_object, dlfo_eh_frame) - 32usize];
    ["Offset of field: dl_find_object::__dflo_reserved"]
        [::std::mem::offset_of!(dl_find_object, __dflo_reserved) - 40usize];
};
unsafe extern "C" {
    pub fn _dl_find_object(
        __address: *mut ::std::os::raw::c_void,
        __result: *mut dl_find_object,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rpcent"][::std::mem::size_of::<rpcent>() - 24usize];
    ["Alignment of rpcent"][::std::mem::align_of::<rpcent>() - 8usize];
    ["Offset of field: rpcent::r_name"][::std::mem::offset_of!(rpcent, r_name) - 0usize];
    ["Offset of field: rpcent::r_aliases"][::std::mem::offset_of!(rpcent, r_aliases) - 8usize];
    ["Offset of field: rpcent::r_number"][::std::mem::offset_of!(rpcent, r_number) - 16usize];
};
unsafe extern "C" {
    pub fn setrpcent(__stayopen: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn endrpcent();
}
unsafe extern "C" {
    pub fn getrpcbyname(__name: *const ::std::os::raw::c_char) -> *mut rpcent;
}
unsafe extern "C" {
    pub fn getrpcbynumber(__number: ::std::os::raw::c_int) -> *mut rpcent;
}
unsafe extern "C" {
    pub fn getrpcent() -> *mut rpcent;
}
unsafe extern "C" {
    pub fn getrpcbyname_r(
        __name: *const ::std::os::raw::c_char,
        __result_buf: *mut rpcent,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut rpcent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getrpcbynumber_r(
        __number: ::std::os::raw::c_int,
        __result_buf: *mut rpcent,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut rpcent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getrpcent_r(
        __result_buf: *mut rpcent,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut rpcent,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigval"][::std::mem::size_of::<sigval>() - 8usize];
    ["Alignment of sigval"][::std::mem::align_of::<sigval>() - 8usize];
    ["Offset of field: sigval::sival_int"][::std::mem::offset_of!(sigval, sival_int) - 0usize];
    ["Offset of field: sigval::sival_ptr"][::std::mem::offset_of!(sigval, sival_ptr) - 0usize];
};
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>() - 16usize];
    ["Alignment of sigevent__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigevent__bindgen_ty_1__bindgen_ty_1::_function"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1__bindgen_ty_1, _function) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1__bindgen_ty_1::_attribute"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1__bindgen_ty_1, _attribute) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent__bindgen_ty_1"][::std::mem::size_of::<sigevent__bindgen_ty_1>() - 48usize];
    ["Alignment of sigevent__bindgen_ty_1"]
        [::std::mem::align_of::<sigevent__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigevent__bindgen_ty_1::_pad"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _pad) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1::_tid"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _tid) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1::_sigev_thread"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _sigev_thread) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent"][::std::mem::size_of::<sigevent>() - 64usize];
    ["Alignment of sigevent"][::std::mem::align_of::<sigevent>() - 8usize];
    ["Offset of field: sigevent::sigev_value"]
        [::std::mem::offset_of!(sigevent, sigev_value) - 0usize];
    ["Offset of field: sigevent::sigev_signo"]
        [::std::mem::offset_of!(sigevent, sigev_signo) - 8usize];
    ["Offset of field: sigevent::sigev_notify"]
        [::std::mem::offset_of!(sigevent, sigev_notify) - 12usize];
    ["Offset of field: sigevent::_sigev_un"][::std::mem::offset_of!(sigevent, _sigev_un) - 16usize];
};
pub type sigevent_t = sigevent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of netent"][::std::mem::size_of::<netent>() - 24usize];
    ["Alignment of netent"][::std::mem::align_of::<netent>() - 8usize];
    ["Offset of field: netent::n_name"][::std::mem::offset_of!(netent, n_name) - 0usize];
    ["Offset of field: netent::n_aliases"][::std::mem::offset_of!(netent, n_aliases) - 8usize];
    ["Offset of field: netent::n_addrtype"][::std::mem::offset_of!(netent, n_addrtype) - 16usize];
    ["Offset of field: netent::n_net"][::std::mem::offset_of!(netent, n_net) - 20usize];
};
unsafe extern "C" {
    pub fn __h_errno_location() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn herror(__str: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn hstrerror(__err_num: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hostent"][::std::mem::size_of::<hostent>() - 32usize];
    ["Alignment of hostent"][::std::mem::align_of::<hostent>() - 8usize];
    ["Offset of field: hostent::h_name"][::std::mem::offset_of!(hostent, h_name) - 0usize];
    ["Offset of field: hostent::h_aliases"][::std::mem::offset_of!(hostent, h_aliases) - 8usize];
    ["Offset of field: hostent::h_addrtype"][::std::mem::offset_of!(hostent, h_addrtype) - 16usize];
    ["Offset of field: hostent::h_length"][::std::mem::offset_of!(hostent, h_length) - 20usize];
    ["Offset of field: hostent::h_addr_list"]
        [::std::mem::offset_of!(hostent, h_addr_list) - 24usize];
};
unsafe extern "C" {
    pub fn sethostent(__stay_open: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn endhostent();
}
unsafe extern "C" {
    pub fn gethostent() -> *mut hostent;
}
unsafe extern "C" {
    pub fn gethostbyaddr(
        __addr: *const ::std::os::raw::c_void,
        __len: __socklen_t,
        __type: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
unsafe extern "C" {
    pub fn gethostbyname(__name: *const ::std::os::raw::c_char) -> *mut hostent;
}
unsafe extern "C" {
    pub fn gethostbyname2(
        __name: *const ::std::os::raw::c_char,
        __af: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
unsafe extern "C" {
    pub fn gethostent_r(
        __result_buf: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostbyaddr_r(
        __addr: *const ::std::os::raw::c_void,
        __len: __socklen_t,
        __type: ::std::os::raw::c_int,
        __result_buf: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostbyname_r(
        __name: *const ::std::os::raw::c_char,
        __result_buf: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostbyname2_r(
        __name: *const ::std::os::raw::c_char,
        __af: ::std::os::raw::c_int,
        __result_buf: *mut hostent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setnetent(__stay_open: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn endnetent();
}
unsafe extern "C" {
    pub fn getnetent() -> *mut netent;
}
unsafe extern "C" {
    pub fn getnetbyaddr(__net: u32, __type: ::std::os::raw::c_int) -> *mut netent;
}
unsafe extern "C" {
    pub fn getnetbyname(__name: *const ::std::os::raw::c_char) -> *mut netent;
}
unsafe extern "C" {
    pub fn getnetent_r(
        __result_buf: *mut netent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut netent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getnetbyaddr_r(
        __net: u32,
        __type: ::std::os::raw::c_int,
        __result_buf: *mut netent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut netent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getnetbyname_r(
        __name: *const ::std::os::raw::c_char,
        __result_buf: *mut netent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut netent,
        __h_errnop: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of servent"][::std::mem::size_of::<servent>() - 32usize];
    ["Alignment of servent"][::std::mem::align_of::<servent>() - 8usize];
    ["Offset of field: servent::s_name"][::std::mem::offset_of!(servent, s_name) - 0usize];
    ["Offset of field: servent::s_aliases"][::std::mem::offset_of!(servent, s_aliases) - 8usize];
    ["Offset of field: servent::s_port"][::std::mem::offset_of!(servent, s_port) - 16usize];
    ["Offset of field: servent::s_proto"][::std::mem::offset_of!(servent, s_proto) - 24usize];
};
unsafe extern "C" {
    pub fn setservent(__stay_open: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn endservent();
}
unsafe extern "C" {
    pub fn getservent() -> *mut servent;
}
unsafe extern "C" {
    pub fn getservbyname(
        __name: *const ::std::os::raw::c_char,
        __proto: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
unsafe extern "C" {
    pub fn getservbyport(
        __port: ::std::os::raw::c_int,
        __proto: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
unsafe extern "C" {
    pub fn getservent_r(
        __result_buf: *mut servent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut servent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getservbyname_r(
        __name: *const ::std::os::raw::c_char,
        __proto: *const ::std::os::raw::c_char,
        __result_buf: *mut servent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut servent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getservbyport_r(
        __port: ::std::os::raw::c_int,
        __proto: *const ::std::os::raw::c_char,
        __result_buf: *mut servent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut servent,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of protoent"][::std::mem::size_of::<protoent>() - 24usize];
    ["Alignment of protoent"][::std::mem::align_of::<protoent>() - 8usize];
    ["Offset of field: protoent::p_name"][::std::mem::offset_of!(protoent, p_name) - 0usize];
    ["Offset of field: protoent::p_aliases"][::std::mem::offset_of!(protoent, p_aliases) - 8usize];
    ["Offset of field: protoent::p_proto"][::std::mem::offset_of!(protoent, p_proto) - 16usize];
};
unsafe extern "C" {
    pub fn setprotoent(__stay_open: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn endprotoent();
}
unsafe extern "C" {
    pub fn getprotoent() -> *mut protoent;
}
unsafe extern "C" {
    pub fn getprotobyname(__name: *const ::std::os::raw::c_char) -> *mut protoent;
}
unsafe extern "C" {
    pub fn getprotobynumber(__proto: ::std::os::raw::c_int) -> *mut protoent;
}
unsafe extern "C" {
    pub fn getprotoent_r(
        __result_buf: *mut protoent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut protoent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getprotobyname_r(
        __name: *const ::std::os::raw::c_char,
        __result_buf: *mut protoent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut protoent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getprotobynumber_r(
        __proto: ::std::os::raw::c_int,
        __result_buf: *mut protoent,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut protoent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setnetgrent(__netgroup: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn endnetgrent();
}
unsafe extern "C" {
    pub fn getnetgrent(
        __hostp: *mut *mut ::std::os::raw::c_char,
        __userp: *mut *mut ::std::os::raw::c_char,
        __domainp: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn innetgr(
        __netgroup: *const ::std::os::raw::c_char,
        __host: *const ::std::os::raw::c_char,
        __user: *const ::std::os::raw::c_char,
        __domain: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getnetgrent_r(
        __hostp: *mut *mut ::std::os::raw::c_char,
        __userp: *mut *mut ::std::os::raw::c_char,
        __domainp: *mut *mut ::std::os::raw::c_char,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rcmd(
        __ahost: *mut *mut ::std::os::raw::c_char,
        __rport: ::std::os::raw::c_ushort,
        __locuser: *const ::std::os::raw::c_char,
        __remuser: *const ::std::os::raw::c_char,
        __cmd: *const ::std::os::raw::c_char,
        __fd2p: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rcmd_af(
        __ahost: *mut *mut ::std::os::raw::c_char,
        __rport: ::std::os::raw::c_ushort,
        __locuser: *const ::std::os::raw::c_char,
        __remuser: *const ::std::os::raw::c_char,
        __cmd: *const ::std::os::raw::c_char,
        __fd2p: *mut ::std::os::raw::c_int,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rexec(
        __ahost: *mut *mut ::std::os::raw::c_char,
        __rport: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __pass: *const ::std::os::raw::c_char,
        __cmd: *const ::std::os::raw::c_char,
        __fd2p: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rexec_af(
        __ahost: *mut *mut ::std::os::raw::c_char,
        __rport: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __pass: *const ::std::os::raw::c_char,
        __cmd: *const ::std::os::raw::c_char,
        __fd2p: *mut ::std::os::raw::c_int,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ruserok(
        __rhost: *const ::std::os::raw::c_char,
        __suser: ::std::os::raw::c_int,
        __remuser: *const ::std::os::raw::c_char,
        __locuser: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ruserok_af(
        __rhost: *const ::std::os::raw::c_char,
        __suser: ::std::os::raw::c_int,
        __remuser: *const ::std::os::raw::c_char,
        __locuser: *const ::std::os::raw::c_char,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iruserok(
        __raddr: u32,
        __suser: ::std::os::raw::c_int,
        __remuser: *const ::std::os::raw::c_char,
        __locuser: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iruserok_af(
        __raddr: *const ::std::os::raw::c_void,
        __suser: ::std::os::raw::c_int,
        __remuser: *const ::std::os::raw::c_char,
        __locuser: *const ::std::os::raw::c_char,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rresvport(__alport: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rresvport_af(
        __alport: *mut ::std::os::raw::c_int,
        __af: sa_family_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_next: *mut addrinfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of addrinfo"][::std::mem::size_of::<addrinfo>() - 48usize];
    ["Alignment of addrinfo"][::std::mem::align_of::<addrinfo>() - 8usize];
    ["Offset of field: addrinfo::ai_flags"][::std::mem::offset_of!(addrinfo, ai_flags) - 0usize];
    ["Offset of field: addrinfo::ai_family"][::std::mem::offset_of!(addrinfo, ai_family) - 4usize];
    ["Offset of field: addrinfo::ai_socktype"]
        [::std::mem::offset_of!(addrinfo, ai_socktype) - 8usize];
    ["Offset of field: addrinfo::ai_protocol"]
        [::std::mem::offset_of!(addrinfo, ai_protocol) - 12usize];
    ["Offset of field: addrinfo::ai_addrlen"]
        [::std::mem::offset_of!(addrinfo, ai_addrlen) - 16usize];
    ["Offset of field: addrinfo::ai_addr"][::std::mem::offset_of!(addrinfo, ai_addr) - 24usize];
    ["Offset of field: addrinfo::ai_canonname"]
        [::std::mem::offset_of!(addrinfo, ai_canonname) - 32usize];
    ["Offset of field: addrinfo::ai_next"][::std::mem::offset_of!(addrinfo, ai_next) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gaicb {
    pub ar_name: *const ::std::os::raw::c_char,
    pub ar_service: *const ::std::os::raw::c_char,
    pub ar_request: *const addrinfo,
    pub ar_result: *mut addrinfo,
    pub __return: ::std::os::raw::c_int,
    pub __glibc_reserved: [::std::os::raw::c_int; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gaicb"][::std::mem::size_of::<gaicb>() - 56usize];
    ["Alignment of gaicb"][::std::mem::align_of::<gaicb>() - 8usize];
    ["Offset of field: gaicb::ar_name"][::std::mem::offset_of!(gaicb, ar_name) - 0usize];
    ["Offset of field: gaicb::ar_service"][::std::mem::offset_of!(gaicb, ar_service) - 8usize];
    ["Offset of field: gaicb::ar_request"][::std::mem::offset_of!(gaicb, ar_request) - 16usize];
    ["Offset of field: gaicb::ar_result"][::std::mem::offset_of!(gaicb, ar_result) - 24usize];
    ["Offset of field: gaicb::__return"][::std::mem::offset_of!(gaicb, __return) - 32usize];
    ["Offset of field: gaicb::__glibc_reserved"]
        [::std::mem::offset_of!(gaicb, __glibc_reserved) - 36usize];
};
unsafe extern "C" {
    pub fn getaddrinfo(
        __name: *const ::std::os::raw::c_char,
        __service: *const ::std::os::raw::c_char,
        __req: *const addrinfo,
        __pai: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn freeaddrinfo(__ai: *mut addrinfo);
}
unsafe extern "C" {
    pub fn gai_strerror(__ecode: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getnameinfo(
        __sa: *const sockaddr,
        __salen: socklen_t,
        __host: *mut ::std::os::raw::c_char,
        __hostlen: socklen_t,
        __serv: *mut ::std::os::raw::c_char,
        __servlen: socklen_t,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getaddrinfo_a(
        __mode: ::std::os::raw::c_int,
        __list: *mut *mut gaicb,
        __ent: ::std::os::raw::c_int,
        __sig: *mut sigevent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gai_suspend(
        __list: *const *const gaicb,
        __ent: ::std::os::raw::c_int,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gai_error(__req: *mut gaicb) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gai_cancel(__gaicbp: *mut gaicb) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct passwd {
    pub pw_name: *mut ::std::os::raw::c_char,
    pub pw_passwd: *mut ::std::os::raw::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut ::std::os::raw::c_char,
    pub pw_dir: *mut ::std::os::raw::c_char,
    pub pw_shell: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of passwd"][::std::mem::size_of::<passwd>() - 48usize];
    ["Alignment of passwd"][::std::mem::align_of::<passwd>() - 8usize];
    ["Offset of field: passwd::pw_name"][::std::mem::offset_of!(passwd, pw_name) - 0usize];
    ["Offset of field: passwd::pw_passwd"][::std::mem::offset_of!(passwd, pw_passwd) - 8usize];
    ["Offset of field: passwd::pw_uid"][::std::mem::offset_of!(passwd, pw_uid) - 16usize];
    ["Offset of field: passwd::pw_gid"][::std::mem::offset_of!(passwd, pw_gid) - 20usize];
    ["Offset of field: passwd::pw_gecos"][::std::mem::offset_of!(passwd, pw_gecos) - 24usize];
    ["Offset of field: passwd::pw_dir"][::std::mem::offset_of!(passwd, pw_dir) - 32usize];
    ["Offset of field: passwd::pw_shell"][::std::mem::offset_of!(passwd, pw_shell) - 40usize];
};
unsafe extern "C" {
    pub fn setpwent();
}
unsafe extern "C" {
    pub fn endpwent();
}
unsafe extern "C" {
    pub fn getpwent() -> *mut passwd;
}
unsafe extern "C" {
    pub fn fgetpwent(__stream: *mut FILE) -> *mut passwd;
}
unsafe extern "C" {
    pub fn putpwent(__p: *const passwd, __f: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpwuid(__uid: __uid_t) -> *mut passwd;
}
unsafe extern "C" {
    pub fn getpwnam(__name: *const ::std::os::raw::c_char) -> *mut passwd;
}
unsafe extern "C" {
    pub fn getpwent_r(
        __resultbuf: *mut passwd,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpwuid_r(
        __uid: __uid_t,
        __resultbuf: *mut passwd,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpwnam_r(
        __name: *const ::std::os::raw::c_char,
        __resultbuf: *mut passwd,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetpwent_r(
        __stream: *mut FILE,
        __resultbuf: *mut passwd,
        __buffer: *mut ::std::os::raw::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpw(__uid: __uid_t, __buffer: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __jmp_buf_tag"][::std::mem::size_of::<__jmp_buf_tag>() - 200usize];
    ["Alignment of __jmp_buf_tag"][::std::mem::align_of::<__jmp_buf_tag>() - 8usize];
    ["Offset of field: __jmp_buf_tag::__jmpbuf"]
        [::std::mem::offset_of!(__jmp_buf_tag, __jmpbuf) - 0usize];
    ["Offset of field: __jmp_buf_tag::__mask_was_saved"]
        [::std::mem::offset_of!(__jmp_buf_tag, __mask_was_saved) - 64usize];
    ["Offset of field: __jmp_buf_tag::__saved_mask"]
        [::std::mem::offset_of!(__jmp_buf_tag, __saved_mask) - 72usize];
};
pub type jmp_buf = [__jmp_buf_tag; 1usize];
unsafe extern "C" {
    pub fn setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int) -> !;
}
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
unsafe extern "C" {
    pub fn siglongjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int) -> !;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __pad0: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_1::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_1, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_1::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_1, si_uid) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: __sigval_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_tid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_tid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_overrun"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_overrun) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_sigval"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_sigval) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_uid) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_sigval"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_sigval) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>() - 32usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_uid) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_status"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_status) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_utime"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_utime) - 16usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_stime"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_stime) - 24usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(
        ) - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(
        ) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1::_lower"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 , _lower) - 0usize] ;
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1::_upper"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 , _upper) - 8usize] ;
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1::_addr_bnd"][::std::mem::offset_of!(
        siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
        _addr_bnd
    ) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1::_pkey"][::std::mem::offset_of!(
        siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
        _pkey
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>() - 32usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::si_addr"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, si_addr) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::si_addr_lsb"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, si_addr_lsb) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::_bounds"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, _bounds) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_6::si_band"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_6, si_band) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_6::si_fd"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_6, si_fd) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_call_addr"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _call_addr) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_syscall"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _syscall) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_arch"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _arch) - 12usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1>() - 112usize];
    ["Alignment of siginfo_t__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_pad"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _pad) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_kill"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _kill) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_timer"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _timer) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_rt"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _rt) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigchld"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigchld) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigfault"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigfault) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigpoll"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigpoll) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigsys"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigsys) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t"][::std::mem::size_of::<siginfo_t>() - 128usize];
    ["Alignment of siginfo_t"][::std::mem::align_of::<siginfo_t>() - 8usize];
    ["Offset of field: siginfo_t::si_signo"][::std::mem::offset_of!(siginfo_t, si_signo) - 0usize];
    ["Offset of field: siginfo_t::si_errno"][::std::mem::offset_of!(siginfo_t, si_errno) - 4usize];
    ["Offset of field: siginfo_t::si_code"][::std::mem::offset_of!(siginfo_t, si_code) - 8usize];
    ["Offset of field: siginfo_t::__pad0"][::std::mem::offset_of!(siginfo_t, __pad0) - 12usize];
    ["Offset of field: siginfo_t::_sifields"]
        [::std::mem::offset_of!(siginfo_t, _sifields) - 16usize];
};
pub const SI_ASYNCNL: _bindgen_ty_15 = -60;
pub const SI_DETHREAD: _bindgen_ty_15 = -7;
pub const SI_TKILL: _bindgen_ty_15 = -6;
pub const SI_SIGIO: _bindgen_ty_15 = -5;
pub const SI_ASYNCIO: _bindgen_ty_15 = -4;
pub const SI_MESGQ: _bindgen_ty_15 = -3;
pub const SI_TIMER: _bindgen_ty_15 = -2;
pub const SI_QUEUE: _bindgen_ty_15 = -1;
pub const SI_USER: _bindgen_ty_15 = 0;
pub const SI_KERNEL: _bindgen_ty_15 = 128;
pub type _bindgen_ty_15 = ::std::os::raw::c_int;
pub const ILL_ILLOPC: _bindgen_ty_16 = 1;
pub const ILL_ILLOPN: _bindgen_ty_16 = 2;
pub const ILL_ILLADR: _bindgen_ty_16 = 3;
pub const ILL_ILLTRP: _bindgen_ty_16 = 4;
pub const ILL_PRVOPC: _bindgen_ty_16 = 5;
pub const ILL_PRVREG: _bindgen_ty_16 = 6;
pub const ILL_COPROC: _bindgen_ty_16 = 7;
pub const ILL_BADSTK: _bindgen_ty_16 = 8;
pub const ILL_BADIADDR: _bindgen_ty_16 = 9;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const FPE_INTDIV: _bindgen_ty_17 = 1;
pub const FPE_INTOVF: _bindgen_ty_17 = 2;
pub const FPE_FLTDIV: _bindgen_ty_17 = 3;
pub const FPE_FLTOVF: _bindgen_ty_17 = 4;
pub const FPE_FLTUND: _bindgen_ty_17 = 5;
pub const FPE_FLTRES: _bindgen_ty_17 = 6;
pub const FPE_FLTINV: _bindgen_ty_17 = 7;
pub const FPE_FLTSUB: _bindgen_ty_17 = 8;
pub const FPE_FLTUNK: _bindgen_ty_17 = 14;
pub const FPE_CONDTRAP: _bindgen_ty_17 = 15;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const SEGV_MAPERR: _bindgen_ty_18 = 1;
pub const SEGV_ACCERR: _bindgen_ty_18 = 2;
pub const SEGV_BNDERR: _bindgen_ty_18 = 3;
pub const SEGV_PKUERR: _bindgen_ty_18 = 4;
pub const SEGV_ACCADI: _bindgen_ty_18 = 5;
pub const SEGV_ADIDERR: _bindgen_ty_18 = 6;
pub const SEGV_ADIPERR: _bindgen_ty_18 = 7;
pub const SEGV_MTEAERR: _bindgen_ty_18 = 8;
pub const SEGV_MTESERR: _bindgen_ty_18 = 9;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub const BUS_ADRALN: _bindgen_ty_19 = 1;
pub const BUS_ADRERR: _bindgen_ty_19 = 2;
pub const BUS_OBJERR: _bindgen_ty_19 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_19 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_19 = 5;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const TRAP_BRKPT: _bindgen_ty_20 = 1;
pub const TRAP_TRACE: _bindgen_ty_20 = 2;
pub const TRAP_BRANCH: _bindgen_ty_20 = 3;
pub const TRAP_HWBKPT: _bindgen_ty_20 = 4;
pub const TRAP_UNK: _bindgen_ty_20 = 5;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
pub const CLD_EXITED: _bindgen_ty_21 = 1;
pub const CLD_KILLED: _bindgen_ty_21 = 2;
pub const CLD_DUMPED: _bindgen_ty_21 = 3;
pub const CLD_TRAPPED: _bindgen_ty_21 = 4;
pub const CLD_STOPPED: _bindgen_ty_21 = 5;
pub const CLD_CONTINUED: _bindgen_ty_21 = 6;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const POLL_IN: _bindgen_ty_22 = 1;
pub const POLL_OUT: _bindgen_ty_22 = 2;
pub const POLL_MSG: _bindgen_ty_22 = 3;
pub const POLL_ERR: _bindgen_ty_22 = 4;
pub const POLL_PRI: _bindgen_ty_22 = 5;
pub const POLL_HUP: _bindgen_ty_22 = 6;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub type sigval_t = __sigval_t;
pub const SIGEV_SIGNAL: _bindgen_ty_23 = 0;
pub const SIGEV_NONE: _bindgen_ty_23 = 1;
pub const SIGEV_THREAD: _bindgen_ty_23 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_23 = 4;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
unsafe extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
        -> __sighandler_t;
}
unsafe extern "C" {
    pub fn sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
unsafe extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
unsafe extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
unsafe extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int, __s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_sigpause"]
    pub fn sigpause(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sighandler_t = __sighandler_t;
pub type sig_t = __sighandler_t;
unsafe extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigisemptyset(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigandset(
        __set: *mut sigset_t,
        __left: *const sigset_t,
        __right: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigorset(
        __set: *mut sigset_t,
        __left: *const sigset_t,
        __right: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction__bindgen_ty_1"][::std::mem::size_of::<sigaction__bindgen_ty_1>() - 8usize];
    ["Alignment of sigaction__bindgen_ty_1"]
        [::std::mem::align_of::<sigaction__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigaction__bindgen_ty_1::sa_handler"]
        [::std::mem::offset_of!(sigaction__bindgen_ty_1, sa_handler) - 0usize];
    ["Offset of field: sigaction__bindgen_ty_1::sa_sigaction"]
        [::std::mem::offset_of!(sigaction__bindgen_ty_1, sa_sigaction) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction"][::std::mem::size_of::<sigaction>() - 152usize];
    ["Alignment of sigaction"][::std::mem::align_of::<sigaction>() - 8usize];
    ["Offset of field: sigaction::__sigaction_handler"]
        [::std::mem::offset_of!(sigaction, __sigaction_handler) - 0usize];
    ["Offset of field: sigaction::sa_mask"][::std::mem::offset_of!(sigaction, sa_mask) - 8usize];
    ["Offset of field: sigaction::sa_flags"]
        [::std::mem::offset_of!(sigaction, sa_flags) - 136usize];
    ["Offset of field: sigaction::sa_restorer"]
        [::std::mem::offset_of!(sigaction, sa_restorer) - 144usize];
};
unsafe extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigaction(
        __sig: ::std::os::raw::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigqueue(
        __pid: __pid_t,
        __sig: ::std::os::raw::c_int,
        __val: sigval,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpx_sw_bytes"][::std::mem::size_of::<_fpx_sw_bytes>() - 48usize];
    ["Alignment of _fpx_sw_bytes"][::std::mem::align_of::<_fpx_sw_bytes>() - 8usize];
    ["Offset of field: _fpx_sw_bytes::magic1"]
        [::std::mem::offset_of!(_fpx_sw_bytes, magic1) - 0usize];
    ["Offset of field: _fpx_sw_bytes::extended_size"]
        [::std::mem::offset_of!(_fpx_sw_bytes, extended_size) - 4usize];
    ["Offset of field: _fpx_sw_bytes::xstate_bv"]
        [::std::mem::offset_of!(_fpx_sw_bytes, xstate_bv) - 8usize];
    ["Offset of field: _fpx_sw_bytes::xstate_size"]
        [::std::mem::offset_of!(_fpx_sw_bytes, xstate_size) - 16usize];
    ["Offset of field: _fpx_sw_bytes::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpx_sw_bytes, __glibc_reserved1) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpreg"][::std::mem::size_of::<_fpreg>() - 10usize];
    ["Alignment of _fpreg"][::std::mem::align_of::<_fpreg>() - 2usize];
    ["Offset of field: _fpreg::significand"][::std::mem::offset_of!(_fpreg, significand) - 0usize];
    ["Offset of field: _fpreg::exponent"][::std::mem::offset_of!(_fpreg, exponent) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpxreg"][::std::mem::size_of::<_fpxreg>() - 16usize];
    ["Alignment of _fpxreg"][::std::mem::align_of::<_fpxreg>() - 2usize];
    ["Offset of field: _fpxreg::significand"]
        [::std::mem::offset_of!(_fpxreg, significand) - 0usize];
    ["Offset of field: _fpxreg::exponent"][::std::mem::offset_of!(_fpxreg, exponent) - 8usize];
    ["Offset of field: _fpxreg::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpxreg, __glibc_reserved1) - 10usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xmmreg"][::std::mem::size_of::<_xmmreg>() - 16usize];
    ["Alignment of _xmmreg"][::std::mem::align_of::<_xmmreg>() - 4usize];
    ["Offset of field: _xmmreg::element"][::std::mem::offset_of!(_xmmreg, element) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpstate"][::std::mem::size_of::<_fpstate>() - 512usize];
    ["Alignment of _fpstate"][::std::mem::align_of::<_fpstate>() - 8usize];
    ["Offset of field: _fpstate::cwd"][::std::mem::offset_of!(_fpstate, cwd) - 0usize];
    ["Offset of field: _fpstate::swd"][::std::mem::offset_of!(_fpstate, swd) - 2usize];
    ["Offset of field: _fpstate::ftw"][::std::mem::offset_of!(_fpstate, ftw) - 4usize];
    ["Offset of field: _fpstate::fop"][::std::mem::offset_of!(_fpstate, fop) - 6usize];
    ["Offset of field: _fpstate::rip"][::std::mem::offset_of!(_fpstate, rip) - 8usize];
    ["Offset of field: _fpstate::rdp"][::std::mem::offset_of!(_fpstate, rdp) - 16usize];
    ["Offset of field: _fpstate::mxcsr"][::std::mem::offset_of!(_fpstate, mxcsr) - 24usize];
    ["Offset of field: _fpstate::mxcr_mask"][::std::mem::offset_of!(_fpstate, mxcr_mask) - 28usize];
    ["Offset of field: _fpstate::_st"][::std::mem::offset_of!(_fpstate, _st) - 32usize];
    ["Offset of field: _fpstate::_xmm"][::std::mem::offset_of!(_fpstate, _xmm) - 160usize];
    ["Offset of field: _fpstate::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpstate, __glibc_reserved1) - 416usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigcontext__bindgen_ty_1"]
        [::std::mem::size_of::<sigcontext__bindgen_ty_1>() - 8usize];
    ["Alignment of sigcontext__bindgen_ty_1"]
        [::std::mem::align_of::<sigcontext__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigcontext__bindgen_ty_1::fpstate"]
        [::std::mem::offset_of!(sigcontext__bindgen_ty_1, fpstate) - 0usize];
    ["Offset of field: sigcontext__bindgen_ty_1::__fpstate_word"]
        [::std::mem::offset_of!(sigcontext__bindgen_ty_1, __fpstate_word) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigcontext"][::std::mem::size_of::<sigcontext>() - 256usize];
    ["Alignment of sigcontext"][::std::mem::align_of::<sigcontext>() - 8usize];
    ["Offset of field: sigcontext::r8"][::std::mem::offset_of!(sigcontext, r8) - 0usize];
    ["Offset of field: sigcontext::r9"][::std::mem::offset_of!(sigcontext, r9) - 8usize];
    ["Offset of field: sigcontext::r10"][::std::mem::offset_of!(sigcontext, r10) - 16usize];
    ["Offset of field: sigcontext::r11"][::std::mem::offset_of!(sigcontext, r11) - 24usize];
    ["Offset of field: sigcontext::r12"][::std::mem::offset_of!(sigcontext, r12) - 32usize];
    ["Offset of field: sigcontext::r13"][::std::mem::offset_of!(sigcontext, r13) - 40usize];
    ["Offset of field: sigcontext::r14"][::std::mem::offset_of!(sigcontext, r14) - 48usize];
    ["Offset of field: sigcontext::r15"][::std::mem::offset_of!(sigcontext, r15) - 56usize];
    ["Offset of field: sigcontext::rdi"][::std::mem::offset_of!(sigcontext, rdi) - 64usize];
    ["Offset of field: sigcontext::rsi"][::std::mem::offset_of!(sigcontext, rsi) - 72usize];
    ["Offset of field: sigcontext::rbp"][::std::mem::offset_of!(sigcontext, rbp) - 80usize];
    ["Offset of field: sigcontext::rbx"][::std::mem::offset_of!(sigcontext, rbx) - 88usize];
    ["Offset of field: sigcontext::rdx"][::std::mem::offset_of!(sigcontext, rdx) - 96usize];
    ["Offset of field: sigcontext::rax"][::std::mem::offset_of!(sigcontext, rax) - 104usize];
    ["Offset of field: sigcontext::rcx"][::std::mem::offset_of!(sigcontext, rcx) - 112usize];
    ["Offset of field: sigcontext::rsp"][::std::mem::offset_of!(sigcontext, rsp) - 120usize];
    ["Offset of field: sigcontext::rip"][::std::mem::offset_of!(sigcontext, rip) - 128usize];
    ["Offset of field: sigcontext::eflags"][::std::mem::offset_of!(sigcontext, eflags) - 136usize];
    ["Offset of field: sigcontext::cs"][::std::mem::offset_of!(sigcontext, cs) - 144usize];
    ["Offset of field: sigcontext::gs"][::std::mem::offset_of!(sigcontext, gs) - 146usize];
    ["Offset of field: sigcontext::fs"][::std::mem::offset_of!(sigcontext, fs) - 148usize];
    ["Offset of field: sigcontext::__pad0"][::std::mem::offset_of!(sigcontext, __pad0) - 150usize];
    ["Offset of field: sigcontext::err"][::std::mem::offset_of!(sigcontext, err) - 152usize];
    ["Offset of field: sigcontext::trapno"][::std::mem::offset_of!(sigcontext, trapno) - 160usize];
    ["Offset of field: sigcontext::oldmask"]
        [::std::mem::offset_of!(sigcontext, oldmask) - 168usize];
    ["Offset of field: sigcontext::cr2"][::std::mem::offset_of!(sigcontext, cr2) - 176usize];
    ["Offset of field: sigcontext::__reserved1"]
        [::std::mem::offset_of!(sigcontext, __reserved1) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xsave_hdr"][::std::mem::size_of::<_xsave_hdr>() - 64usize];
    ["Alignment of _xsave_hdr"][::std::mem::align_of::<_xsave_hdr>() - 8usize];
    ["Offset of field: _xsave_hdr::xstate_bv"]
        [::std::mem::offset_of!(_xsave_hdr, xstate_bv) - 0usize];
    ["Offset of field: _xsave_hdr::__glibc_reserved1"]
        [::std::mem::offset_of!(_xsave_hdr, __glibc_reserved1) - 8usize];
    ["Offset of field: _xsave_hdr::__glibc_reserved2"]
        [::std::mem::offset_of!(_xsave_hdr, __glibc_reserved2) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ymmh_state"][::std::mem::size_of::<_ymmh_state>() - 256usize];
    ["Alignment of _ymmh_state"][::std::mem::align_of::<_ymmh_state>() - 4usize];
    ["Offset of field: _ymmh_state::ymmh_space"]
        [::std::mem::offset_of!(_ymmh_state, ymmh_space) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xstate"][::std::mem::size_of::<_xstate>() - 832usize];
    ["Alignment of _xstate"][::std::mem::align_of::<_xstate>() - 8usize];
    ["Offset of field: _xstate::fpstate"][::std::mem::offset_of!(_xstate, fpstate) - 0usize];
    ["Offset of field: _xstate::xstate_hdr"]
        [::std::mem::offset_of!(_xstate, xstate_hdr) - 512usize];
    ["Offset of field: _xstate::ymmh"][::std::mem::offset_of!(_xstate, ymmh) - 576usize];
};
unsafe extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stack_t"][::std::mem::size_of::<stack_t>() - 24usize];
    ["Alignment of stack_t"][::std::mem::align_of::<stack_t>() - 8usize];
    ["Offset of field: stack_t::ss_sp"][::std::mem::offset_of!(stack_t, ss_sp) - 0usize];
    ["Offset of field: stack_t::ss_flags"][::std::mem::offset_of!(stack_t, ss_flags) - 8usize];
    ["Offset of field: stack_t::ss_size"][::std::mem::offset_of!(stack_t, ss_size) - 16usize];
};
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
pub const REG_R8: _bindgen_ty_24 = 0;
pub const REG_R9: _bindgen_ty_24 = 1;
pub const REG_R10: _bindgen_ty_24 = 2;
pub const REG_R11: _bindgen_ty_24 = 3;
pub const REG_R12: _bindgen_ty_24 = 4;
pub const REG_R13: _bindgen_ty_24 = 5;
pub const REG_R14: _bindgen_ty_24 = 6;
pub const REG_R15: _bindgen_ty_24 = 7;
pub const REG_RDI: _bindgen_ty_24 = 8;
pub const REG_RSI: _bindgen_ty_24 = 9;
pub const REG_RBP: _bindgen_ty_24 = 10;
pub const REG_RBX: _bindgen_ty_24 = 11;
pub const REG_RDX: _bindgen_ty_24 = 12;
pub const REG_RAX: _bindgen_ty_24 = 13;
pub const REG_RCX: _bindgen_ty_24 = 14;
pub const REG_RSP: _bindgen_ty_24 = 15;
pub const REG_RIP: _bindgen_ty_24 = 16;
pub const REG_EFL: _bindgen_ty_24 = 17;
pub const REG_CSGSFS: _bindgen_ty_24 = 18;
pub const REG_ERR: _bindgen_ty_24 = 19;
pub const REG_TRAPNO: _bindgen_ty_24 = 20;
pub const REG_OLDMASK: _bindgen_ty_24 = 21;
pub const REG_CR2: _bindgen_ty_24 = 22;
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_fpxreg"][::std::mem::size_of::<_libc_fpxreg>() - 16usize];
    ["Alignment of _libc_fpxreg"][::std::mem::align_of::<_libc_fpxreg>() - 2usize];
    ["Offset of field: _libc_fpxreg::significand"]
        [::std::mem::offset_of!(_libc_fpxreg, significand) - 0usize];
    ["Offset of field: _libc_fpxreg::exponent"]
        [::std::mem::offset_of!(_libc_fpxreg, exponent) - 8usize];
    ["Offset of field: _libc_fpxreg::__glibc_reserved1"]
        [::std::mem::offset_of!(_libc_fpxreg, __glibc_reserved1) - 10usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_xmmreg"][::std::mem::size_of::<_libc_xmmreg>() - 16usize];
    ["Alignment of _libc_xmmreg"][::std::mem::align_of::<_libc_xmmreg>() - 4usize];
    ["Offset of field: _libc_xmmreg::element"]
        [::std::mem::offset_of!(_libc_xmmreg, element) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_fpstate"][::std::mem::size_of::<_libc_fpstate>() - 512usize];
    ["Alignment of _libc_fpstate"][::std::mem::align_of::<_libc_fpstate>() - 8usize];
    ["Offset of field: _libc_fpstate::cwd"][::std::mem::offset_of!(_libc_fpstate, cwd) - 0usize];
    ["Offset of field: _libc_fpstate::swd"][::std::mem::offset_of!(_libc_fpstate, swd) - 2usize];
    ["Offset of field: _libc_fpstate::ftw"][::std::mem::offset_of!(_libc_fpstate, ftw) - 4usize];
    ["Offset of field: _libc_fpstate::fop"][::std::mem::offset_of!(_libc_fpstate, fop) - 6usize];
    ["Offset of field: _libc_fpstate::rip"][::std::mem::offset_of!(_libc_fpstate, rip) - 8usize];
    ["Offset of field: _libc_fpstate::rdp"][::std::mem::offset_of!(_libc_fpstate, rdp) - 16usize];
    ["Offset of field: _libc_fpstate::mxcsr"]
        [::std::mem::offset_of!(_libc_fpstate, mxcsr) - 24usize];
    ["Offset of field: _libc_fpstate::mxcr_mask"]
        [::std::mem::offset_of!(_libc_fpstate, mxcr_mask) - 28usize];
    ["Offset of field: _libc_fpstate::_st"][::std::mem::offset_of!(_libc_fpstate, _st) - 32usize];
    ["Offset of field: _libc_fpstate::_xmm"]
        [::std::mem::offset_of!(_libc_fpstate, _xmm) - 160usize];
    ["Offset of field: _libc_fpstate::__glibc_reserved1"]
        [::std::mem::offset_of!(_libc_fpstate, __glibc_reserved1) - 416usize];
};
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mcontext_t"][::std::mem::size_of::<mcontext_t>() - 256usize];
    ["Alignment of mcontext_t"][::std::mem::align_of::<mcontext_t>() - 8usize];
    ["Offset of field: mcontext_t::gregs"][::std::mem::offset_of!(mcontext_t, gregs) - 0usize];
    ["Offset of field: mcontext_t::fpregs"][::std::mem::offset_of!(mcontext_t, fpregs) - 184usize];
    ["Offset of field: mcontext_t::__reserved1"]
        [::std::mem::offset_of!(mcontext_t, __reserved1) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [::std::os::raw::c_ulonglong; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ucontext_t"][::std::mem::size_of::<ucontext_t>() - 968usize];
    ["Alignment of ucontext_t"][::std::mem::align_of::<ucontext_t>() - 8usize];
    ["Offset of field: ucontext_t::uc_flags"]
        [::std::mem::offset_of!(ucontext_t, uc_flags) - 0usize];
    ["Offset of field: ucontext_t::uc_link"][::std::mem::offset_of!(ucontext_t, uc_link) - 8usize];
    ["Offset of field: ucontext_t::uc_stack"]
        [::std::mem::offset_of!(ucontext_t, uc_stack) - 16usize];
    ["Offset of field: ucontext_t::uc_mcontext"]
        [::std::mem::offset_of!(ucontext_t, uc_mcontext) - 40usize];
    ["Offset of field: ucontext_t::uc_sigmask"]
        [::std::mem::offset_of!(ucontext_t, uc_sigmask) - 296usize];
    ["Offset of field: ucontext_t::__fpregs_mem"]
        [::std::mem::offset_of!(ucontext_t, __fpregs_mem) - 424usize];
    ["Offset of field: ucontext_t::__ssp"][::std::mem::offset_of!(ucontext_t, __ssp) - 936usize];
};
unsafe extern "C" {
    pub fn siginterrupt(
        __sig: ::std::os::raw::c_int,
        __interrupt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const SS_ONSTACK: _bindgen_ty_25 = 1;
pub const SS_DISABLE: _bindgen_ty_25 = 2;
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigstack"][::std::mem::size_of::<sigstack>() - 16usize];
    ["Alignment of sigstack"][::std::mem::align_of::<sigstack>() - 8usize];
    ["Offset of field: sigstack::ss_sp"][::std::mem::offset_of!(sigstack, ss_sp) - 0usize];
    ["Offset of field: sigstack::ss_onstack"]
        [::std::mem::offset_of!(sigstack, ss_onstack) - 8usize];
};
unsafe extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sighold(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigrelse(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigignore(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigset(__sig: ::std::os::raw::c_int, __disp: __sighandler_t) -> __sighandler_t;
}
unsafe extern "C" {
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_kill(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_sigqueue(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
        __value: sigval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tgkill(
        __tgid: __pid_t,
        __tid: __pid_t,
        __signal: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn writev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn preadv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pwritev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn preadv64(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off64_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pwritev64(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off64_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn preadv2(
        __fp: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
        ___flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pwritev2(
        __fd: ::std::os::raw::c_int,
        __iodev: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn preadv64v2(
        __fp: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off64_t,
        ___flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pwritev64v2(
        __fd: ::std::os::raw::c_int,
        __iodev: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off64_t,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn process_vm_readv(
        __pid: pid_t,
        __lvec: *const iovec,
        __liovcnt: ::std::os::raw::c_ulong,
        __rvec: *const iovec,
        __riovcnt: ::std::os::raw::c_ulong,
        __flags: ::std::os::raw::c_ulong,
    ) -> isize;
}
unsafe extern "C" {
    pub fn process_vm_writev(
        __pid: pid_t,
        __lvec: *const iovec,
        __liovcnt: ::std::os::raw::c_ulong,
        __rvec: *const iovec,
        __riovcnt: ::std::os::raw::c_ulong,
        __flags: ::std::os::raw::c_ulong,
    ) -> isize;
}
pub const P_ALL: idtype_t = 0;
pub const P_PID: idtype_t = 1;
pub const P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn wait(__stat_loc: *mut ::std::os::raw::c_int) -> __pid_t;
}
unsafe extern "C" {
    pub fn waitpid(
        __pid: __pid_t,
        __stat_loc: *mut ::std::os::raw::c_int,
        __options: ::std::os::raw::c_int,
    ) -> __pid_t;
}
unsafe extern "C" {
    pub fn waitid(
        __idtype: idtype_t,
        __id: __id_t,
        __infop: *mut siginfo_t,
        __options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn wait3(
        __stat_loc: *mut ::std::os::raw::c_int,
        __options: ::std::os::raw::c_int,
        __usage: *mut rusage,
    ) -> __pid_t;
}
unsafe extern "C" {
    pub fn wait4(
        __pid: __pid_t,
        __stat_loc: *mut ::std::os::raw::c_int,
        __options: ::std::os::raw::c_int,
        __usage: *mut rusage,
    ) -> __pid_t;
}
unsafe extern "C" {
    pub fn stat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fstat(__fd: ::std::os::raw::c_int, __buf: *mut stat) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn stat64(
        __file: *const ::std::os::raw::c_char,
        __buf: *mut stat64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fstat64(__fd: ::std::os::raw::c_int, __buf: *mut stat64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fstatat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __buf: *mut stat,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fstatat64(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __buf: *mut stat64,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lstat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lstat64(
        __file: *const ::std::os::raw::c_char,
        __buf: *mut stat64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lchmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchmod(__fd: ::std::os::raw::c_int, __mode: __mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchmodat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
unsafe extern "C" {
    pub fn getumask() -> __mode_t;
}
unsafe extern "C" {
    pub fn mkdir(__path: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdirat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mknod(
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mknodat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkfifo(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkfifoat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
        -> ::std::os::raw::c_int;
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statx_timestamp {
    pub tv_sec: __s64,
    pub tv_nsec: __u32,
    pub __reserved: __s32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of statx_timestamp"][::std::mem::size_of::<statx_timestamp>() - 16usize];
    ["Alignment of statx_timestamp"][::std::mem::align_of::<statx_timestamp>() - 8usize];
    ["Offset of field: statx_timestamp::tv_sec"]
        [::std::mem::offset_of!(statx_timestamp, tv_sec) - 0usize];
    ["Offset of field: statx_timestamp::tv_nsec"]
        [::std::mem::offset_of!(statx_timestamp, tv_nsec) - 8usize];
    ["Offset of field: statx_timestamp::__reserved"]
        [::std::mem::offset_of!(statx_timestamp, __reserved) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statx {
    pub stx_mask: __u32,
    pub stx_blksize: __u32,
    pub stx_attributes: __u64,
    pub stx_nlink: __u32,
    pub stx_uid: __u32,
    pub stx_gid: __u32,
    pub stx_mode: __u16,
    pub __spare0: [__u16; 1usize],
    pub stx_ino: __u64,
    pub stx_size: __u64,
    pub stx_blocks: __u64,
    pub stx_attributes_mask: __u64,
    pub stx_atime: statx_timestamp,
    pub stx_btime: statx_timestamp,
    pub stx_ctime: statx_timestamp,
    pub stx_mtime: statx_timestamp,
    pub stx_rdev_major: __u32,
    pub stx_rdev_minor: __u32,
    pub stx_dev_major: __u32,
    pub stx_dev_minor: __u32,
    pub stx_mnt_id: __u64,
    pub __spare2: __u64,
    pub __spare3: [__u64; 12usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of statx"][::std::mem::size_of::<statx>() - 256usize];
    ["Alignment of statx"][::std::mem::align_of::<statx>() - 8usize];
    ["Offset of field: statx::stx_mask"][::std::mem::offset_of!(statx, stx_mask) - 0usize];
    ["Offset of field: statx::stx_blksize"][::std::mem::offset_of!(statx, stx_blksize) - 4usize];
    ["Offset of field: statx::stx_attributes"]
        [::std::mem::offset_of!(statx, stx_attributes) - 8usize];
    ["Offset of field: statx::stx_nlink"][::std::mem::offset_of!(statx, stx_nlink) - 16usize];
    ["Offset of field: statx::stx_uid"][::std::mem::offset_of!(statx, stx_uid) - 20usize];
    ["Offset of field: statx::stx_gid"][::std::mem::offset_of!(statx, stx_gid) - 24usize];
    ["Offset of field: statx::stx_mode"][::std::mem::offset_of!(statx, stx_mode) - 28usize];
    ["Offset of field: statx::__spare0"][::std::mem::offset_of!(statx, __spare0) - 30usize];
    ["Offset of field: statx::stx_ino"][::std::mem::offset_of!(statx, stx_ino) - 32usize];
    ["Offset of field: statx::stx_size"][::std::mem::offset_of!(statx, stx_size) - 40usize];
    ["Offset of field: statx::stx_blocks"][::std::mem::offset_of!(statx, stx_blocks) - 48usize];
    ["Offset of field: statx::stx_attributes_mask"]
        [::std::mem::offset_of!(statx, stx_attributes_mask) - 56usize];
    ["Offset of field: statx::stx_atime"][::std::mem::offset_of!(statx, stx_atime) - 64usize];
    ["Offset of field: statx::stx_btime"][::std::mem::offset_of!(statx, stx_btime) - 80usize];
    ["Offset of field: statx::stx_ctime"][::std::mem::offset_of!(statx, stx_ctime) - 96usize];
    ["Offset of field: statx::stx_mtime"][::std::mem::offset_of!(statx, stx_mtime) - 112usize];
    ["Offset of field: statx::stx_rdev_major"]
        [::std::mem::offset_of!(statx, stx_rdev_major) - 128usize];
    ["Offset of field: statx::stx_rdev_minor"]
        [::std::mem::offset_of!(statx, stx_rdev_minor) - 132usize];
    ["Offset of field: statx::stx_dev_major"]
        [::std::mem::offset_of!(statx, stx_dev_major) - 136usize];
    ["Offset of field: statx::stx_dev_minor"]
        [::std::mem::offset_of!(statx, stx_dev_minor) - 140usize];
    ["Offset of field: statx::stx_mnt_id"][::std::mem::offset_of!(statx, stx_mnt_id) - 144usize];
    ["Offset of field: statx::__spare2"][::std::mem::offset_of!(statx, __spare2) - 152usize];
    ["Offset of field: statx::__spare3"][::std::mem::offset_of!(statx, __spare3) - 160usize];
};
unsafe extern "C" {
    pub fn statx(
        __dirfd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
        __mask: ::std::os::raw::c_uint,
        __buf: *mut statx,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timezone"][::std::mem::size_of::<timezone>() - 8usize];
    ["Alignment of timezone"][::std::mem::align_of::<timezone>() - 4usize];
    ["Offset of field: timezone::tz_minuteswest"]
        [::std::mem::offset_of!(timezone, tz_minuteswest) - 0usize];
    ["Offset of field: timezone::tz_dsttime"]
        [::std::mem::offset_of!(timezone, tz_dsttime) - 4usize];
};
unsafe extern "C" {
    pub fn gettimeofday(
        __tv: *mut timeval,
        __tz: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const ITIMER_REAL: __itimer_which = 0;
pub const ITIMER_VIRTUAL: __itimer_which = 1;
pub const ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerval"][::std::mem::size_of::<itimerval>() - 32usize];
    ["Alignment of itimerval"][::std::mem::align_of::<itimerval>() - 8usize];
    ["Offset of field: itimerval::it_interval"]
        [::std::mem::offset_of!(itimerval, it_interval) - 0usize];
    ["Offset of field: itimerval::it_value"][::std::mem::offset_of!(itimerval, it_value) - 16usize];
};
pub use self::__itimer_which as __itimer_which_t;
unsafe extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn futimesat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memfd_create(
        __name: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlock2(
        __addr: *const ::std::os::raw::c_void,
        __length: usize,
        __flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pkey_alloc(
        __flags: ::std::os::raw::c_uint,
        __access_rights: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pkey_set(
        __key: ::std::os::raw::c_int,
        __access_rights: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pkey_get(__key: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pkey_free(__key: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pkey_mprotect(
        __addr: *mut ::std::os::raw::c_void,
        __len: usize,
        __prot: ::std::os::raw::c_int,
        __pkey: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mmap(
        __addr: *mut ::std::os::raw::c_void,
        __len: usize,
        __prot: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mmap64(
        __addr: *mut ::std::os::raw::c_void,
        __len: usize,
        __prot: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
        __fd: ::std::os::raw::c_int,
        __offset: __off64_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn munmap(__addr: *mut ::std::os::raw::c_void, __len: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mprotect(
        __addr: *mut ::std::os::raw::c_void,
        __len: usize,
        __prot: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn msync(
        __addr: *mut ::std::os::raw::c_void,
        __len: usize,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn madvise(
        __addr: *mut ::std::os::raw::c_void,
        __len: usize,
        __advice: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn posix_madvise(
        __addr: *mut ::std::os::raw::c_void,
        __len: usize,
        __advice: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlock(__addr: *const ::std::os::raw::c_void, __len: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn munlock(__addr: *const ::std::os::raw::c_void, __len: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlockall(__flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn munlockall() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mincore(
        __start: *mut ::std::os::raw::c_void,
        __len: usize,
        __vec: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mremap(
        __addr: *mut ::std::os::raw::c_void,
        __old_len: usize,
        __new_len: usize,
        __flags: ::std::os::raw::c_int,
        ...
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn remap_file_pages(
        __start: *mut ::std::os::raw::c_void,
        __size: usize,
        __prot: ::std::os::raw::c_int,
        __pgoff: usize,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn shm_open(
        __name: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        __mode: mode_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn shm_unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type gint8 = ::std::os::raw::c_schar;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gssize = ::std::os::raw::c_long;
pub type gsize = ::std::os::raw::c_ulong;
pub type goffset = gint64;
pub type gintptr = ::std::os::raw::c_long;
pub type guintptr = ::std::os::raw::c_ulong;
pub type GPid = ::std::os::raw::c_int;
pub type gchar = ::std::os::raw::c_char;
pub type gshort = ::std::os::raw::c_short;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guchar = ::std::os::raw::c_uchar;
pub type gushort = ::std::os::raw::c_ushort;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gint>;
pub type GCompareDataFunc = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint,
>;
pub type GEqualFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gboolean>;
pub type GDestroyNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc = ::std::option::Option<unsafe extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer),
>;
#[doc = " GCopyFunc:\n @src: (not nullable): A pointer to the data which should be copied\n @data: Additional data\n\n A function of this signature is used to copy the node data\n when doing a deep-copy of a tree.\n\n Returns: (not nullable): A pointer to the copy\n\n Since: 2.4"]
pub type GCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src: gconstpointer, data: gpointer) -> gpointer>;
#[doc = " GFreeFunc:\n @data: a data pointer\n\n Declares a type of function which takes an arbitrary\n data pointer argument and has no return value. It is\n not currently used in GLib or GTK+."]
pub type GFreeFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
#[doc = " GTranslateFunc:\n @str: the untranslated string\n @data: user data specified when installing the function, e.g.\n  in g_option_group_set_translate_func()\n\n The type of functions which are used to translate user-visible\n strings, for <option>--help</option> output.\n\n Returns: a translation of the string for the current locale.\n  The returned string is owned by GLib and must not be freed."]
pub type GTranslateFunc =
    ::std::option::Option<unsafe extern "C" fn(str_: *const gchar, data: gpointer) -> *const gchar>;
pub type GDoubleIEEE754 = _GDoubleIEEE754;
pub type GFloatIEEE754 = _GFloatIEEE754;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GFloatIEEE754 {
    pub v_float: gfloat,
    pub mpn: _GFloatIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFloatIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFloatIEEE754__bindgen_ty_1"]
        [::std::mem::size_of::<_GFloatIEEE754__bindgen_ty_1>() - 4usize];
    ["Alignment of _GFloatIEEE754__bindgen_ty_1"]
        [::std::mem::align_of::<_GFloatIEEE754__bindgen_ty_1>() - 4usize];
};
impl _GFloatIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mantissa_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mantissa_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn biased_exponent_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_biased_exponent_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sign_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sign_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let mantissa: u32 = unsafe { ::std::mem::transmute(mantissa) };
            mantissa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFloatIEEE754"][::std::mem::size_of::<_GFloatIEEE754>() - 4usize];
    ["Alignment of _GFloatIEEE754"][::std::mem::align_of::<_GFloatIEEE754>() - 4usize];
    ["Offset of field: _GFloatIEEE754::v_float"]
        [::std::mem::offset_of!(_GFloatIEEE754, v_float) - 0usize];
    ["Offset of field: _GFloatIEEE754::mpn"][::std::mem::offset_of!(_GFloatIEEE754, mpn) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDoubleIEEE754 {
    pub v_double: gdouble,
    pub mpn: _GDoubleIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDoubleIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDoubleIEEE754__bindgen_ty_1"]
        [::std::mem::size_of::<_GDoubleIEEE754__bindgen_ty_1>() - 8usize];
    ["Alignment of _GDoubleIEEE754__bindgen_ty_1"]
        [::std::mem::align_of::<_GDoubleIEEE754__bindgen_ty_1>() - 4usize];
};
impl _GDoubleIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa_low(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_low(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mantissa_low_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                32u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mantissa_low_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                32u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mantissa_high(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_high(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mantissa_high_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mantissa_high_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn biased_exponent_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                52usize,
                11u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_biased_exponent_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                52usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sign_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                63usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sign_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                63usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa_low: guint,
        mantissa_high: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let mantissa_low: u32 = unsafe { ::std::mem::transmute(mantissa_low) };
            mantissa_low as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let mantissa_high: u32 = unsafe { ::std::mem::transmute(mantissa_high) };
            mantissa_high as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDoubleIEEE754"][::std::mem::size_of::<_GDoubleIEEE754>() - 8usize];
    ["Alignment of _GDoubleIEEE754"][::std::mem::align_of::<_GDoubleIEEE754>() - 8usize];
    ["Offset of field: _GDoubleIEEE754::v_double"]
        [::std::mem::offset_of!(_GDoubleIEEE754, v_double) - 0usize];
    ["Offset of field: _GDoubleIEEE754::mpn"]
        [::std::mem::offset_of!(_GDoubleIEEE754, mpn) - 0usize];
};
pub type GTimeVal = _GTimeVal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTimeVal"][::std::mem::size_of::<_GTimeVal>() - 16usize];
    ["Alignment of _GTimeVal"][::std::mem::align_of::<_GTimeVal>() - 8usize];
    ["Offset of field: _GTimeVal::tv_sec"][::std::mem::offset_of!(_GTimeVal, tv_sec) - 0usize];
    ["Offset of field: _GTimeVal::tv_usec"][::std::mem::offset_of!(_GTimeVal, tv_usec) - 8usize];
};
pub type grefcount = gint;
pub type gatomicrefcount = gint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytes {
    _unused: [u8; 0],
}
pub type GBytes = _GBytes;
pub type GArray = _GArray;
pub type GByteArray = _GByteArray;
pub type GPtrArray = _GPtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GArray"][::std::mem::size_of::<_GArray>() - 16usize];
    ["Alignment of _GArray"][::std::mem::align_of::<_GArray>() - 8usize];
    ["Offset of field: _GArray::data"][::std::mem::offset_of!(_GArray, data) - 0usize];
    ["Offset of field: _GArray::len"][::std::mem::offset_of!(_GArray, len) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GByteArray"][::std::mem::size_of::<_GByteArray>() - 16usize];
    ["Alignment of _GByteArray"][::std::mem::align_of::<_GByteArray>() - 8usize];
    ["Offset of field: _GByteArray::data"][::std::mem::offset_of!(_GByteArray, data) - 0usize];
    ["Offset of field: _GByteArray::len"][::std::mem::offset_of!(_GByteArray, len) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPtrArray"][::std::mem::size_of::<_GPtrArray>() - 16usize];
    ["Alignment of _GPtrArray"][::std::mem::align_of::<_GPtrArray>() - 8usize];
    ["Offset of field: _GPtrArray::pdata"][::std::mem::offset_of!(_GPtrArray, pdata) - 0usize];
    ["Offset of field: _GPtrArray::len"][::std::mem::offset_of!(_GPtrArray, len) - 8usize];
};
unsafe extern "C" {
    pub fn g_array_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
    ) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_steal(array: *mut GArray, len: *mut gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_array_sized_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
        reserved_size: guint,
    ) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_copy(array: *mut GArray) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_unref(array: *mut GArray);
}
unsafe extern "C" {
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
}
unsafe extern "C" {
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: guint)
        -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_insert_vals(
        array: *mut GArray,
        index_: guint,
        data: gconstpointer,
        len: guint,
    ) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_remove_index(array: *mut GArray, index_: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_remove_range(array: *mut GArray, index_: guint, length: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
}
unsafe extern "C" {
    pub fn g_array_sort_with_data(
        array: *mut GArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_array_binary_search(
        array: *mut GArray,
        target: gconstpointer,
        compare_func: GCompareFunc,
        out_match_index: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_ptr_array_new() -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_steal(array: *mut GPtrArray, len: *mut gsize) -> *mut gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_copy(
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_full(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
}
unsafe extern "C" {
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
}
unsafe extern "C" {
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_steal_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_steal_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ptr_array_remove_range(
        array: *mut GPtrArray,
        index_: guint,
        length: guint,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
}
unsafe extern "C" {
    pub fn g_ptr_array_extend(
        array_to_extend: *mut GPtrArray,
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_ptr_array_extend_and_steal(array_to_extend: *mut GPtrArray, array: *mut GPtrArray);
}
unsafe extern "C" {
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint, data: gpointer);
}
unsafe extern "C" {
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
}
unsafe extern "C" {
    pub fn g_ptr_array_sort_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_ptr_array_find(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        index_: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ptr_array_find_with_equal_func(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        equal_func: GEqualFunc,
        index_: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_byte_array_new() -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_steal(array: *mut GByteArray, len: *mut gsize) -> *mut guint8;
}
unsafe extern "C" {
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut guint8;
}
unsafe extern "C" {
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_unref(array: *mut GByteArray);
}
unsafe extern "C" {
    pub fn g_byte_array_append(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_prepend(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: guint)
        -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_remove_range(
        array: *mut GByteArray,
        index_: guint,
        length: guint,
    ) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
}
unsafe extern "C" {
    pub fn g_byte_array_sort_with_data(
        array: *mut GByteArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
}
unsafe extern "C" {
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
}
unsafe extern "C" {
    pub fn g_atomic_int_inc(atomic: *mut gint);
}
unsafe extern "C" {
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_int_compare_and_exchange(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_get(atomic: *const ::std::os::raw::c_void) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_set(atomic: *mut ::std::os::raw::c_void, newval: gpointer);
}
unsafe extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_add(atomic: *mut ::std::os::raw::c_void, val: gssize) -> gssize;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_and(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_or(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_xor(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
unsafe extern "C" {
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint) -> gint;
}
pub type GQuark = guint32;
unsafe extern "C" {
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
}
unsafe extern "C" {
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
}
unsafe extern "C" {
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
}
unsafe extern "C" {
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
}
#[doc = " GError:\n @domain: error domain, e.g. %G_FILE_ERROR\n @code: error code, e.g. %G_FILE_ERROR_NOENT\n @message: human-readable informative error message\n\n The `GError` structure contains information about\n an error that has occurred."]
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GError"][::std::mem::size_of::<_GError>() - 16usize];
    ["Alignment of _GError"][::std::mem::align_of::<_GError>() - 8usize];
    ["Offset of field: _GError::domain"][::std::mem::offset_of!(_GError, domain) - 0usize];
    ["Offset of field: _GError::code"][::std::mem::offset_of!(_GError, code) - 4usize];
    ["Offset of field: _GError::message"][::std::mem::offset_of!(_GError, message) - 8usize];
};
#[doc = " GErrorInitFunc:\n @error: extended error\n\n Specifies the type of function which is called just after an\n extended error instance is created and its fields filled. It should\n only initialize the fields in the private data, which can be\n received with the generated `*_get_private()` function.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @error.\n\n Since: 2.68"]
pub type GErrorInitFunc = ::std::option::Option<unsafe extern "C" fn(error: *mut GError)>;
#[doc = " GErrorCopyFunc:\n @src_error: source extended error\n @dest_error: destination extended error\n\n Specifies the type of function which is called when an extended\n error instance is copied. It is passed the pointer to the\n destination error and source error, and should copy only the fields\n of the private data from @src_error to @dest_error.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @src_error and\n @dest_error.\n\n Since: 2.68"]
pub type GErrorCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src_error: *const GError, dest_error: *mut GError)>;
#[doc = " GErrorClearFunc:\n @error: extended error to clear\n\n Specifies the type of function which is called when an extended\n error instance is freed. It is passed the error pointer about to be\n freed, and should free the error's private data fields.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @error.\n\n Since: 2.68"]
pub type GErrorClearFunc = ::std::option::Option<unsafe extern "C" fn(error: *mut GError)>;
unsafe extern "C" {
    pub fn g_error_domain_register_static(
        error_type_name: *const ::std::os::raw::c_char,
        error_type_private_size: gsize,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
}
unsafe extern "C" {
    pub fn g_error_domain_register(
        error_type_name: *const ::std::os::raw::c_char,
        error_type_private_size: gsize,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
}
unsafe extern "C" {
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...) -> *mut GError;
}
unsafe extern "C" {
    pub fn g_error_new_literal(domain: GQuark, code: gint, message: *const gchar) -> *mut GError;
}
unsafe extern "C" {
    pub fn g_error_new_valist(
        domain: GQuark,
        code: gint,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> *mut GError;
}
unsafe extern "C" {
    pub fn g_error_free(error: *mut GError);
}
unsafe extern "C" {
    pub fn g_error_copy(error: *const GError) -> *mut GError;
}
unsafe extern "C" {
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_set_error(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_set_error_literal(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
}
unsafe extern "C" {
    pub fn g_clear_error(err: *mut *mut GError);
}
unsafe extern "C" {
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_prefix_error_literal(err: *mut *mut GError, prefix: *const gchar);
}
unsafe extern "C" {
    pub fn g_propagate_prefixed_error(
        dest: *mut *mut GError,
        src: *mut GError,
        format: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_get_user_name() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_real_name() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_home_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_tmp_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_host_name() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_prgname() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_set_prgname(prgname: *const gchar);
}
unsafe extern "C" {
    pub fn g_get_application_name() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_set_application_name(application_name: *const gchar);
}
unsafe extern "C" {
    pub fn g_get_os_info(key_name: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_reload_user_special_dirs_cache();
}
unsafe extern "C" {
    pub fn g_get_user_data_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_user_config_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_user_cache_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_user_state_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_system_data_dirs() -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_get_system_config_dirs() -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_get_user_runtime_dir() -> *const gchar;
}
pub const G_USER_DIRECTORY_DESKTOP: GUserDirectory = 0;
pub const G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = 1;
pub const G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = 2;
pub const G_USER_DIRECTORY_MUSIC: GUserDirectory = 3;
pub const G_USER_DIRECTORY_PICTURES: GUserDirectory = 4;
pub const G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = 5;
pub const G_USER_DIRECTORY_TEMPLATES: GUserDirectory = 6;
pub const G_USER_DIRECTORY_VIDEOS: GUserDirectory = 7;
pub const G_USER_N_DIRECTORIES: GUserDirectory = 8;
#[doc = " GUserDirectory:\n @G_USER_DIRECTORY_DESKTOP: the user's Desktop directory\n @G_USER_DIRECTORY_DOCUMENTS: the user's Documents directory\n @G_USER_DIRECTORY_DOWNLOAD: the user's Downloads directory\n @G_USER_DIRECTORY_MUSIC: the user's Music directory\n @G_USER_DIRECTORY_PICTURES: the user's Pictures directory\n @G_USER_DIRECTORY_PUBLIC_SHARE: the user's shared directory\n @G_USER_DIRECTORY_TEMPLATES: the user's Templates directory\n @G_USER_DIRECTORY_VIDEOS: the user's Movies directory\n @G_USER_N_DIRECTORIES: the number of enum values\n\n These are logical ids for special directories which are defined\n depending on the platform used. You should use g_get_user_special_dir()\n to retrieve the full path associated to the logical id.\n\n The #GUserDirectory enumeration can be extended at later date. Not\n every platform has a directory for every logical id in this\n enumeration.\n\n Since: 2.14"]
pub type GUserDirectory = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
}
#[doc = " GDebugKey:\n @key: the string\n @value: the flag\n\n Associates a string with a bit flag.\n Used in g_parse_debug_string()."]
pub type GDebugKey = _GDebugKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDebugKey"][::std::mem::size_of::<_GDebugKey>() - 16usize];
    ["Alignment of _GDebugKey"][::std::mem::align_of::<_GDebugKey>() - 8usize];
    ["Offset of field: _GDebugKey::key"][::std::mem::offset_of!(_GDebugKey, key) - 0usize];
    ["Offset of field: _GDebugKey::value"][::std::mem::offset_of!(_GDebugKey, value) - 8usize];
};
unsafe extern "C" {
    pub fn g_parse_debug_string(
        string: *const gchar,
        keys: *const GDebugKey,
        nkeys: guint,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_snprintf(string: *mut gchar, n: gulong, format: *const gchar, ...) -> gint;
}
unsafe extern "C" {
    pub fn g_vsnprintf(
        string: *mut gchar,
        n: gulong,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
}
pub const G_FORMAT_SIZE_DEFAULT: GFormatSizeFlags = 0;
pub const G_FORMAT_SIZE_LONG_FORMAT: GFormatSizeFlags = 1;
pub const G_FORMAT_SIZE_IEC_UNITS: GFormatSizeFlags = 2;
pub const G_FORMAT_SIZE_BITS: GFormatSizeFlags = 4;
pub type GFormatSizeFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_format_size(size: guint64) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
}
#[doc = " GVoidFunc:\n\n Declares a type of function which takes no arguments\n and has no return value. It is used to specify the type\n function passed to g_atexit()."]
pub type GVoidFunc = ::std::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    pub fn g_atexit(func: GVoidFunc);
}
unsafe extern "C" {
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_bit_nth_msf(mask: gulong, nth_bit: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_bit_storage(number: gulong) -> guint;
}
unsafe extern "C" {
    pub fn g_thread_error_quark() -> GQuark;
}
pub const G_THREAD_ERROR_AGAIN: GThreadError = 0;
pub type GThreadError = ::std::os::raw::c_uint;
pub type GThreadFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gpointer>;
pub type GThread = _GThread;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
pub type GRWLock = _GRWLock;
pub type GCond = _GCond;
pub type GPrivate = _GPrivate;
pub type GOnce = _GOnce;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMutex"][::std::mem::size_of::<_GMutex>() - 8usize];
    ["Alignment of _GMutex"][::std::mem::align_of::<_GMutex>() - 8usize];
    ["Offset of field: _GMutex::p"][::std::mem::offset_of!(_GMutex, p) - 0usize];
    ["Offset of field: _GMutex::i"][::std::mem::offset_of!(_GMutex, i) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRWLock {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GRWLock"][::std::mem::size_of::<_GRWLock>() - 16usize];
    ["Alignment of _GRWLock"][::std::mem::align_of::<_GRWLock>() - 8usize];
    ["Offset of field: _GRWLock::p"][::std::mem::offset_of!(_GRWLock, p) - 0usize];
    ["Offset of field: _GRWLock::i"][::std::mem::offset_of!(_GRWLock, i) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCond {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GCond"][::std::mem::size_of::<_GCond>() - 16usize];
    ["Alignment of _GCond"][::std::mem::align_of::<_GCond>() - 8usize];
    ["Offset of field: _GCond::p"][::std::mem::offset_of!(_GCond, p) - 0usize];
    ["Offset of field: _GCond::i"][::std::mem::offset_of!(_GCond, i) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GRecMutex"][::std::mem::size_of::<_GRecMutex>() - 16usize];
    ["Alignment of _GRecMutex"][::std::mem::align_of::<_GRecMutex>() - 8usize];
    ["Offset of field: _GRecMutex::p"][::std::mem::offset_of!(_GRecMutex, p) - 0usize];
    ["Offset of field: _GRecMutex::i"][::std::mem::offset_of!(_GRecMutex, i) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPrivate"][::std::mem::size_of::<_GPrivate>() - 32usize];
    ["Alignment of _GPrivate"][::std::mem::align_of::<_GPrivate>() - 8usize];
    ["Offset of field: _GPrivate::p"][::std::mem::offset_of!(_GPrivate, p) - 0usize];
    ["Offset of field: _GPrivate::notify"][::std::mem::offset_of!(_GPrivate, notify) - 8usize];
    ["Offset of field: _GPrivate::future"][::std::mem::offset_of!(_GPrivate, future) - 16usize];
};
pub const G_ONCE_STATUS_NOTCALLED: GOnceStatus = 0;
pub const G_ONCE_STATUS_PROGRESS: GOnceStatus = 1;
pub const G_ONCE_STATUS_READY: GOnceStatus = 2;
pub type GOnceStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GOnce"][::std::mem::size_of::<_GOnce>() - 16usize];
    ["Alignment of _GOnce"][::std::mem::align_of::<_GOnce>() - 8usize];
    ["Offset of field: _GOnce::status"][::std::mem::offset_of!(_GOnce, status) - 0usize];
    ["Offset of field: _GOnce::retval"][::std::mem::offset_of!(_GOnce, retval) - 8usize];
};
unsafe extern "C" {
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_unref(thread: *mut GThread);
}
unsafe extern "C" {
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_try_new(
        name: *const gchar,
        func: GThreadFunc,
        data: gpointer,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_self() -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_exit(retval: gpointer);
}
unsafe extern "C" {
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
}
unsafe extern "C" {
    pub fn g_thread_yield();
}
unsafe extern "C" {
    pub fn g_mutex_init(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_mutex_clear(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_mutex_lock(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
}
unsafe extern "C" {
    pub fn g_mutex_unlock(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
unsafe extern "C" {
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
unsafe extern "C" {
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
}
unsafe extern "C" {
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
}
unsafe extern "C" {
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
}
unsafe extern "C" {
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
}
unsafe extern "C" {
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
}
unsafe extern "C" {
    pub fn g_cond_init(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_clear(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_cond_signal(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_broadcast(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: gint64) -> gboolean;
}
unsafe extern "C" {
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
}
unsafe extern "C" {
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
}
unsafe extern "C" {
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
}
unsafe extern "C" {
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_once_init_enter(location: *mut ::std::os::raw::c_void) -> gboolean;
}
unsafe extern "C" {
    pub fn g_once_init_leave(location: *mut ::std::os::raw::c_void, result: gsize);
}
unsafe extern "C" {
    pub fn g_get_num_processors() -> guint;
}
#[doc = " GMutexLocker:\n\n Opaque type. See g_mutex_locker_new() for details.\n Since: 2.44"]
pub type GMutexLocker = ::std::os::raw::c_void;
#[doc = " GRecMutexLocker:\n\n Opaque type. See g_rec_mutex_locker_new() for details.\n Since: 2.60"]
pub type GRecMutexLocker = ::std::os::raw::c_void;
#[doc = " GRWLockWriterLocker:\n\n Opaque type. See g_rw_lock_writer_locker_new() for details.\n Since: 2.62"]
pub type GRWLockWriterLocker = ::std::os::raw::c_void;
#[doc = " GRWLockReaderLocker:\n\n Opaque type. See g_rw_lock_reader_locker_new() for details.\n Since: 2.62"]
pub type GRWLockReaderLocker = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncQueue {
    _unused: [u8; 0],
}
pub type GAsyncQueue = _GAsyncQueue;
unsafe extern "C" {
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
}
unsafe extern "C" {
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;
}
unsafe extern "C" {
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
}
unsafe extern "C" {
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_push_sorted(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_async_queue_push_sorted_unlocked(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: guint64) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_timeout_pop_unlocked(
        queue: *mut GAsyncQueue,
        timeout: guint64,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
}
unsafe extern "C" {
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
}
unsafe extern "C" {
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_sort_unlocked(
        queue: *mut GAsyncQueue,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_timed_pop_unlocked(
        queue: *mut GAsyncQueue,
        end_time: *mut GTimeVal,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_on_error_query(prg_name: *const gchar);
}
unsafe extern "C" {
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
}
unsafe extern "C" {
    pub fn g_base64_encode_step(
        in_: *const guchar,
        len: gsize,
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_base64_encode_close(
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_base64_decode_step(
        in_: *const gchar,
        len: gsize,
        out: *mut guchar,
        state: *mut gint,
        save: *mut guint,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize) -> *mut guchar;
}
unsafe extern "C" {
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize) -> *mut guchar;
}
unsafe extern "C" {
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
}
unsafe extern "C" {
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
}
unsafe extern "C" {
    pub fn g_pointer_bit_lock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
unsafe extern "C" {
    pub fn g_pointer_bit_trylock(address: *mut ::std::os::raw::c_void, lock_bit: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pointer_bit_unlock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeZone {
    _unused: [u8; 0],
}
pub type GTimeZone = _GTimeZone;
pub const G_TIME_TYPE_STANDARD: GTimeType = 0;
pub const G_TIME_TYPE_DAYLIGHT: GTimeType = 1;
pub const G_TIME_TYPE_UNIVERSAL: GTimeType = 2;
#[doc = " GTimeType:\n @G_TIME_TYPE_STANDARD: the time is in local standard time\n @G_TIME_TYPE_DAYLIGHT: the time is in local daylight time\n @G_TIME_TYPE_UNIVERSAL: the time is in UTC\n\n Disambiguates a given time in two ways.\n\n First, specifies if the given time is in universal or local time.\n\n Second, if the time is in local time, specifies if it is local\n standard time or local daylight time.  This is important for the case\n where the same local time occurs twice (during daylight savings time\n transitions, for example)."]
pub type GTimeType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_new_identifier(identifier: *const gchar) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_new_offset(seconds: gint32) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
}
unsafe extern "C" {
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: gint64) -> gint;
}
unsafe extern "C" {
    pub fn g_time_zone_adjust_time(
        tz: *mut GTimeZone,
        type_: GTimeType,
        time_: *mut gint64,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint) -> gint32;
}
unsafe extern "C" {
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_time_zone_get_identifier(tz: *mut GTimeZone) -> *const gchar;
}
#[doc = " GTimeSpan:\n\n A value representing an interval of time, in microseconds.\n\n Since: 2.26"]
pub type GTimeSpan = gint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
#[doc = " GDateTime:\n\n An opaque structure that represents a date and time, including a time zone.\n\n Since: 2.26"]
pub type GDateTime = _GDateTime;
unsafe extern "C" {
    pub fn g_date_time_unref(datetime: *mut GDateTime);
}
unsafe extern "C" {
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_iso8601(
        text: *const gchar,
        default_tz: *mut GTimeZone,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_local(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_utc(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: gint,
        months: gint,
        days: gint,
        hours: gint,
        minutes: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
}
unsafe extern "C" {
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_time_get_ymd(
        datetime: *mut GDateTime,
        year: *mut gint,
        month: *mut gint,
        day: *mut gint,
    );
}
unsafe extern "C" {
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
}
unsafe extern "C" {
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
}
unsafe extern "C" {
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
}
unsafe extern "C" {
    pub fn g_date_time_get_timezone(datetime: *mut GDateTime) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_date_time_format_iso8601(datetime: *mut GDateTime) -> *mut gchar;
}
pub const G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = 0;
pub const G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = 1;
pub const G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = 2;
pub const G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = 3;
pub const G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = 4;
pub const G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = 5;
pub const G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = 6;
pub const G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = 7;
#[doc = " GBookmarkFileError:\n @G_BOOKMARK_FILE_ERROR_INVALID_URI: URI was ill-formed\n @G_BOOKMARK_FILE_ERROR_INVALID_VALUE: a requested field was not found\n @G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: a requested application did\n     not register a bookmark\n @G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: a requested URI was not found\n @G_BOOKMARK_FILE_ERROR_READ: document was ill formed\n @G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was\n     in an unknown encoding\n @G_BOOKMARK_FILE_ERROR_WRITE: an error occurred while writing\n @G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: requested file was not found\n\n Error codes returned by bookmark file parsing."]
pub type GBookmarkFileError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_bookmark_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBookmarkFile {
    _unused: [u8; 0],
}
#[doc = " GBookmarkFile:\n\n An opaque data structure representing a set of bookmarks."]
pub type GBookmarkFile = _GBookmarkFile;
unsafe extern "C" {
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
}
unsafe extern "C" {
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
}
unsafe extern "C" {
    pub fn g_bookmark_file_load_from_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_load_from_data(
        bookmark: *mut GBookmarkFile,
        data: *const gchar,
        length: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_load_from_data_dirs(
        bookmark: *mut GBookmarkFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_to_data(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_to_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        title: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        description: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        mime_type: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        groups: *mut *const gchar,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_add_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_has_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_add_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_has_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_applications(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
        count: gint,
        stamp: time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        exec: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        stamp: *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *mut *mut gchar,
        count: *mut guint,
        stamp: *mut time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        exec: *mut *mut ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_uint,
        stamp: *mut *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        is_private: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *const gchar,
        mime_type: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *mut *mut gchar,
        mime_type: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        added: time_t,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        added: *mut GDateTime,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        modified: time_t,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        modified: *mut GDateTime,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        visited: time_t,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        visited: *mut GDateTime,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_uris(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_remove_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_remove_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_remove_item(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_move_item(
        bookmark: *mut GBookmarkFile,
        old_uri: *const gchar,
        new_uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_new_with_free_func(
        data: gconstpointer,
        size: gsize,
        free_func: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize, length: gsize) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize) -> gconstpointer;
}
unsafe extern "C" {
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
}
unsafe extern "C" {
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_unref(bytes: *mut GBytes);
}
unsafe extern "C" {
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_bytes_get_region(
        bytes: *mut GBytes,
        element_size: gsize,
        offset: gsize,
        n_elements: gsize,
    ) -> gconstpointer;
}
unsafe extern "C" {
    pub fn g_get_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
unsafe extern "C" {
    pub fn g_get_codeset() -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_get_console_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
unsafe extern "C" {
    pub fn g_get_language_names() -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_get_language_names_with_category(category_name: *const gchar) -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
}
pub const G_CHECKSUM_MD5: GChecksumType = 0;
pub const G_CHECKSUM_SHA1: GChecksumType = 1;
pub const G_CHECKSUM_SHA256: GChecksumType = 2;
pub const G_CHECKSUM_SHA512: GChecksumType = 3;
pub const G_CHECKSUM_SHA384: GChecksumType = 4;
#[doc = " GChecksumType:\n @G_CHECKSUM_MD5: Use the MD5 hashing algorithm\n @G_CHECKSUM_SHA1: Use the SHA-1 hashing algorithm\n @G_CHECKSUM_SHA256: Use the SHA-256 hashing algorithm\n @G_CHECKSUM_SHA384: Use the SHA-384 hashing algorithm (Since: 2.51)\n @G_CHECKSUM_SHA512: Use the SHA-512 hashing algorithm (Since: 2.36)\n\n The hashing algorithm to be used by #GChecksum when performing the\n digest of some data.\n\n Note that the #GChecksumType enumeration may be extended at a later\n date to include new hashing algorithm types.\n\n Since: 2.16"]
pub type GChecksumType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GChecksum {
    _unused: [u8; 0],
}
#[doc = " GChecksum:\n\n An opaque structure representing a checksumming operation.\n\n To create a new GChecksum, use g_checksum_new(). To free\n a GChecksum, use g_checksum_free().\n\n Since: 2.16"]
pub type GChecksum = _GChecksum;
unsafe extern "C" {
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
}
unsafe extern "C" {
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
}
unsafe extern "C" {
    pub fn g_checksum_reset(checksum: *mut GChecksum);
}
unsafe extern "C" {
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
}
unsafe extern "C" {
    pub fn g_checksum_free(checksum: *mut GChecksum);
}
unsafe extern "C" {
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar, length: gssize);
}
unsafe extern "C" {
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_checksum_get_digest(
        checksum: *mut GChecksum,
        buffer: *mut guint8,
        digest_len: *mut gsize,
    );
}
unsafe extern "C" {
    pub fn g_compute_checksum_for_data(
        checksum_type: GChecksumType,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_compute_checksum_for_string(
        checksum_type: GChecksumType,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_compute_checksum_for_bytes(
        checksum_type: GChecksumType,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub const G_CONVERT_ERROR_NO_CONVERSION: GConvertError = 0;
pub const G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = 1;
pub const G_CONVERT_ERROR_FAILED: GConvertError = 2;
pub const G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = 3;
pub const G_CONVERT_ERROR_BAD_URI: GConvertError = 4;
pub const G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = 5;
pub const G_CONVERT_ERROR_NO_MEMORY: GConvertError = 6;
pub const G_CONVERT_ERROR_EMBEDDED_NUL: GConvertError = 7;
#[doc = " GConvertError:\n @G_CONVERT_ERROR_NO_CONVERSION: Conversion between the requested character\n     sets is not supported.\n @G_CONVERT_ERROR_ILLEGAL_SEQUENCE: Invalid byte sequence in conversion input;\n    or the character sequence could not be represented in the target\n    character set.\n @G_CONVERT_ERROR_FAILED: Conversion failed for some reason.\n @G_CONVERT_ERROR_PARTIAL_INPUT: Partial character sequence at end of input.\n @G_CONVERT_ERROR_BAD_URI: URI is invalid.\n @G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: Pathname is not an absolute path.\n @G_CONVERT_ERROR_NO_MEMORY: No memory available. Since: 2.40\n @G_CONVERT_ERROR_EMBEDDED_NUL: An embedded NUL character is present in\n     conversion output where a NUL-terminated string is expected.\n     Since: 2.56\n\n Error codes returned by character set conversion routines."]
pub type GConvertError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_convert_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIConv {
    _unused: [u8; 0],
}
#[doc = " GIConv: (skip)\n\n The GIConv struct wraps an iconv() conversion descriptor. It contains\n private data and should only be accessed using the following functions."]
pub type GIConv = *mut _GIConv;
unsafe extern "C" {
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar) -> GIConv;
}
unsafe extern "C" {
    pub fn g_iconv(
        converter: GIConv,
        inbuf: *mut *mut gchar,
        inbytes_left: *mut gsize,
        outbuf: *mut *mut gchar,
        outbytes_left: *mut gsize,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_iconv_close(converter: GIConv) -> gint;
}
unsafe extern "C" {
    pub fn g_convert(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_convert_with_iconv(
        str_: *const gchar,
        len: gssize,
        converter: GIConv,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_convert_with_fallback(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        fallback: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_locale_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_locale_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_from_uri(
        uri: *const gchar,
        hostname: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_to_uri(
        filename: *const gchar,
        hostname: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_get_filename_charsets(filename_charsets: *mut *mut *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GDataForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(key_id: GQuark, data: gpointer, user_data: gpointer),
>;
unsafe extern "C" {
    pub fn g_datalist_init(datalist: *mut *mut GData);
}
unsafe extern "C" {
    pub fn g_datalist_clear(datalist: *mut *mut GData);
}
unsafe extern "C" {
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_datalist_id_set_data_full(
        datalist: *mut *mut GData,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
pub type GDuplicateFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
unsafe extern "C" {
    pub fn g_datalist_id_dup_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_datalist_id_replace_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_datalist_foreach(
        datalist: *mut *mut GData,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
}
unsafe extern "C" {
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
}
unsafe extern "C" {
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
}
unsafe extern "C" {
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
}
unsafe extern "C" {
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar) -> gpointer;
}
unsafe extern "C" {
    pub fn g_dataset_id_set_data_full(
        dataset_location: gconstpointer,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_dataset_id_remove_no_notify(
        dataset_location: gconstpointer,
        key_id: GQuark,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_dataset_foreach(
        dataset_location: gconstpointer,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = _GDate;
pub const G_DATE_DAY: GDateDMY = 0;
pub const G_DATE_MONTH: GDateDMY = 1;
pub const G_DATE_YEAR: GDateDMY = 2;
pub type GDateDMY = ::std::os::raw::c_uint;
pub const G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const G_DATE_MONDAY: GDateWeekday = 1;
pub const G_DATE_TUESDAY: GDateWeekday = 2;
pub const G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const G_DATE_THURSDAY: GDateWeekday = 4;
pub const G_DATE_FRIDAY: GDateWeekday = 5;
pub const G_DATE_SATURDAY: GDateWeekday = 6;
pub const G_DATE_SUNDAY: GDateWeekday = 7;
pub type GDateWeekday = ::std::os::raw::c_uint;
pub const G_DATE_BAD_MONTH: GDateMonth = 0;
pub const G_DATE_JANUARY: GDateMonth = 1;
pub const G_DATE_FEBRUARY: GDateMonth = 2;
pub const G_DATE_MARCH: GDateMonth = 3;
pub const G_DATE_APRIL: GDateMonth = 4;
pub const G_DATE_MAY: GDateMonth = 5;
pub const G_DATE_JUNE: GDateMonth = 6;
pub const G_DATE_JULY: GDateMonth = 7;
pub const G_DATE_AUGUST: GDateMonth = 8;
pub const G_DATE_SEPTEMBER: GDateMonth = 9;
pub const G_DATE_OCTOBER: GDateMonth = 10;
pub const G_DATE_NOVEMBER: GDateMonth = 11;
pub const G_DATE_DECEMBER: GDateMonth = 12;
pub type GDateMonth = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDate {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDate"][::std::mem::size_of::<_GDate>() - 8usize];
    ["Alignment of _GDate"][::std::mem::align_of::<_GDate>() - 4usize];
};
impl _GDate {
    #[inline]
    pub fn julian_days(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_julian_days(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn julian_days_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                32u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_julian_days_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                32u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn julian(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_julian(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn julian_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_julian_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dmy(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmy(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dmy_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dmy_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn day(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn day_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_day_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn month(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn month_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_month_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn year(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn year_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                44usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_year_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        julian_days: guint,
        julian: guint,
        dmy: guint,
        day: guint,
        month: guint,
        year: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let julian_days: u32 = unsafe { ::std::mem::transmute(julian_days) };
            julian_days as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let julian: u32 = unsafe { ::std::mem::transmute(julian) };
            julian as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dmy: u32 = unsafe { ::std::mem::transmute(dmy) };
            dmy as u64
        });
        __bindgen_bitfield_unit.set(34usize, 6u8, {
            let day: u32 = unsafe { ::std::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let month: u32 = unsafe { ::std::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(44usize, 16u8, {
            let year: u32 = unsafe { ::std::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub fn g_date_new() -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_free(date: *mut GDate);
}
unsafe extern "C" {
    pub fn g_date_copy(date: *const GDate) -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_valid(date: *const GDate) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
}
unsafe extern "C" {
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
}
unsafe extern "C" {
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
}
unsafe extern "C" {
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
}
unsafe extern "C" {
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
}
unsafe extern "C" {
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
}
unsafe extern "C" {
    pub fn g_date_set_parse(date: *mut GDate, str_: *const gchar);
}
unsafe extern "C" {
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
}
unsafe extern "C" {
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
}
unsafe extern "C" {
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
}
unsafe extern "C" {
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
}
unsafe extern "C" {
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
}
unsafe extern "C" {
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
}
unsafe extern "C" {
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
}
unsafe extern "C" {
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
}
unsafe extern "C" {
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
}
unsafe extern "C" {
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
}
unsafe extern "C" {
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
}
unsafe extern "C" {
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
}
unsafe extern "C" {
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
}
unsafe extern "C" {
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
}
unsafe extern "C" {
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> guint8;
}
unsafe extern "C" {
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
}
unsafe extern "C" {
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
}
unsafe extern "C" {
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
}
unsafe extern "C" {
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
}
unsafe extern "C" {
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut tm);
}
unsafe extern "C" {
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
}
unsafe extern "C" {
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
}
unsafe extern "C" {
    pub fn g_date_strftime(
        s: *mut gchar,
        slen: gsize,
        format: *const gchar,
        date: *const GDate,
    ) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of dirent"][::std::mem::size_of::<dirent>() - 280usize];
    ["Alignment of dirent"][::std::mem::align_of::<dirent>() - 8usize];
    ["Offset of field: dirent::d_ino"][::std::mem::offset_of!(dirent, d_ino) - 0usize];
    ["Offset of field: dirent::d_off"][::std::mem::offset_of!(dirent, d_off) - 8usize];
    ["Offset of field: dirent::d_reclen"][::std::mem::offset_of!(dirent, d_reclen) - 16usize];
    ["Offset of field: dirent::d_type"][::std::mem::offset_of!(dirent, d_type) - 18usize];
    ["Offset of field: dirent::d_name"][::std::mem::offset_of!(dirent, d_name) - 19usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent64 {
    pub d_ino: __ino64_t,
    pub d_off: __off64_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of dirent64"][::std::mem::size_of::<dirent64>() - 280usize];
    ["Alignment of dirent64"][::std::mem::align_of::<dirent64>() - 8usize];
    ["Offset of field: dirent64::d_ino"][::std::mem::offset_of!(dirent64, d_ino) - 0usize];
    ["Offset of field: dirent64::d_off"][::std::mem::offset_of!(dirent64, d_off) - 8usize];
    ["Offset of field: dirent64::d_reclen"][::std::mem::offset_of!(dirent64, d_reclen) - 16usize];
    ["Offset of field: dirent64::d_type"][::std::mem::offset_of!(dirent64, d_type) - 18usize];
    ["Offset of field: dirent64::d_name"][::std::mem::offset_of!(dirent64, d_name) - 19usize];
};
pub const DT_UNKNOWN: _bindgen_ty_26 = 0;
pub const DT_FIFO: _bindgen_ty_26 = 1;
pub const DT_CHR: _bindgen_ty_26 = 2;
pub const DT_DIR: _bindgen_ty_26 = 4;
pub const DT_BLK: _bindgen_ty_26 = 6;
pub const DT_REG: _bindgen_ty_26 = 8;
pub const DT_LNK: _bindgen_ty_26 = 10;
pub const DT_SOCK: _bindgen_ty_26 = 12;
pub const DT_WHT: _bindgen_ty_26 = 14;
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
unsafe extern "C" {
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
}
unsafe extern "C" {
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
}
unsafe extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
unsafe extern "C" {
    pub fn readdir64(__dirp: *mut DIR) -> *mut dirent64;
}
unsafe extern "C" {
    pub fn readdir_r(
        __dirp: *mut DIR,
        __entry: *mut dirent,
        __result: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readdir64_r(
        __dirp: *mut DIR,
        __entry: *mut dirent64,
        __result: *mut *mut dirent64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
unsafe extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scandir(
        __dir: *const ::std::os::raw::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scandir64(
        __dir: *const ::std::os::raw::c_char,
        __namelist: *mut *mut *mut dirent64,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent64) -> ::std::os::raw::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent64,
                arg2: *mut *const dirent64,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scandirat(
        __dfd: ::std::os::raw::c_int,
        __dir: *const ::std::os::raw::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scandirat64(
        __dfd: ::std::os::raw::c_int,
        __dir: *const ::std::os::raw::c_char,
        __namelist: *mut *mut *mut dirent64,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent64) -> ::std::os::raw::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent64,
                arg2: *mut *const dirent64,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn alphasort64(
        __e1: *mut *const dirent64,
        __e2: *mut *const dirent64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdirentries(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
        __basep: *mut __off_t,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getdirentries64(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
        __basep: *mut __off64_t,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn versionsort(__e1: *mut *const dirent, __e2: *mut *const dirent)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn versionsort64(
        __e1: *mut *const dirent64,
        __e2: *mut *const dirent64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdents64(
        __fd: ::std::os::raw::c_int,
        __buffer: *mut ::std::os::raw::c_void,
        __length: usize,
    ) -> __ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDir {
    _unused: [u8; 0],
}
pub type GDir = _GDir;
unsafe extern "C" {
    pub fn g_dir_open(path: *const gchar, flags: guint, error: *mut *mut GError) -> *mut GDir;
}
unsafe extern "C" {
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dir_rewind(dir: *mut GDir);
}
unsafe extern "C" {
    pub fn g_dir_close(dir: *mut GDir);
}
unsafe extern "C" {
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_setenv(variable: *const gchar, value: *const gchar, overwrite: gboolean) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unsetenv(variable: *const gchar);
}
unsafe extern "C" {
    pub fn g_listenv() -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_get_environ() -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_environ_setenv(
        envp: *mut *mut gchar,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar) -> *mut *mut gchar;
}
pub const G_FILE_ERROR_EXIST: GFileError = 0;
pub const G_FILE_ERROR_ISDIR: GFileError = 1;
pub const G_FILE_ERROR_ACCES: GFileError = 2;
pub const G_FILE_ERROR_NAMETOOLONG: GFileError = 3;
pub const G_FILE_ERROR_NOENT: GFileError = 4;
pub const G_FILE_ERROR_NOTDIR: GFileError = 5;
pub const G_FILE_ERROR_NXIO: GFileError = 6;
pub const G_FILE_ERROR_NODEV: GFileError = 7;
pub const G_FILE_ERROR_ROFS: GFileError = 8;
pub const G_FILE_ERROR_TXTBSY: GFileError = 9;
pub const G_FILE_ERROR_FAULT: GFileError = 10;
pub const G_FILE_ERROR_LOOP: GFileError = 11;
pub const G_FILE_ERROR_NOSPC: GFileError = 12;
pub const G_FILE_ERROR_NOMEM: GFileError = 13;
pub const G_FILE_ERROR_MFILE: GFileError = 14;
pub const G_FILE_ERROR_NFILE: GFileError = 15;
pub const G_FILE_ERROR_BADF: GFileError = 16;
pub const G_FILE_ERROR_INVAL: GFileError = 17;
pub const G_FILE_ERROR_PIPE: GFileError = 18;
pub const G_FILE_ERROR_AGAIN: GFileError = 19;
pub const G_FILE_ERROR_INTR: GFileError = 20;
pub const G_FILE_ERROR_IO: GFileError = 21;
pub const G_FILE_ERROR_PERM: GFileError = 22;
pub const G_FILE_ERROR_NOSYS: GFileError = 23;
pub const G_FILE_ERROR_FAILED: GFileError = 24;
pub type GFileError = ::std::os::raw::c_uint;
pub const G_FILE_TEST_IS_REGULAR: GFileTest = 1;
pub const G_FILE_TEST_IS_SYMLINK: GFileTest = 2;
pub const G_FILE_TEST_IS_DIR: GFileTest = 4;
pub const G_FILE_TEST_IS_EXECUTABLE: GFileTest = 8;
pub const G_FILE_TEST_EXISTS: GFileTest = 16;
pub type GFileTest = ::std::os::raw::c_uint;
pub const G_FILE_SET_CONTENTS_NONE: GFileSetContentsFlags = 0;
pub const G_FILE_SET_CONTENTS_CONSISTENT: GFileSetContentsFlags = 1;
pub const G_FILE_SET_CONTENTS_DURABLE: GFileSetContentsFlags = 2;
pub const G_FILE_SET_CONTENTS_ONLY_EXISTING: GFileSetContentsFlags = 4;
#[doc = " GFileSetContentsFlags:\n @G_FILE_SET_CONTENTS_NONE: No guarantees about file consistency or durability.\n   The most dangerous setting, which is slightly faster than other settings.\n @G_FILE_SET_CONTENTS_CONSISTENT: Guarantee file consistency: after a crash,\n   either the old version of the file or the new version of the file will be\n   available, but not a mixture. On Unix systems this equates to an `fsync()`\n   on the file and use of an atomic `rename()` of the new version of the file\n   over the old.\n @G_FILE_SET_CONTENTS_DURABLE: Guarantee file durability: after a crash, the\n   new version of the file will be available. On Unix systems this equates to\n   an `fsync()` on the file (if %G_FILE_SET_CONTENTS_CONSISTENT is unset), or\n   the effects of %G_FILE_SET_CONTENTS_CONSISTENT plus an `fsync()` on the\n   directory containing the file after calling `rename()`.\n @G_FILE_SET_CONTENTS_ONLY_EXISTING: Only apply consistency and durability\n   guarantees if the file already exists. This may speed up file operations\n   if the file doesnt currently exist, but may result in a corrupted version\n   of the new file if the system crashes while writing it.\n\n Flags to pass to g_file_set_contents_full() to affect its safety and\n performance.\n\n Since: 2.66"]
pub type GFileSetContentsFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_file_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
}
unsafe extern "C" {
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_get_contents(
        filename: *const gchar,
        contents: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_set_contents(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_set_contents_full(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        flags: GFileSetContentsFlags,
        mode: ::std::os::raw::c_int,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_file_open_tmp(
        tmpl: *const gchar,
        name_used: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_path(separator: *const gchar, first_element: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_filename_valist(first_element: *const gchar, args: *mut va_list) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_current_dir() -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_canonicalize_filename(filename: *const gchar, relative_to: *const gchar)
        -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar, category: gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dngettext(
        domain: *const gchar,
        msgid: *const gchar,
        msgid_plural: *const gchar,
        n: gulong,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dpgettext(
        domain: *const gchar,
        msgctxtid: *const gchar,
        msgidoffset: gsize,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dpgettext2(
        domain: *const gchar,
        context: *const gchar,
        msgid: *const gchar,
    ) -> *const gchar;
}
#[doc = " GMemVTable:\n @malloc: function to use for allocating memory.\n @realloc: function to use for reallocating memory.\n @free: function to use to free memory.\n @calloc: function to use for allocating zero-filled memory.\n @try_malloc: function to use for allocating memory without a default error handler.\n @try_realloc: function to use for reallocating memory without a default error handler.\n\n A set of functions used to perform memory allocation. The same #GMemVTable must\n be used for all allocations in the same program; a call to g_mem_set_vtable(),\n if it exists, should be prior to any use of GLib.\n\n This functions related to this has been deprecated in 2.46, and no longer work."]
pub type GMemVTable = _GMemVTable;
unsafe extern "C" {
    pub fn g_free(mem: gpointer);
}
unsafe extern "C" {
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_aligned_alloc(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_aligned_alloc0(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_aligned_free(mem: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemVTable {
    pub malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
    pub free: ::std::option::Option<unsafe extern "C" fn(mem: gpointer)>,
    pub calloc: ::std::option::Option<
        unsafe extern "C" fn(n_blocks: gsize, n_block_bytes: gsize) -> gpointer,
    >,
    pub try_malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub try_realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMemVTable"][::std::mem::size_of::<_GMemVTable>() - 48usize];
    ["Alignment of _GMemVTable"][::std::mem::align_of::<_GMemVTable>() - 8usize];
    ["Offset of field: _GMemVTable::malloc"][::std::mem::offset_of!(_GMemVTable, malloc) - 0usize];
    ["Offset of field: _GMemVTable::realloc"]
        [::std::mem::offset_of!(_GMemVTable, realloc) - 8usize];
    ["Offset of field: _GMemVTable::free"][::std::mem::offset_of!(_GMemVTable, free) - 16usize];
    ["Offset of field: _GMemVTable::calloc"][::std::mem::offset_of!(_GMemVTable, calloc) - 24usize];
    ["Offset of field: _GMemVTable::try_malloc"]
        [::std::mem::offset_of!(_GMemVTable, try_malloc) - 32usize];
    ["Offset of field: _GMemVTable::try_realloc"]
        [::std::mem::offset_of!(_GMemVTable, try_realloc) - 40usize];
};
unsafe extern "C" {
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
}
unsafe extern "C" {
    pub fn g_mem_is_system_malloc() -> gboolean;
}
unsafe extern "C" {
    pub static mut g_mem_gc_friendly: gboolean;
}
unsafe extern "C" {
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
}
unsafe extern "C" {
    pub fn g_mem_profile();
}
pub type GNode = _GNode;
pub const G_TRAVERSE_LEAVES: GTraverseFlags = 1;
pub const G_TRAVERSE_NON_LEAVES: GTraverseFlags = 2;
pub const G_TRAVERSE_ALL: GTraverseFlags = 3;
pub const G_TRAVERSE_MASK: GTraverseFlags = 3;
pub const G_TRAVERSE_LEAFS: GTraverseFlags = 1;
pub const G_TRAVERSE_NON_LEAFS: GTraverseFlags = 2;
pub type GTraverseFlags = ::std::os::raw::c_uint;
pub const G_IN_ORDER: GTraverseType = 0;
pub const G_PRE_ORDER: GTraverseType = 1;
pub const G_POST_ORDER: GTraverseType = 2;
pub const G_LEVEL_ORDER: GTraverseType = 3;
pub type GTraverseType = ::std::os::raw::c_uint;
pub type GNodeTraverseFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer) -> gboolean>;
pub type GNodeForeachFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GNode"][::std::mem::size_of::<_GNode>() - 40usize];
    ["Alignment of _GNode"][::std::mem::align_of::<_GNode>() - 8usize];
    ["Offset of field: _GNode::data"][::std::mem::offset_of!(_GNode, data) - 0usize];
    ["Offset of field: _GNode::next"][::std::mem::offset_of!(_GNode, next) - 8usize];
    ["Offset of field: _GNode::prev"][::std::mem::offset_of!(_GNode, prev) - 16usize];
    ["Offset of field: _GNode::parent"][::std::mem::offset_of!(_GNode, parent) - 24usize];
    ["Offset of field: _GNode::children"][::std::mem::offset_of!(_GNode, children) - 32usize];
};
unsafe extern "C" {
    pub fn g_node_new(data: gpointer) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_destroy(root: *mut GNode);
}
unsafe extern "C" {
    pub fn g_node_unlink(node: *mut GNode);
}
unsafe extern "C" {
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_insert_before(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_insert_after(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
}
unsafe extern "C" {
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
}
unsafe extern "C" {
    pub fn g_node_depth(node: *mut GNode) -> guint;
}
unsafe extern "C" {
    pub fn g_node_find(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        data: gpointer,
    ) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_traverse(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        max_depth: gint,
        func: GNodeTraverseFunc,
        data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_node_max_height(root: *mut GNode) -> guint;
}
unsafe extern "C" {
    pub fn g_node_children_foreach(
        node: *mut GNode,
        flags: GTraverseFlags,
        func: GNodeForeachFunc,
        data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_node_reverse_children(node: *mut GNode);
}
unsafe extern "C" {
    pub fn g_node_n_children(node: *mut GNode) -> guint;
}
unsafe extern "C" {
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer)
        -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
}
unsafe extern "C" {
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GList"][::std::mem::size_of::<_GList>() - 24usize];
    ["Alignment of _GList"][::std::mem::align_of::<_GList>() - 8usize];
    ["Offset of field: _GList::data"][::std::mem::offset_of!(_GList, data) - 0usize];
    ["Offset of field: _GList::next"][::std::mem::offset_of!(_GList, next) - 8usize];
    ["Offset of field: _GList::prev"][::std::mem::offset_of!(_GList, prev) - 16usize];
};
unsafe extern "C" {
    pub fn g_list_alloc() -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_free(list: *mut GList);
}
unsafe extern "C" {
    pub fn g_list_free_1(list: *mut GList);
}
unsafe extern "C" {
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc)
        -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_sorted_with_data(
        list: *mut GList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_before(
        list: *mut GList,
        sibling: *mut GList,
        data: gpointer,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_before_link(
        list: *mut GList,
        sibling: *mut GList,
        link_: *mut GList,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_find_custom(
        list: *mut GList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
}
unsafe extern "C" {
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_list_last(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_first(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_length(list: *mut GList) -> guint;
}
unsafe extern "C" {
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_sort_with_data(
        list: *mut GList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_clear_list(list_ptr: *mut *mut GList, destroy: GDestroyNotify);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
pub type GHRFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer) -> gboolean,
>;
pub type GHashTableIter = _GHashTableIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: ::std::os::raw::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GHashTableIter"][::std::mem::size_of::<_GHashTableIter>() - 40usize];
    ["Alignment of _GHashTableIter"][::std::mem::align_of::<_GHashTableIter>() - 8usize];
    ["Offset of field: _GHashTableIter::dummy1"]
        [::std::mem::offset_of!(_GHashTableIter, dummy1) - 0usize];
    ["Offset of field: _GHashTableIter::dummy2"]
        [::std::mem::offset_of!(_GHashTableIter, dummy2) - 8usize];
    ["Offset of field: _GHashTableIter::dummy3"]
        [::std::mem::offset_of!(_GHashTableIter, dummy3) - 16usize];
    ["Offset of field: _GHashTableIter::dummy4"]
        [::std::mem::offset_of!(_GHashTableIter, dummy4) - 24usize];
    ["Offset of field: _GHashTableIter::dummy5"]
        [::std::mem::offset_of!(_GHashTableIter, dummy5) - 28usize];
    ["Offset of field: _GHashTableIter::dummy6"]
        [::std::mem::offset_of!(_GHashTableIter, dummy6) - 32usize];
};
unsafe extern "C" {
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_new_full(
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_new_similar(other_hash_table: *mut GHashTable) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_hash_table_insert(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_replace(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_steal_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        stolen_key: *mut gpointer,
        stolen_value: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_lookup_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_hash_table_find(
        hash_table: *mut GHashTable,
        predicate: GHRFunc,
        user_data: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_hash_table_foreach_remove(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_hash_table_foreach_steal(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
}
unsafe extern "C" {
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_hash_table_get_keys_as_array(
        hash_table: *mut GHashTable,
        length: *mut guint,
    ) -> *mut gpointer;
}
unsafe extern "C" {
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_hash_table_iter_next(
        iter: *mut GHashTableIter,
        key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
}
unsafe extern "C" {
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
}
unsafe extern "C" {
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
}
unsafe extern "C" {
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_str_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_int_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_int64_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_double_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_direct_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHmac {
    _unused: [u8; 0],
}
#[doc = " GHmac:\n\n An opaque structure representing a HMAC operation.\n To create a new GHmac, use g_hmac_new(). To free\n a GHmac, use g_hmac_unref().\n\n Since: 2.30"]
pub type GHmac = _GHmac;
unsafe extern "C" {
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar, key_len: gsize)
        -> *mut GHmac;
}
unsafe extern "C" {
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
}
unsafe extern "C" {
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
}
unsafe extern "C" {
    pub fn g_hmac_unref(hmac: *mut GHmac);
}
unsafe extern "C" {
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar, length: gssize);
}
unsafe extern "C" {
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8, digest_len: *mut gsize);
}
unsafe extern "C" {
    pub fn g_compute_hmac_for_data(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_compute_hmac_for_string(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_compute_hmac_for_bytes(
        digest_type: GChecksumType,
        key: *mut GBytes,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub type GHook = _GHook;
pub type GHookList = _GHookList;
pub type GHookCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(new_hook: *mut GHook, sibling: *mut GHook) -> gint>;
pub type GHookFindFunc =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, data: gpointer) -> gboolean>;
pub type GHookMarshaller =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer)>;
pub type GHookCheckMarshaller = ::std::option::Option<
    unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer) -> gboolean,
>;
pub type GHookFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(hook_list: *mut GHookList, hook: *mut GHook)>;
pub const G_HOOK_FLAG_ACTIVE: GHookFlagMask = 1;
pub const G_HOOK_FLAG_IN_CALL: GHookFlagMask = 2;
pub const G_HOOK_FLAG_MASK: GHookFlagMask = 15;
pub type GHookFlagMask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHookList {
    pub seq_id: gulong,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GHookList"][::std::mem::size_of::<_GHookList>() - 56usize];
    ["Alignment of _GHookList"][::std::mem::align_of::<_GHookList>() - 8usize];
    ["Offset of field: _GHookList::seq_id"][::std::mem::offset_of!(_GHookList, seq_id) - 0usize];
    ["Offset of field: _GHookList::hooks"][::std::mem::offset_of!(_GHookList, hooks) - 16usize];
    ["Offset of field: _GHookList::dummy3"][::std::mem::offset_of!(_GHookList, dummy3) - 24usize];
    ["Offset of field: _GHookList::finalize_hook"]
        [::std::mem::offset_of!(_GHookList, finalize_hook) - 32usize];
    ["Offset of field: _GHookList::dummy"][::std::mem::offset_of!(_GHookList, dummy) - 40usize];
};
impl _GHookList {
    #[inline]
    pub fn hook_size(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hook_size(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hook_size_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hook_size_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_setup(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_setup(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_setup_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_setup_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hook_size: guint,
        is_setup: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let hook_size: u32 = unsafe { ::std::mem::transmute(hook_size) };
            hook_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is_setup: u32 = unsafe { ::std::mem::transmute(is_setup) };
            is_setup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GHook"][::std::mem::size_of::<_GHook>() - 64usize];
    ["Alignment of _GHook"][::std::mem::align_of::<_GHook>() - 8usize];
    ["Offset of field: _GHook::data"][::std::mem::offset_of!(_GHook, data) - 0usize];
    ["Offset of field: _GHook::next"][::std::mem::offset_of!(_GHook, next) - 8usize];
    ["Offset of field: _GHook::prev"][::std::mem::offset_of!(_GHook, prev) - 16usize];
    ["Offset of field: _GHook::ref_count"][::std::mem::offset_of!(_GHook, ref_count) - 24usize];
    ["Offset of field: _GHook::hook_id"][::std::mem::offset_of!(_GHook, hook_id) - 32usize];
    ["Offset of field: _GHook::flags"][::std::mem::offset_of!(_GHook, flags) - 40usize];
    ["Offset of field: _GHook::func"][::std::mem::offset_of!(_GHook, func) - 48usize];
    ["Offset of field: _GHook::destroy"][::std::mem::offset_of!(_GHook, destroy) - 56usize];
};
unsafe extern "C" {
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
}
unsafe extern "C" {
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
}
unsafe extern "C" {
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_insert_sorted(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        func: GHookCompareFunc,
    );
}
unsafe extern "C" {
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_find(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: GHookFindFunc,
        data: gpointer,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_find_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        data: gpointer,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_find_func(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_find_func_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
        data: gpointer,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_next_valid(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        may_be_in_call: gboolean,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> gint;
}
unsafe extern "C" {
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
}
unsafe extern "C" {
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
}
unsafe extern "C" {
    pub fn g_hook_list_marshal(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookMarshaller,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_hook_list_marshal_check(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookCheckMarshaller,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
}
#[doc = " GPollFD:\n @fd: the file descriptor to poll (or a HANDLE on Win32)\n @events: a bitwise combination from #GIOCondition, specifying which\n     events should be polled for. Typically for reading from a file\n     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and\n     for writing you would use %G_IO_OUT | %G_IO_ERR.\n @revents: a bitwise combination of flags from #GIOCondition, returned\n     from the poll() function to indicate which events occurred.\n\n Represents a file descriptor, which events to poll for, and which events\n occurred."]
pub type GPollFD = _GPollFD;
#[doc = " GPollFunc:\n @ufds: an array of #GPollFD elements\n @nfsd: the number of elements in @ufds\n @timeout_: the maximum time to wait for an event of the file descriptors.\n     A negative value indicates an infinite timeout.\n\n Specifies the type of function passed to g_main_context_set_poll_func().\n The semantics of the function should match those of the poll() system call.\n\n Returns: the number of #GPollFD elements which have events or errors\n     reported, or -1 if an error occurred."]
pub type GPollFunc = ::std::option::Option<
    unsafe extern "C" fn(ufds: *mut GPollFD, nfsd: guint, timeout_: gint) -> gint,
>;
#[doc = " GPollFD:\n @fd: the file descriptor to poll (or a HANDLE on Win32)\n @events: a bitwise combination from #GIOCondition, specifying which\n     events should be polled for. Typically for reading from a file\n     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and\n     for writing you would use %G_IO_OUT | %G_IO_ERR.\n @revents: a bitwise combination of flags from #GIOCondition, returned\n     from the poll() function to indicate which events occurred.\n\n Represents a file descriptor, which events to poll for, and which events\n occurred."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollFD {
    pub fd: gint,
    pub events: gushort,
    pub revents: gushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPollFD"][::std::mem::size_of::<_GPollFD>() - 8usize];
    ["Alignment of _GPollFD"][::std::mem::align_of::<_GPollFD>() - 4usize];
    ["Offset of field: _GPollFD::fd"][::std::mem::offset_of!(_GPollFD, fd) - 0usize];
    ["Offset of field: _GPollFD::events"][::std::mem::offset_of!(_GPollFD, events) - 4usize];
    ["Offset of field: _GPollFD::revents"][::std::mem::offset_of!(_GPollFD, revents) - 6usize];
};
unsafe extern "C" {
    #[doc = " G_POLLFD_FORMAT:\n\n A format specifier that can be used in printf()-style format strings\n when printing the @fd member of a #GPollFD."]
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSList"][::std::mem::size_of::<_GSList>() - 16usize];
    ["Alignment of _GSList"][::std::mem::align_of::<_GSList>() - 8usize];
    ["Offset of field: _GSList::data"][::std::mem::offset_of!(_GSList, data) - 0usize];
    ["Offset of field: _GSList::next"][::std::mem::offset_of!(_GSList, next) - 8usize];
};
unsafe extern "C" {
    pub fn g_slist_alloc() -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_free(list: *mut GSList);
}
unsafe extern "C" {
    pub fn g_slist_free_1(list: *mut GSList);
}
unsafe extern "C" {
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert_sorted(
        list: *mut GSList,
        data: gpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert_sorted_with_data(
        list: *mut GSList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert_before(
        slist: *mut GSList,
        sibling: *mut GSList,
        data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_copy_deep(
        list: *mut GSList,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_find_custom(
        list: *mut GSList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
}
unsafe extern "C" {
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_length(list: *mut GSList) -> guint;
}
unsafe extern "C" {
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_sort_with_data(
        list: *mut GSList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_clear_slist(slist_ptr: *mut *mut GSList, destroy: GDestroyNotify);
}
pub const G_IO_IN: GIOCondition = 1;
pub const G_IO_OUT: GIOCondition = 4;
pub const G_IO_PRI: GIOCondition = 2;
pub const G_IO_ERR: GIOCondition = 8;
pub const G_IO_HUP: GIOCondition = 16;
pub const G_IO_NVAL: GIOCondition = 32;
pub type GIOCondition = ::std::os::raw::c_uint;
pub const G_MAIN_CONTEXT_FLAGS_NONE: GMainContextFlags = 0;
pub const G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: GMainContextFlags = 1;
#[doc = " GMainContextFlags:\n @G_MAIN_CONTEXT_FLAGS_NONE: Default behaviour.\n @G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: Assume that polling for events will\n free the thread to process other jobs. That's useful if you're using\n `g_main_context_{prepare,query,check,dispatch}` to integrate GMainContext in\n other event loops.\n\n Flags to pass to g_main_context_new_with_flags() which affect the behaviour\n of a #GMainContext.\n\n Since: 2.72"]
pub type GMainContextFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainContext {
    _unused: [u8; 0],
}
#[doc = " GMainContext:\n\n The `GMainContext` struct is an opaque data\n type representing a set of sources to be handled in a main loop."]
pub type GMainContext = _GMainContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainLoop {
    _unused: [u8; 0],
}
#[doc = " GMainLoop:\n\n The `GMainLoop` struct is an opaque data type\n representing the main event loop of a GLib or GTK+ application."]
pub type GMainLoop = _GMainLoop;
#[doc = " GSource:\n\n The `GSource` struct is an opaque data type\n representing an event source."]
pub type GSource = _GSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourcePrivate {
    _unused: [u8; 0],
}
pub type GSourcePrivate = _GSourcePrivate;
#[doc = " GSourceCallbackFuncs:\n @ref: Called when a reference is added to the callback object\n @unref: Called when a reference to the callback object is dropped\n @get: Called to extract the callback function and data from the\n     callback object.\n\n The `GSourceCallbackFuncs` struct contains\n functions for managing callback objects."]
pub type GSourceCallbackFuncs = _GSourceCallbackFuncs;
#[doc = " GSourceFuncs:\n @prepare: Called before all the file descriptors are polled. If the\n     source can determine that it is ready here (without waiting for the\n     results of the poll() call) it should return %TRUE. It can also return\n     a @timeout_ value which should be the maximum timeout (in milliseconds)\n     which should be passed to the poll() call. The actual timeout used will\n     be -1 if all sources returned -1, or it will be the minimum of all\n     the @timeout_ values returned which were >= 0.  Since 2.36 this may\n     be %NULL, in which case the effect is as if the function always returns\n     %FALSE with a timeout of -1.  If @prepare returns a\n     timeout and the source also has a ready time set, then the\n     lower of the two will be used.\n @check: Called after all the file descriptors are polled. The source\n     should return %TRUE if it is ready to be dispatched. Note that some\n     time may have passed since the previous prepare function was called,\n     so the source should be checked again here.  Since 2.36 this may\n     be %NULL, in which case the effect is as if the function always returns\n     %FALSE.\n @dispatch: Called to dispatch the event source, after it has returned\n     %TRUE in either its @prepare or its @check function, or if a ready time\n     has been reached. The @dispatch function receives a callback function and\n     user data. The callback function may be %NULL if the source was never\n     connected to a callback using g_source_set_callback(). The @dispatch\n     function should call the callback function with @user_data and whatever\n     additional parameters are needed for this type of event source. The\n     return value of the @dispatch function should be %G_SOURCE_REMOVE if the\n     source should be removed or %G_SOURCE_CONTINUE to keep it.\n @finalize: Called when the source is finalized. At this point, the source\n     will have been destroyed, had its callback cleared, and have been removed\n     from its #GMainContext, but it will still have its final reference count,\n     so methods can be called on it from within this function.\n\n The `GSourceFuncs` struct contains a table of\n functions used to handle event sources in a generic manner.\n\n For idle sources, the prepare and check functions always return %TRUE\n to indicate that the source is always ready to be processed. The prepare\n function also returns a timeout value of 0 to ensure that the poll() call\n doesn't block (since that would be time wasted which could have been spent\n running the idle function).\n\n For timeout sources, the prepare and check functions both return %TRUE\n if the timeout interval has expired. The prepare function also returns\n a timeout value to ensure that the poll() call doesn't block too long\n and miss the next timeout.\n\n For file descriptor sources, the prepare function typically returns %FALSE,\n since it must wait until poll() has been called before it knows whether\n any events need to be processed. It sets the returned timeout to -1 to\n indicate that it doesn't mind how long the poll() call blocks. In the\n check function, it tests the results of the poll() call to see if the\n required condition has been met, and returns %TRUE if so."]
pub type GSourceFuncs = _GSourceFuncs;
#[doc = " GSourceFunc:\n @user_data: data passed to the function, set when the source was\n     created with one of the above functions\n\n Specifies the type of function passed to g_timeout_add(),\n g_timeout_add_full(), g_idle_add(), and g_idle_add_full().\n\n When calling g_source_set_callback(), you may need to cast a function of a\n different type to this type. Use G_SOURCE_FUNC() to avoid warnings about\n incompatible function types.\n\n Returns: %FALSE if the source should be removed. %G_SOURCE_CONTINUE and\n %G_SOURCE_REMOVE are more memorable names for the return value."]
pub type GSourceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer) -> gboolean>;
#[doc = " GChildWatchFunc:\n @pid: the process id of the child process\n @wait_status: Status information about the child process, encoded\n               in a platform-specific manner\n @user_data: user data passed to g_child_watch_add()\n\n Prototype of a #GChildWatchSource callback, called when a child\n process has exited.\n\n To interpret @wait_status, see the documentation\n for g_spawn_check_wait_status(). In particular,\n on Unix platforms, note that it is usually not equal\n to the integer passed to `exit()` or returned from `main()`."]
pub type GChildWatchFunc =
    ::std::option::Option<unsafe extern "C" fn(pid: GPid, wait_status: gint, user_data: gpointer)>;
#[doc = " GSourceDisposeFunc:\n @source: #GSource that is currently being disposed\n\n Dispose function for @source. See g_source_set_dispose_function() for\n details.\n\n Since: 2.64"]
pub type GSourceDisposeFunc = ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut ::std::os::raw::c_char,
    pub priv_: *mut GSourcePrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSource"][::std::mem::size_of::<_GSource>() - 96usize];
    ["Alignment of _GSource"][::std::mem::align_of::<_GSource>() - 8usize];
    ["Offset of field: _GSource::callback_data"]
        [::std::mem::offset_of!(_GSource, callback_data) - 0usize];
    ["Offset of field: _GSource::callback_funcs"]
        [::std::mem::offset_of!(_GSource, callback_funcs) - 8usize];
    ["Offset of field: _GSource::source_funcs"]
        [::std::mem::offset_of!(_GSource, source_funcs) - 16usize];
    ["Offset of field: _GSource::ref_count"][::std::mem::offset_of!(_GSource, ref_count) - 24usize];
    ["Offset of field: _GSource::context"][::std::mem::offset_of!(_GSource, context) - 32usize];
    ["Offset of field: _GSource::priority"][::std::mem::offset_of!(_GSource, priority) - 40usize];
    ["Offset of field: _GSource::flags"][::std::mem::offset_of!(_GSource, flags) - 44usize];
    ["Offset of field: _GSource::source_id"][::std::mem::offset_of!(_GSource, source_id) - 48usize];
    ["Offset of field: _GSource::poll_fds"][::std::mem::offset_of!(_GSource, poll_fds) - 56usize];
    ["Offset of field: _GSource::prev"][::std::mem::offset_of!(_GSource, prev) - 64usize];
    ["Offset of field: _GSource::next"][::std::mem::offset_of!(_GSource, next) - 72usize];
    ["Offset of field: _GSource::name"][::std::mem::offset_of!(_GSource, name) - 80usize];
    ["Offset of field: _GSource::priv_"][::std::mem::offset_of!(_GSource, priv_) - 88usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceCallbackFuncs {
    pub ref_: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub unref: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            cb_data: gpointer,
            source: *mut GSource,
            func: *mut GSourceFunc,
            data: *mut gpointer,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSourceCallbackFuncs"][::std::mem::size_of::<_GSourceCallbackFuncs>() - 24usize];
    ["Alignment of _GSourceCallbackFuncs"]
        [::std::mem::align_of::<_GSourceCallbackFuncs>() - 8usize];
    ["Offset of field: _GSourceCallbackFuncs::ref_"]
        [::std::mem::offset_of!(_GSourceCallbackFuncs, ref_) - 0usize];
    ["Offset of field: _GSourceCallbackFuncs::unref"]
        [::std::mem::offset_of!(_GSourceCallbackFuncs, unref) - 8usize];
    ["Offset of field: _GSourceCallbackFuncs::get"]
        [::std::mem::offset_of!(_GSourceCallbackFuncs, get) - 16usize];
};
#[doc = " GSourceDummyMarshal:\n\n This is just a placeholder for #GClosureMarshal,\n which cannot be used here for dependency reasons."]
pub type GSourceDummyMarshal = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceFuncs {
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(source: *mut GSource, timeout_: *mut gint) -> gboolean,
    >,
    pub check: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource) -> gboolean>,
    pub dispatch: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GSource,
            callback: GSourceFunc,
            user_data: gpointer,
        ) -> gboolean,
    >,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSourceFuncs"][::std::mem::size_of::<_GSourceFuncs>() - 48usize];
    ["Alignment of _GSourceFuncs"][::std::mem::align_of::<_GSourceFuncs>() - 8usize];
    ["Offset of field: _GSourceFuncs::prepare"]
        [::std::mem::offset_of!(_GSourceFuncs, prepare) - 0usize];
    ["Offset of field: _GSourceFuncs::check"]
        [::std::mem::offset_of!(_GSourceFuncs, check) - 8usize];
    ["Offset of field: _GSourceFuncs::dispatch"]
        [::std::mem::offset_of!(_GSourceFuncs, dispatch) - 16usize];
    ["Offset of field: _GSourceFuncs::finalize"]
        [::std::mem::offset_of!(_GSourceFuncs, finalize) - 24usize];
    ["Offset of field: _GSourceFuncs::closure_callback"]
        [::std::mem::offset_of!(_GSourceFuncs, closure_callback) - 32usize];
    ["Offset of field: _GSourceFuncs::closure_marshal"]
        [::std::mem::offset_of!(_GSourceFuncs, closure_marshal) - 40usize];
};
unsafe extern "C" {
    pub fn g_main_context_new() -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_new_with_flags(flags: GMainContextFlags) -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_unref(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_default() -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_find_source_by_id(
        context: *mut GMainContext,
        source_id: guint,
    ) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_main_context_find_source_by_user_data(
        context: *mut GMainContext,
        user_data: gpointer,
    ) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_main_context_find_source_by_funcs_user_data(
        context: *mut GMainContext,
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_main_context_wakeup(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_release(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_wait(
        context: *mut GMainContext,
        cond: *mut GCond,
        mutex: *mut GMutex,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_query(
        context: *mut GMainContext,
        max_priority: gint,
        timeout_: *mut gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_main_context_check(
        context: *mut GMainContext,
        max_priority: gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_dispatch(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
}
unsafe extern "C" {
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
}
unsafe extern "C" {
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: gint);
}
unsafe extern "C" {
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
}
unsafe extern "C" {
    pub fn g_main_depth() -> gint;
}
unsafe extern "C" {
    pub fn g_main_current_source() -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
}
#[doc = " GMainContextPusher:\n\n Opaque type. See g_main_context_pusher_new() for details.\n\n Since: 2.64"]
pub type GMainContextPusher = ::std::os::raw::c_void;
unsafe extern "C" {
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
}
unsafe extern "C" {
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
}
unsafe extern "C" {
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
}
unsafe extern "C" {
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
}
unsafe extern "C" {
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);
}
unsafe extern "C" {
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_source_set_dispose_function(source: *mut GSource, dispose: GSourceDisposeFunc);
}
unsafe extern "C" {
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_source_unref(source: *mut GSource);
}
unsafe extern "C" {
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> guint;
}
unsafe extern "C" {
    pub fn g_source_destroy(source: *mut GSource);
}
unsafe extern "C" {
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
}
unsafe extern "C" {
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
}
unsafe extern "C" {
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
}
unsafe extern "C" {
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
}
unsafe extern "C" {
    pub fn g_source_get_id(source: *mut GSource) -> guint;
}
unsafe extern "C" {
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_source_set_callback(
        source: *mut GSource,
        func: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
}
unsafe extern "C" {
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
}
unsafe extern "C" {
    pub fn g_source_set_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_source_set_static_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_source_get_name(source: *mut GSource) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_source_set_name_by_id(tag: guint, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
}
unsafe extern "C" {
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
}
unsafe extern "C" {
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: gint, events: GIOCondition) -> gpointer;
}
unsafe extern "C" {
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
}
unsafe extern "C" {
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
}
unsafe extern "C" {
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
}
unsafe extern "C" {
    pub fn g_source_set_callback_indirect(
        source: *mut GSource,
        callback_data: gpointer,
        callback_funcs: *mut GSourceCallbackFuncs,
    );
}
unsafe extern "C" {
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
}
unsafe extern "C" {
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
}
unsafe extern "C" {
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
}
unsafe extern "C" {
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
}
unsafe extern "C" {
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
}
unsafe extern "C" {
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
}
unsafe extern "C" {
    pub fn g_idle_source_new() -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_get_current_time(result: *mut GTimeVal);
}
unsafe extern "C" {
    pub fn g_get_monotonic_time() -> gint64;
}
unsafe extern "C" {
    pub fn g_get_real_time() -> gint64;
}
unsafe extern "C" {
    pub fn g_source_remove(tag: guint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_source_remove_by_funcs_user_data(
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> gboolean;
}
#[doc = " GClearHandleFunc:\n @handle_id: the handle ID to clear\n\n Specifies the type of function passed to g_clear_handle_id().\n The implementation is expected to free the resource identified\n by @handle_id; for instance, if @handle_id is a #GSource ID,\n g_source_remove() can be used.\n\n Since: 2.56"]
pub type GClearHandleFunc = ::std::option::Option<unsafe extern "C" fn(handle_id: guint)>;
unsafe extern "C" {
    pub fn g_clear_handle_id(tag_ptr: *mut guint, clear_func: GClearHandleFunc);
}
unsafe extern "C" {
    pub fn g_timeout_add_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_timeout_add_seconds_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_child_watch_add_full(
        priority: gint,
        pid: GPid,
        function: GChildWatchFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_idle_add_full(
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_invoke_full(
        context: *mut GMainContext,
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
}
unsafe extern "C" {
    pub static mut g_timeout_funcs: GSourceFuncs;
}
unsafe extern "C" {
    pub static mut g_child_watch_funcs: GSourceFuncs;
}
unsafe extern "C" {
    pub static mut g_idle_funcs: GSourceFuncs;
}
unsafe extern "C" {
    pub static mut g_unix_signal_funcs: GSourceFuncs;
}
unsafe extern "C" {
    pub static mut g_unix_fd_source_funcs: GSourceFuncs;
}
#[doc = " gunichar:\n\n A type which can hold any UTF-32 or UCS-4 character code,\n also known as a Unicode code point.\n\n If you want to produce the UTF-8 representation of a #gunichar,\n use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse\n process.\n\n To print/scan values of this type as integer, use\n %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT.\n\n The notation to express a Unicode code point in running text is\n as a hexadecimal number with four to six digits and uppercase\n letters, prefixed by the string \"U+\". Leading zeros are omitted,\n unless the code point would have fewer than four hexadecimal digits.\n For example, \"U+0041 LATIN CAPITAL LETTER A\". To print a code point\n in the U+-notation, use the format string \"U+\\%04\"G_GINT32_FORMAT\"X\".\n To scan, use the format string \"U+\\%06\"G_GINT32_FORMAT\"X\".\n\n |[\n gunichar c;\n sscanf (\"U+0041\", \"U+%06\"G_GINT32_FORMAT\"X\", &amp;c)\n g_print (\"Read U+%04\"G_GINT32_FORMAT\"X\", c);\n ]|"]
pub type gunichar = guint32;
#[doc = " gunichar2:\n\n A type which can hold any UTF-16 code\n point<footnote id=\"utf16_surrogate_pairs\">UTF-16 also has so called\n <firstterm>surrogate pairs</firstterm> to encode characters beyond\n the BMP as pairs of 16bit numbers. Surrogate pairs cannot be stored\n in a single gunichar2 field, but all GLib functions accepting gunichar2\n arrays will correctly interpret surrogate pairs.</footnote>.\n\n To print/scan values of this type to/from text you need to convert\n to/from UTF-8, using g_utf16_to_utf8()/g_utf8_to_utf16().\n\n To print/scan values of this type as integer, use\n %G_GINT16_MODIFIER and/or %G_GUINT16_FORMAT."]
pub type gunichar2 = guint16;
pub const G_UNICODE_CONTROL: GUnicodeType = 0;
pub const G_UNICODE_FORMAT: GUnicodeType = 1;
pub const G_UNICODE_UNASSIGNED: GUnicodeType = 2;
pub const G_UNICODE_PRIVATE_USE: GUnicodeType = 3;
pub const G_UNICODE_SURROGATE: GUnicodeType = 4;
pub const G_UNICODE_LOWERCASE_LETTER: GUnicodeType = 5;
pub const G_UNICODE_MODIFIER_LETTER: GUnicodeType = 6;
pub const G_UNICODE_OTHER_LETTER: GUnicodeType = 7;
pub const G_UNICODE_TITLECASE_LETTER: GUnicodeType = 8;
pub const G_UNICODE_UPPERCASE_LETTER: GUnicodeType = 9;
pub const G_UNICODE_SPACING_MARK: GUnicodeType = 10;
pub const G_UNICODE_ENCLOSING_MARK: GUnicodeType = 11;
pub const G_UNICODE_NON_SPACING_MARK: GUnicodeType = 12;
pub const G_UNICODE_DECIMAL_NUMBER: GUnicodeType = 13;
pub const G_UNICODE_LETTER_NUMBER: GUnicodeType = 14;
pub const G_UNICODE_OTHER_NUMBER: GUnicodeType = 15;
pub const G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = 16;
pub const G_UNICODE_DASH_PUNCTUATION: GUnicodeType = 17;
pub const G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = 18;
pub const G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = 19;
pub const G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = 20;
pub const G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = 21;
pub const G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = 22;
pub const G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = 23;
pub const G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = 24;
pub const G_UNICODE_MATH_SYMBOL: GUnicodeType = 25;
pub const G_UNICODE_OTHER_SYMBOL: GUnicodeType = 26;
pub const G_UNICODE_LINE_SEPARATOR: GUnicodeType = 27;
pub const G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = 28;
pub const G_UNICODE_SPACE_SEPARATOR: GUnicodeType = 29;
#[doc = " GUnicodeType:\n @G_UNICODE_CONTROL: General category \"Other, Control\" (Cc)\n @G_UNICODE_FORMAT: General category \"Other, Format\" (Cf)\n @G_UNICODE_UNASSIGNED: General category \"Other, Not Assigned\" (Cn)\n @G_UNICODE_PRIVATE_USE: General category \"Other, Private Use\" (Co)\n @G_UNICODE_SURROGATE: General category \"Other, Surrogate\" (Cs)\n @G_UNICODE_LOWERCASE_LETTER: General category \"Letter, Lowercase\" (Ll)\n @G_UNICODE_MODIFIER_LETTER: General category \"Letter, Modifier\" (Lm)\n @G_UNICODE_OTHER_LETTER: General category \"Letter, Other\" (Lo)\n @G_UNICODE_TITLECASE_LETTER: General category \"Letter, Titlecase\" (Lt)\n @G_UNICODE_UPPERCASE_LETTER: General category \"Letter, Uppercase\" (Lu)\n @G_UNICODE_SPACING_MARK: General category \"Mark, Spacing\" (Mc)\n @G_UNICODE_ENCLOSING_MARK: General category \"Mark, Enclosing\" (Me)\n @G_UNICODE_NON_SPACING_MARK: General category \"Mark, Nonspacing\" (Mn)\n @G_UNICODE_DECIMAL_NUMBER: General category \"Number, Decimal Digit\" (Nd)\n @G_UNICODE_LETTER_NUMBER: General category \"Number, Letter\" (Nl)\n @G_UNICODE_OTHER_NUMBER: General category \"Number, Other\" (No)\n @G_UNICODE_CONNECT_PUNCTUATION: General category \"Punctuation, Connector\" (Pc)\n @G_UNICODE_DASH_PUNCTUATION: General category \"Punctuation, Dash\" (Pd)\n @G_UNICODE_CLOSE_PUNCTUATION: General category \"Punctuation, Close\" (Pe)\n @G_UNICODE_FINAL_PUNCTUATION: General category \"Punctuation, Final quote\" (Pf)\n @G_UNICODE_INITIAL_PUNCTUATION: General category \"Punctuation, Initial quote\" (Pi)\n @G_UNICODE_OTHER_PUNCTUATION: General category \"Punctuation, Other\" (Po)\n @G_UNICODE_OPEN_PUNCTUATION: General category \"Punctuation, Open\" (Ps)\n @G_UNICODE_CURRENCY_SYMBOL: General category \"Symbol, Currency\" (Sc)\n @G_UNICODE_MODIFIER_SYMBOL: General category \"Symbol, Modifier\" (Sk)\n @G_UNICODE_MATH_SYMBOL: General category \"Symbol, Math\" (Sm)\n @G_UNICODE_OTHER_SYMBOL: General category \"Symbol, Other\" (So)\n @G_UNICODE_LINE_SEPARATOR: General category \"Separator, Line\" (Zl)\n @G_UNICODE_PARAGRAPH_SEPARATOR: General category \"Separator, Paragraph\" (Zp)\n @G_UNICODE_SPACE_SEPARATOR: General category \"Separator, Space\" (Zs)\n\n These are the possible character classifications from the\n Unicode specification.\n See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values)."]
pub type GUnicodeType = ::std::os::raw::c_uint;
pub const G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = 0;
pub const G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = 1;
pub const G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = 2;
pub const G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = 3;
pub const G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = 4;
pub const G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = 5;
pub const G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = 6;
pub const G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = 7;
pub const G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = 8;
pub const G_UNICODE_BREAK_SPACE: GUnicodeBreakType = 9;
pub const G_UNICODE_BREAK_AFTER: GUnicodeBreakType = 10;
pub const G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = 11;
pub const G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = 12;
pub const G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = 13;
pub const G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = 14;
pub const G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = 15;
pub const G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = 16;
pub const G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = 17;
pub const G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = 18;
pub const G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = 19;
pub const G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = 20;
pub const G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = 21;
pub const G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = 22;
pub const G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = 23;
pub const G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = 24;
pub const G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = 25;
pub const G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = 26;
pub const G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = 27;
pub const G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = 28;
pub const G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = 29;
pub const G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = 30;
pub const G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = 31;
pub const G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = 32;
pub const G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = 33;
pub const G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = 34;
pub const G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = 35;
pub const G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = 36;
pub const G_UNICODE_BREAK_CLOSE_PARENTHESIS: GUnicodeBreakType = 36;
pub const G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = 37;
pub const G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = 38;
pub const G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = 39;
pub const G_UNICODE_BREAK_EMOJI_BASE: GUnicodeBreakType = 40;
pub const G_UNICODE_BREAK_EMOJI_MODIFIER: GUnicodeBreakType = 41;
pub const G_UNICODE_BREAK_ZERO_WIDTH_JOINER: GUnicodeBreakType = 42;
#[doc = " GUnicodeBreakType:\n @G_UNICODE_BREAK_MANDATORY: Mandatory Break (BK)\n @G_UNICODE_BREAK_CARRIAGE_RETURN: Carriage Return (CR)\n @G_UNICODE_BREAK_LINE_FEED: Line Feed (LF)\n @G_UNICODE_BREAK_COMBINING_MARK: Attached Characters and Combining Marks (CM)\n @G_UNICODE_BREAK_SURROGATE: Surrogates (SG)\n @G_UNICODE_BREAK_ZERO_WIDTH_SPACE: Zero Width Space (ZW)\n @G_UNICODE_BREAK_INSEPARABLE: Inseparable (IN)\n @G_UNICODE_BREAK_NON_BREAKING_GLUE: Non-breaking (\"Glue\") (GL)\n @G_UNICODE_BREAK_CONTINGENT: Contingent Break Opportunity (CB)\n @G_UNICODE_BREAK_SPACE: Space (SP)\n @G_UNICODE_BREAK_AFTER: Break Opportunity After (BA)\n @G_UNICODE_BREAK_BEFORE: Break Opportunity Before (BB)\n @G_UNICODE_BREAK_BEFORE_AND_AFTER: Break Opportunity Before and After (B2)\n @G_UNICODE_BREAK_HYPHEN: Hyphen (HY)\n @G_UNICODE_BREAK_NON_STARTER: Nonstarter (NS)\n @G_UNICODE_BREAK_OPEN_PUNCTUATION: Opening Punctuation (OP)\n @G_UNICODE_BREAK_CLOSE_PUNCTUATION: Closing Punctuation (CL)\n @G_UNICODE_BREAK_QUOTATION: Ambiguous Quotation (QU)\n @G_UNICODE_BREAK_EXCLAMATION: Exclamation/Interrogation (EX)\n @G_UNICODE_BREAK_IDEOGRAPHIC: Ideographic (ID)\n @G_UNICODE_BREAK_NUMERIC: Numeric (NU)\n @G_UNICODE_BREAK_INFIX_SEPARATOR: Infix Separator (Numeric) (IS)\n @G_UNICODE_BREAK_SYMBOL: Symbols Allowing Break After (SY)\n @G_UNICODE_BREAK_ALPHABETIC: Ordinary Alphabetic and Symbol Characters (AL)\n @G_UNICODE_BREAK_PREFIX: Prefix (Numeric) (PR)\n @G_UNICODE_BREAK_POSTFIX: Postfix (Numeric) (PO)\n @G_UNICODE_BREAK_COMPLEX_CONTEXT: Complex Content Dependent (South East Asian) (SA)\n @G_UNICODE_BREAK_AMBIGUOUS: Ambiguous (Alphabetic or Ideographic) (AI)\n @G_UNICODE_BREAK_UNKNOWN: Unknown (XX)\n @G_UNICODE_BREAK_NEXT_LINE: Next Line (NL)\n @G_UNICODE_BREAK_WORD_JOINER: Word Joiner (WJ)\n @G_UNICODE_BREAK_HANGUL_L_JAMO: Hangul L Jamo (JL)\n @G_UNICODE_BREAK_HANGUL_V_JAMO: Hangul V Jamo (JV)\n @G_UNICODE_BREAK_HANGUL_T_JAMO: Hangul T Jamo (JT)\n @G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: Hangul LV Syllable (H2)\n @G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: Hangul LVT Syllable (H3)\n @G_UNICODE_BREAK_CLOSE_PARANTHESIS: Closing Parenthesis (CP). Since 2.28. Deprecated: 2.70: Use %G_UNICODE_BREAK_CLOSE_PARENTHESIS instead.\n @G_UNICODE_BREAK_CLOSE_PARENTHESIS: Closing Parenthesis (CP). Since 2.70\n @G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: Conditional Japanese Starter (CJ). Since: 2.32\n @G_UNICODE_BREAK_HEBREW_LETTER: Hebrew Letter (HL). Since: 2.32\n @G_UNICODE_BREAK_REGIONAL_INDICATOR: Regional Indicator (RI). Since: 2.36\n @G_UNICODE_BREAK_EMOJI_BASE: Emoji Base (EB). Since: 2.50\n @G_UNICODE_BREAK_EMOJI_MODIFIER: Emoji Modifier (EM). Since: 2.50\n @G_UNICODE_BREAK_ZERO_WIDTH_JOINER: Zero Width Joiner (ZWJ). Since: 2.50\n\n These are the possible line break classifications.\n\n Since new unicode versions may add new types here, applications should be ready\n to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN.\n\n See [Unicode Line Breaking Algorithm](http://www.unicode.org/unicode/reports/tr14/)."]
pub type GUnicodeBreakType = ::std::os::raw::c_uint;
pub const G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub const G_UNICODE_SCRIPT_ADLAM: GUnicodeScript = 132;
pub const G_UNICODE_SCRIPT_BHAIKSUKI: GUnicodeScript = 133;
pub const G_UNICODE_SCRIPT_MARCHEN: GUnicodeScript = 134;
pub const G_UNICODE_SCRIPT_NEWA: GUnicodeScript = 135;
pub const G_UNICODE_SCRIPT_OSAGE: GUnicodeScript = 136;
pub const G_UNICODE_SCRIPT_TANGUT: GUnicodeScript = 137;
pub const G_UNICODE_SCRIPT_MASARAM_GONDI: GUnicodeScript = 138;
pub const G_UNICODE_SCRIPT_NUSHU: GUnicodeScript = 139;
pub const G_UNICODE_SCRIPT_SOYOMBO: GUnicodeScript = 140;
pub const G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: GUnicodeScript = 141;
pub const G_UNICODE_SCRIPT_DOGRA: GUnicodeScript = 142;
pub const G_UNICODE_SCRIPT_GUNJALA_GONDI: GUnicodeScript = 143;
pub const G_UNICODE_SCRIPT_HANIFI_ROHINGYA: GUnicodeScript = 144;
pub const G_UNICODE_SCRIPT_MAKASAR: GUnicodeScript = 145;
pub const G_UNICODE_SCRIPT_MEDEFAIDRIN: GUnicodeScript = 146;
pub const G_UNICODE_SCRIPT_OLD_SOGDIAN: GUnicodeScript = 147;
pub const G_UNICODE_SCRIPT_SOGDIAN: GUnicodeScript = 148;
pub const G_UNICODE_SCRIPT_ELYMAIC: GUnicodeScript = 149;
pub const G_UNICODE_SCRIPT_NANDINAGARI: GUnicodeScript = 150;
pub const G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: GUnicodeScript = 151;
pub const G_UNICODE_SCRIPT_WANCHO: GUnicodeScript = 152;
pub const G_UNICODE_SCRIPT_CHORASMIAN: GUnicodeScript = 153;
pub const G_UNICODE_SCRIPT_DIVES_AKURU: GUnicodeScript = 154;
pub const G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT: GUnicodeScript = 155;
pub const G_UNICODE_SCRIPT_YEZIDI: GUnicodeScript = 156;
pub const G_UNICODE_SCRIPT_CYPRO_MINOAN: GUnicodeScript = 157;
pub const G_UNICODE_SCRIPT_OLD_UYGHUR: GUnicodeScript = 158;
pub const G_UNICODE_SCRIPT_TANGSA: GUnicodeScript = 159;
pub const G_UNICODE_SCRIPT_TOTO: GUnicodeScript = 160;
pub const G_UNICODE_SCRIPT_VITHKUQI: GUnicodeScript = 161;
pub const G_UNICODE_SCRIPT_MATH: GUnicodeScript = 162;
#[doc = " GUnicodeScript:\n @G_UNICODE_SCRIPT_INVALID_CODE:\n                               a value never returned from g_unichar_get_script()\n @G_UNICODE_SCRIPT_COMMON:     a character used by multiple different scripts\n @G_UNICODE_SCRIPT_INHERITED:  a mark glyph that takes its script from the\n                               base glyph to which it is attached\n @G_UNICODE_SCRIPT_ARABIC:     Arabic\n @G_UNICODE_SCRIPT_ARMENIAN:   Armenian\n @G_UNICODE_SCRIPT_BENGALI:    Bengali\n @G_UNICODE_SCRIPT_BOPOMOFO:   Bopomofo\n @G_UNICODE_SCRIPT_CHEROKEE:   Cherokee\n @G_UNICODE_SCRIPT_COPTIC:     Coptic\n @G_UNICODE_SCRIPT_CYRILLIC:   Cyrillic\n @G_UNICODE_SCRIPT_DESERET:    Deseret\n @G_UNICODE_SCRIPT_DEVANAGARI: Devanagari\n @G_UNICODE_SCRIPT_ETHIOPIC:   Ethiopic\n @G_UNICODE_SCRIPT_GEORGIAN:   Georgian\n @G_UNICODE_SCRIPT_GOTHIC:     Gothic\n @G_UNICODE_SCRIPT_GREEK:      Greek\n @G_UNICODE_SCRIPT_GUJARATI:   Gujarati\n @G_UNICODE_SCRIPT_GURMUKHI:   Gurmukhi\n @G_UNICODE_SCRIPT_HAN:        Han\n @G_UNICODE_SCRIPT_HANGUL:     Hangul\n @G_UNICODE_SCRIPT_HEBREW:     Hebrew\n @G_UNICODE_SCRIPT_HIRAGANA:   Hiragana\n @G_UNICODE_SCRIPT_KANNADA:    Kannada\n @G_UNICODE_SCRIPT_KATAKANA:   Katakana\n @G_UNICODE_SCRIPT_KHMER:      Khmer\n @G_UNICODE_SCRIPT_LAO:        Lao\n @G_UNICODE_SCRIPT_LATIN:      Latin\n @G_UNICODE_SCRIPT_MALAYALAM:  Malayalam\n @G_UNICODE_SCRIPT_MONGOLIAN:  Mongolian\n @G_UNICODE_SCRIPT_MYANMAR:    Myanmar\n @G_UNICODE_SCRIPT_OGHAM:      Ogham\n @G_UNICODE_SCRIPT_OLD_ITALIC: Old Italic\n @G_UNICODE_SCRIPT_ORIYA:      Oriya\n @G_UNICODE_SCRIPT_RUNIC:      Runic\n @G_UNICODE_SCRIPT_SINHALA:    Sinhala\n @G_UNICODE_SCRIPT_SYRIAC:     Syriac\n @G_UNICODE_SCRIPT_TAMIL:      Tamil\n @G_UNICODE_SCRIPT_TELUGU:     Telugu\n @G_UNICODE_SCRIPT_THAANA:     Thaana\n @G_UNICODE_SCRIPT_THAI:       Thai\n @G_UNICODE_SCRIPT_TIBETAN:    Tibetan\n @G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL:\n                               Canadian Aboriginal\n @G_UNICODE_SCRIPT_YI:         Yi\n @G_UNICODE_SCRIPT_TAGALOG:    Tagalog\n @G_UNICODE_SCRIPT_HANUNOO:    Hanunoo\n @G_UNICODE_SCRIPT_BUHID:      Buhid\n @G_UNICODE_SCRIPT_TAGBANWA:   Tagbanwa\n @G_UNICODE_SCRIPT_BRAILLE:    Braille\n @G_UNICODE_SCRIPT_CYPRIOT:    Cypriot\n @G_UNICODE_SCRIPT_LIMBU:      Limbu\n @G_UNICODE_SCRIPT_OSMANYA:    Osmanya\n @G_UNICODE_SCRIPT_SHAVIAN:    Shavian\n @G_UNICODE_SCRIPT_LINEAR_B:   Linear B\n @G_UNICODE_SCRIPT_TAI_LE:     Tai Le\n @G_UNICODE_SCRIPT_UGARITIC:   Ugaritic\n @G_UNICODE_SCRIPT_NEW_TAI_LUE:\n                               New Tai Lue\n @G_UNICODE_SCRIPT_BUGINESE:   Buginese\n @G_UNICODE_SCRIPT_GLAGOLITIC: Glagolitic\n @G_UNICODE_SCRIPT_TIFINAGH:   Tifinagh\n @G_UNICODE_SCRIPT_SYLOTI_NAGRI:\n                               Syloti Nagri\n @G_UNICODE_SCRIPT_OLD_PERSIAN:\n                               Old Persian\n @G_UNICODE_SCRIPT_KHAROSHTHI: Kharoshthi\n @G_UNICODE_SCRIPT_UNKNOWN:    an unassigned code point\n @G_UNICODE_SCRIPT_BALINESE:   Balinese\n @G_UNICODE_SCRIPT_CUNEIFORM:  Cuneiform\n @G_UNICODE_SCRIPT_PHOENICIAN: Phoenician\n @G_UNICODE_SCRIPT_PHAGS_PA:   Phags-pa\n @G_UNICODE_SCRIPT_NKO:        N'Ko\n @G_UNICODE_SCRIPT_KAYAH_LI:   Kayah Li. Since 2.16.3\n @G_UNICODE_SCRIPT_LEPCHA:     Lepcha. Since 2.16.3\n @G_UNICODE_SCRIPT_REJANG:     Rejang. Since 2.16.3\n @G_UNICODE_SCRIPT_SUNDANESE:  Sundanese. Since 2.16.3\n @G_UNICODE_SCRIPT_SAURASHTRA: Saurashtra. Since 2.16.3\n @G_UNICODE_SCRIPT_CHAM:       Cham. Since 2.16.3\n @G_UNICODE_SCRIPT_OL_CHIKI:   Ol Chiki. Since 2.16.3\n @G_UNICODE_SCRIPT_VAI:        Vai. Since 2.16.3\n @G_UNICODE_SCRIPT_CARIAN:     Carian. Since 2.16.3\n @G_UNICODE_SCRIPT_LYCIAN:     Lycian. Since 2.16.3\n @G_UNICODE_SCRIPT_LYDIAN:     Lydian. Since 2.16.3\n @G_UNICODE_SCRIPT_AVESTAN:    Avestan. Since 2.26\n @G_UNICODE_SCRIPT_BAMUM:      Bamum. Since 2.26\n @G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS:\n                               Egyptian Hieroglpyhs. Since 2.26\n @G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC:\n                               Imperial Aramaic. Since 2.26\n @G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI:\n                               Inscriptional Pahlavi. Since 2.26\n @G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN:\n                               Inscriptional Parthian. Since 2.26\n @G_UNICODE_SCRIPT_JAVANESE:   Javanese. Since 2.26\n @G_UNICODE_SCRIPT_KAITHI:     Kaithi. Since 2.26\n @G_UNICODE_SCRIPT_LISU:       Lisu. Since 2.26\n @G_UNICODE_SCRIPT_MEETEI_MAYEK:\n                               Meetei Mayek. Since 2.26\n @G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN:\n                               Old South Arabian. Since 2.26\n @G_UNICODE_SCRIPT_OLD_TURKIC: Old Turkic. Since 2.28\n @G_UNICODE_SCRIPT_SAMARITAN:  Samaritan. Since 2.26\n @G_UNICODE_SCRIPT_TAI_THAM:   Tai Tham. Since 2.26\n @G_UNICODE_SCRIPT_TAI_VIET:   Tai Viet. Since 2.26\n @G_UNICODE_SCRIPT_BATAK:      Batak. Since 2.28\n @G_UNICODE_SCRIPT_BRAHMI:     Brahmi. Since 2.28\n @G_UNICODE_SCRIPT_MANDAIC:    Mandaic. Since 2.28\n @G_UNICODE_SCRIPT_CHAKMA:               Chakma. Since: 2.32\n @G_UNICODE_SCRIPT_MEROITIC_CURSIVE:     Meroitic Cursive. Since: 2.32\n @G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32\n @G_UNICODE_SCRIPT_MIAO:                 Miao. Since: 2.32\n @G_UNICODE_SCRIPT_SHARADA:              Sharada. Since: 2.32\n @G_UNICODE_SCRIPT_SORA_SOMPENG:         Sora Sompeng. Since: 2.32\n @G_UNICODE_SCRIPT_TAKRI:                Takri. Since: 2.32\n @G_UNICODE_SCRIPT_BASSA_VAH:            Bassa. Since: 2.42\n @G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN:   Caucasian Albanian. Since: 2.42\n @G_UNICODE_SCRIPT_DUPLOYAN:             Duployan. Since: 2.42\n @G_UNICODE_SCRIPT_ELBASAN:              Elbasan. Since: 2.42\n @G_UNICODE_SCRIPT_GRANTHA:              Grantha. Since: 2.42\n @G_UNICODE_SCRIPT_KHOJKI:               Kjohki. Since: 2.42\n @G_UNICODE_SCRIPT_KHUDAWADI:            Khudawadi, Sindhi. Since: 2.42\n @G_UNICODE_SCRIPT_LINEAR_A:             Linear A. Since: 2.42\n @G_UNICODE_SCRIPT_MAHAJANI:             Mahajani. Since: 2.42\n @G_UNICODE_SCRIPT_MANICHAEAN:           Manichaean. Since: 2.42\n @G_UNICODE_SCRIPT_MENDE_KIKAKUI:        Mende Kikakui. Since: 2.42\n @G_UNICODE_SCRIPT_MODI:                 Modi. Since: 2.42\n @G_UNICODE_SCRIPT_MRO:                  Mro. Since: 2.42\n @G_UNICODE_SCRIPT_NABATAEAN:            Nabataean. Since: 2.42\n @G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN:    Old North Arabian. Since: 2.42\n @G_UNICODE_SCRIPT_OLD_PERMIC:           Old Permic. Since: 2.42\n @G_UNICODE_SCRIPT_PAHAWH_HMONG:         Pahawh Hmong. Since: 2.42\n @G_UNICODE_SCRIPT_PALMYRENE:            Palmyrene. Since: 2.42\n @G_UNICODE_SCRIPT_PAU_CIN_HAU:          Pau Cin Hau. Since: 2.42\n @G_UNICODE_SCRIPT_PSALTER_PAHLAVI:      Psalter Pahlavi. Since: 2.42\n @G_UNICODE_SCRIPT_SIDDHAM:              Siddham. Since: 2.42\n @G_UNICODE_SCRIPT_TIRHUTA:              Tirhuta. Since: 2.42\n @G_UNICODE_SCRIPT_WARANG_CITI:          Warang Citi. Since: 2.42\n @G_UNICODE_SCRIPT_AHOM:                 Ahom. Since: 2.48\n @G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48\n @G_UNICODE_SCRIPT_HATRAN:               Hatran. Since: 2.48\n @G_UNICODE_SCRIPT_MULTANI:              Multani. Since: 2.48\n @G_UNICODE_SCRIPT_OLD_HUNGARIAN:        Old Hungarian. Since: 2.48\n @G_UNICODE_SCRIPT_SIGNWRITING:          Signwriting. Since: 2.48\n @G_UNICODE_SCRIPT_ADLAM:                Adlam. Since: 2.50\n @G_UNICODE_SCRIPT_BHAIKSUKI:            Bhaiksuki. Since: 2.50\n @G_UNICODE_SCRIPT_MARCHEN:              Marchen. Since: 2.50\n @G_UNICODE_SCRIPT_NEWA:                 Newa. Since: 2.50\n @G_UNICODE_SCRIPT_OSAGE:                Osage. Since: 2.50\n @G_UNICODE_SCRIPT_TANGUT:               Tangut. Since: 2.50\n @G_UNICODE_SCRIPT_MASARAM_GONDI:        Masaram Gondi. Since: 2.54\n @G_UNICODE_SCRIPT_NUSHU:                Nushu. Since: 2.54\n @G_UNICODE_SCRIPT_SOYOMBO:              Soyombo. Since: 2.54\n @G_UNICODE_SCRIPT_ZANABAZAR_SQUARE:     Zanabazar Square. Since: 2.54\n @G_UNICODE_SCRIPT_DOGRA:                Dogra. Since: 2.58\n @G_UNICODE_SCRIPT_GUNJALA_GONDI:        Gunjala Gondi. Since: 2.58\n @G_UNICODE_SCRIPT_HANIFI_ROHINGYA:      Hanifi Rohingya. Since: 2.58\n @G_UNICODE_SCRIPT_MAKASAR:              Makasar. Since: 2.58\n @G_UNICODE_SCRIPT_MEDEFAIDRIN:          Medefaidrin. Since: 2.58\n @G_UNICODE_SCRIPT_OLD_SOGDIAN:          Old Sogdian. Since: 2.58\n @G_UNICODE_SCRIPT_SOGDIAN:              Sogdian. Since: 2.58\n @G_UNICODE_SCRIPT_ELYMAIC:              Elym. Since: 2.62\n @G_UNICODE_SCRIPT_NANDINAGARI:          Nand. Since: 2.62\n @G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: Rohg. Since: 2.62\n @G_UNICODE_SCRIPT_WANCHO:               Wcho. Since: 2.62\n @G_UNICODE_SCRIPT_CHORASMIAN:           Chorasmian. Since: 2.66\n @G_UNICODE_SCRIPT_DIVES_AKURU:          Dives Akuru. Since: 2.66\n @G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT:  Khitan small script. Since: 2.66\n @G_UNICODE_SCRIPT_YEZIDI:               Yezidi. Since: 2.66\n @G_UNICODE_SCRIPT_CYPRO_MINOAN:         Cypro-Minoan. Since: 2.72\n @G_UNICODE_SCRIPT_OLD_UYGHUR:           Old Uyghur. Since: 2.72\n @G_UNICODE_SCRIPT_TANGSA:               Tangsa. Since: 2.72\n @G_UNICODE_SCRIPT_TOTO:                 Toto. Since: 2.72\n @G_UNICODE_SCRIPT_VITHKUQI:             Vithkuqi. Since: 2.72\n @G_UNICODE_SCRIPT_MATH:                 Mathematical notation. Since: 2.72\n\n The #GUnicodeScript enumeration identifies different writing\n systems. The values correspond to the names as defined in the\n Unicode standard. The enumeration has been added in GLib 2.14,\n and is interchangeable with #PangoScript.\n\n Note that new types may be added in the future. Applications\n should be ready to handle unknown values.\n See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/)."]
pub type GUnicodeScript = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
}
unsafe extern "C" {
    pub fn g_unicode_script_from_iso15924(iso15924: guint32) -> GUnicodeScript;
}
unsafe extern "C" {
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
}
unsafe extern "C" {
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
}
unsafe extern "C" {
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
}
unsafe extern "C" {
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
}
unsafe extern "C" {
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
}
unsafe extern "C" {
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
}
unsafe extern "C" {
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
}
unsafe extern "C" {
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
}
unsafe extern "C" {
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
}
unsafe extern "C" {
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar, b: *mut gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_fully_decompose(
        ch: gunichar,
        compat: gboolean,
        result: *mut gunichar,
        result_len: gsize,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
}
unsafe extern "C" {
    pub fn g_unicode_canonical_decomposition(ch: gunichar, result_len: *mut gsize)
        -> *mut gunichar;
}
unsafe extern "C" {
    pub static g_utf8_skip: *const gchar;
}
unsafe extern "C" {
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
}
unsafe extern "C" {
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize) -> gunichar;
}
unsafe extern "C" {
    pub fn g_utf8_offset_to_pointer(str_: *const gchar, offset: glong) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_pointer_to_offset(str_: *const gchar, pos: *const gchar) -> glong;
}
unsafe extern "C" {
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_find_prev_char(str_: *const gchar, p: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
}
unsafe extern "C" {
    pub fn g_utf8_substring(str_: *const gchar, start_pos: glong, end_pos: glong) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strreverse(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_to_utf16(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
unsafe extern "C" {
    pub fn g_utf8_to_ucs4(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
unsafe extern "C" {
    pub fn g_utf8_to_ucs4_fast(
        str_: *const gchar,
        len: glong,
        items_written: *mut glong,
    ) -> *mut gunichar;
}
unsafe extern "C" {
    pub fn g_utf16_to_ucs4(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
unsafe extern "C" {
    pub fn g_utf16_to_utf8(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_ucs4_to_utf16(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
unsafe extern "C" {
    pub fn g_ucs4_to_utf8(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_utf8_validate(str_: *const gchar, max_len: gssize, end: *mut *const gchar)
        -> gboolean;
}
unsafe extern "C" {
    pub fn g_utf8_validate_len(
        str_: *const gchar,
        max_len: gsize,
        end: *mut *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_utf8_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_casefold(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub const G_NORMALIZE_DEFAULT: GNormalizeMode = 0;
pub const G_NORMALIZE_NFD: GNormalizeMode = 0;
pub const G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = 1;
pub const G_NORMALIZE_NFC: GNormalizeMode = 1;
pub const G_NORMALIZE_ALL: GNormalizeMode = 2;
pub const G_NORMALIZE_NFKD: GNormalizeMode = 2;
pub const G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = 3;
pub const G_NORMALIZE_NFKC: GNormalizeMode = 3;
#[doc = " GNormalizeMode:\n @G_NORMALIZE_DEFAULT: standardize differences that do not affect the\n     text content, such as the above-mentioned accent representation\n @G_NORMALIZE_NFD: another name for %G_NORMALIZE_DEFAULT\n @G_NORMALIZE_DEFAULT_COMPOSE: like %G_NORMALIZE_DEFAULT, but with\n     composed forms rather than a maximally decomposed form\n @G_NORMALIZE_NFC: another name for %G_NORMALIZE_DEFAULT_COMPOSE\n @G_NORMALIZE_ALL: beyond %G_NORMALIZE_DEFAULT also standardize the\n     \"compatibility\" characters in Unicode, such as SUPERSCRIPT THREE\n     to the standard forms (in this case DIGIT THREE). Formatting\n     information may be lost but for most text operations such\n     characters should be considered the same\n @G_NORMALIZE_NFKD: another name for %G_NORMALIZE_ALL\n @G_NORMALIZE_ALL_COMPOSE: like %G_NORMALIZE_ALL, but with composed\n     forms rather than a maximally decomposed form\n @G_NORMALIZE_NFKC: another name for %G_NORMALIZE_ALL_COMPOSE\n\n Defines how a Unicode string is transformed in a canonical\n form, standardizing such issues as whether a character with\n an accent is represented as a base character and combining\n accent or as a single precomposed character. Unicode strings\n should generally be normalized before comparing them."]
pub type GNormalizeMode = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_utf8_normalize(str_: *const gchar, len: gssize, mode: GNormalizeMode) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_utf8_collate_key(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_collate_key_for_filename(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_make_valid(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub type GString = _GString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GString {
    pub str_: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GString"][::std::mem::size_of::<_GString>() - 24usize];
    ["Alignment of _GString"][::std::mem::align_of::<_GString>() - 8usize];
    ["Offset of field: _GString::str_"][::std::mem::offset_of!(_GString, str_) - 0usize];
    ["Offset of field: _GString::len"][::std::mem::offset_of!(_GString, len) - 8usize];
    ["Offset of field: _GString::allocated_len"]
        [::std::mem::offset_of!(_GString, allocated_len) - 16usize];
};
unsafe extern "C" {
    pub fn g_string_new(init: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
}
unsafe extern "C" {
    pub fn g_string_hash(str_: *const GString) -> guint;
}
unsafe extern "C" {
    pub fn g_string_assign(string: *mut GString, rval: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_truncate(string: *mut GString, len: gsize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_set_size(string: *mut GString, len: gsize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_insert_len(
        string: *mut GString,
        pos: gssize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_append(string: *mut GString, val: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_append_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_prepend(string: *mut GString, val: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_prepend_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_insert(string: *mut GString, pos: gssize, val: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize, wc: gunichar)
        -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_overwrite(string: *mut GString, pos: gsize, val: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_overwrite_len(
        string: *mut GString,
        pos: gsize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_replace(
        string: *mut GString,
        find: *const gchar,
        replace: *const gchar,
        limit: guint,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar, args: *mut __va_list_tag);
}
unsafe extern "C" {
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_string_append_vprintf(
        string: *mut GString,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_string_append_printf(string: *mut GString, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_string_append_uri_escaped(
        string: *mut GString,
        unescaped: *const gchar,
        reserved_chars_allowed: *const gchar,
        allow_utf8: gboolean,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_down(string: *mut GString) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_up(string: *mut GString) -> *mut GString;
}
pub type GIOChannel = _GIOChannel;
pub type GIOFuncs = _GIOFuncs;
pub const G_IO_ERROR_NONE: GIOError = 0;
pub const G_IO_ERROR_AGAIN: GIOError = 1;
pub const G_IO_ERROR_INVAL: GIOError = 2;
pub const G_IO_ERROR_UNKNOWN: GIOError = 3;
pub type GIOError = ::std::os::raw::c_uint;
pub const G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = 0;
pub const G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = 1;
pub const G_IO_CHANNEL_ERROR_IO: GIOChannelError = 2;
pub const G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = 3;
pub const G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = 4;
pub const G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = 5;
pub const G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = 6;
pub const G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = 7;
pub const G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = 8;
pub type GIOChannelError = ::std::os::raw::c_uint;
pub const G_IO_STATUS_ERROR: GIOStatus = 0;
pub const G_IO_STATUS_NORMAL: GIOStatus = 1;
pub const G_IO_STATUS_EOF: GIOStatus = 2;
pub const G_IO_STATUS_AGAIN: GIOStatus = 3;
pub type GIOStatus = ::std::os::raw::c_uint;
pub const G_SEEK_CUR: GSeekType = 0;
pub const G_SEEK_SET: GSeekType = 1;
pub const G_SEEK_END: GSeekType = 2;
pub type GSeekType = ::std::os::raw::c_uint;
pub const G_IO_FLAG_APPEND: GIOFlags = 1;
pub const G_IO_FLAG_NONBLOCK: GIOFlags = 2;
pub const G_IO_FLAG_IS_READABLE: GIOFlags = 4;
pub const G_IO_FLAG_IS_WRITABLE: GIOFlags = 8;
pub const G_IO_FLAG_IS_WRITEABLE: GIOFlags = 8;
pub const G_IO_FLAG_IS_SEEKABLE: GIOFlags = 16;
pub const G_IO_FLAG_MASK: GIOFlags = 31;
pub const G_IO_FLAG_GET_MASK: GIOFlags = 31;
pub const G_IO_FLAG_SET_MASK: GIOFlags = 3;
pub type GIOFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GIOChannel"][::std::mem::size_of::<_GIOChannel>() - 112usize];
    ["Alignment of _GIOChannel"][::std::mem::align_of::<_GIOChannel>() - 8usize];
    ["Offset of field: _GIOChannel::ref_count"]
        [::std::mem::offset_of!(_GIOChannel, ref_count) - 0usize];
    ["Offset of field: _GIOChannel::funcs"][::std::mem::offset_of!(_GIOChannel, funcs) - 8usize];
    ["Offset of field: _GIOChannel::encoding"]
        [::std::mem::offset_of!(_GIOChannel, encoding) - 16usize];
    ["Offset of field: _GIOChannel::read_cd"]
        [::std::mem::offset_of!(_GIOChannel, read_cd) - 24usize];
    ["Offset of field: _GIOChannel::write_cd"]
        [::std::mem::offset_of!(_GIOChannel, write_cd) - 32usize];
    ["Offset of field: _GIOChannel::line_term"]
        [::std::mem::offset_of!(_GIOChannel, line_term) - 40usize];
    ["Offset of field: _GIOChannel::line_term_len"]
        [::std::mem::offset_of!(_GIOChannel, line_term_len) - 48usize];
    ["Offset of field: _GIOChannel::buf_size"]
        [::std::mem::offset_of!(_GIOChannel, buf_size) - 56usize];
    ["Offset of field: _GIOChannel::read_buf"]
        [::std::mem::offset_of!(_GIOChannel, read_buf) - 64usize];
    ["Offset of field: _GIOChannel::encoded_read_buf"]
        [::std::mem::offset_of!(_GIOChannel, encoded_read_buf) - 72usize];
    ["Offset of field: _GIOChannel::write_buf"]
        [::std::mem::offset_of!(_GIOChannel, write_buf) - 80usize];
    ["Offset of field: _GIOChannel::partial_write_buf"]
        [::std::mem::offset_of!(_GIOChannel, partial_write_buf) - 88usize];
    ["Offset of field: _GIOChannel::reserved1"]
        [::std::mem::offset_of!(_GIOChannel, reserved1) - 96usize];
    ["Offset of field: _GIOChannel::reserved2"]
        [::std::mem::offset_of!(_GIOChannel, reserved2) - 104usize];
};
impl _GIOChannel {
    #[inline]
    pub fn use_buffer(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_buffer(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_buffer_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_buffer_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn do_encode(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_encode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn do_encode_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_do_encode_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn close_on_unref(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_on_unref(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn close_on_unref_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_close_on_unref_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_readable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_readable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_readable_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_readable_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_writeable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_writeable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_writeable_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_writeable_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_seekable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_seekable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_seekable_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_seekable_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_buffer: guint,
        do_encode: guint,
        close_on_unref: guint,
        is_readable: guint,
        is_writeable: guint,
        is_seekable: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_buffer: u32 = unsafe { ::std::mem::transmute(use_buffer) };
            use_buffer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_encode: u32 = unsafe { ::std::mem::transmute(do_encode) };
            do_encode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let close_on_unref: u32 = unsafe { ::std::mem::transmute(close_on_unref) };
            close_on_unref as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_readable: u32 = unsafe { ::std::mem::transmute(is_readable) };
            is_readable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_writeable: u32 = unsafe { ::std::mem::transmute(is_writeable) };
            is_writeable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_seekable: u32 = unsafe { ::std::mem::transmute(is_seekable) };
            is_seekable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type GIOFunc = ::std::option::Option<
    unsafe extern "C" fn(
        source: *mut GIOChannel,
        condition: GIOCondition,
        data: gpointer,
    ) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOFuncs {
    pub io_read: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *mut gchar,
            count: gsize,
            bytes_read: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_write: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *const gchar,
            count: gsize,
            bytes_written: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_seek: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            offset: gint64,
            type_: GSeekType,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_close: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, err: *mut *mut GError) -> GIOStatus,
    >,
    pub io_create_watch: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource,
    >,
    pub io_free: ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel)>,
    pub io_set_flags: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            flags: GIOFlags,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_get_flags:
        ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel) -> GIOFlags>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GIOFuncs"][::std::mem::size_of::<_GIOFuncs>() - 64usize];
    ["Alignment of _GIOFuncs"][::std::mem::align_of::<_GIOFuncs>() - 8usize];
    ["Offset of field: _GIOFuncs::io_read"][::std::mem::offset_of!(_GIOFuncs, io_read) - 0usize];
    ["Offset of field: _GIOFuncs::io_write"][::std::mem::offset_of!(_GIOFuncs, io_write) - 8usize];
    ["Offset of field: _GIOFuncs::io_seek"][::std::mem::offset_of!(_GIOFuncs, io_seek) - 16usize];
    ["Offset of field: _GIOFuncs::io_close"][::std::mem::offset_of!(_GIOFuncs, io_close) - 24usize];
    ["Offset of field: _GIOFuncs::io_create_watch"]
        [::std::mem::offset_of!(_GIOFuncs, io_create_watch) - 32usize];
    ["Offset of field: _GIOFuncs::io_free"][::std::mem::offset_of!(_GIOFuncs, io_free) - 40usize];
    ["Offset of field: _GIOFuncs::io_set_flags"]
        [::std::mem::offset_of!(_GIOFuncs, io_set_flags) - 48usize];
    ["Offset of field: _GIOFuncs::io_get_flags"]
        [::std::mem::offset_of!(_GIOFuncs, io_get_flags) - 56usize];
};
unsafe extern "C" {
    pub fn g_io_channel_init(channel: *mut GIOChannel);
}
unsafe extern "C" {
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
}
unsafe extern "C" {
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
}
unsafe extern "C" {
    pub fn g_io_channel_read(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
    ) -> GIOError;
}
unsafe extern "C" {
    pub fn g_io_channel_write(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gsize,
        bytes_written: *mut gsize,
    ) -> GIOError;
}
unsafe extern "C" {
    pub fn g_io_channel_seek(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
    ) -> GIOError;
}
unsafe extern "C" {
    pub fn g_io_channel_close(channel: *mut GIOChannel);
}
unsafe extern "C" {
    pub fn g_io_channel_shutdown(
        channel: *mut GIOChannel,
        flush: gboolean,
        err: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_add_watch_full(
        channel: *mut GIOChannel,
        priority: gint,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_io_add_watch(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: gsize);
}
unsafe extern "C" {
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
}
unsafe extern "C" {
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
}
unsafe extern "C" {
    pub fn g_io_channel_set_flags(
        channel: *mut GIOChannel,
        flags: GIOFlags,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
}
unsafe extern "C" {
    pub fn g_io_channel_set_line_term(
        channel: *mut GIOChannel,
        line_term: *const gchar,
        length: gint,
    );
}
unsafe extern "C" {
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
}
unsafe extern "C" {
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
}
unsafe extern "C" {
    pub fn g_io_channel_set_encoding(
        channel: *mut GIOChannel,
        encoding: *const gchar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
}
unsafe extern "C" {
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
}
unsafe extern "C" {
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_line(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_line_string(
        channel: *mut GIOChannel,
        buffer: *mut GString,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_to_end(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_chars(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_unichar(
        channel: *mut GIOChannel,
        thechar: *mut gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_write_chars(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gssize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_write_unichar(
        channel: *mut GIOChannel,
        thechar: gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_seek_position(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_new_file(
        filename: *const gchar,
        mode: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GIOChannel;
}
unsafe extern "C" {
    pub fn g_io_channel_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
}
unsafe extern "C" {
    pub fn g_io_channel_unix_new(fd: ::std::os::raw::c_int) -> *mut GIOChannel;
}
unsafe extern "C" {
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
}
unsafe extern "C" {
    pub static mut g_io_watch_funcs: GSourceFuncs;
}
pub const G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = 0;
pub const G_KEY_FILE_ERROR_PARSE: GKeyFileError = 1;
pub const G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = 2;
pub const G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = 3;
pub const G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = 4;
pub const G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = 5;
pub type GKeyFileError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_key_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GKeyFile {
    _unused: [u8; 0],
}
pub type GKeyFile = _GKeyFile;
pub const G_KEY_FILE_NONE: GKeyFileFlags = 0;
pub const G_KEY_FILE_KEEP_COMMENTS: GKeyFileFlags = 1;
pub const G_KEY_FILE_KEEP_TRANSLATIONS: GKeyFileFlags = 2;
pub type GKeyFileFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_key_file_new() -> *mut GKeyFile;
}
unsafe extern "C" {
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
}
unsafe extern "C" {
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
}
unsafe extern "C" {
    pub fn g_key_file_free(key_file: *mut GKeyFile);
}
unsafe extern "C" {
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: gchar);
}
unsafe extern "C" {
    pub fn g_key_file_load_from_file(
        key_file: *mut GKeyFile,
        file: *const gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_load_from_data(
        key_file: *mut GKeyFile,
        data: *const gchar,
        length: gsize,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_load_from_bytes(
        key_file: *mut GKeyFile,
        bytes: *mut GBytes,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_load_from_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        search_dirs: *mut *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_load_from_data_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_to_data(
        key_file: *mut GKeyFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_save_to_file(
        key_file: *mut GKeyFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_get_keys(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_has_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_get_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        string: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_get_locale_for_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        string: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_set_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_key_file_set_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint64;
}
unsafe extern "C" {
    pub fn g_key_file_set_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint64,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> guint64;
}
unsafe extern "C" {
    pub fn g_key_file_set_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: guint64,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gdouble;
}
unsafe extern "C" {
    pub fn g_key_file_set_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gdouble,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_set_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gboolean,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gint;
}
unsafe extern "C" {
    pub fn g_key_file_set_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gdouble,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gdouble;
}
unsafe extern "C" {
    pub fn g_key_file_set_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gint,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_set_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        comment: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_get_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_remove_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_remove_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_remove_group(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMappedFile {
    _unused: [u8; 0],
}
pub type GMappedFile = _GMappedFile;
unsafe extern "C" {
    pub fn g_mapped_file_new(
        filename: *const gchar,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
unsafe extern "C" {
    pub fn g_mapped_file_new_from_fd(
        fd: gint,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
unsafe extern "C" {
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
}
unsafe extern "C" {
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
}
unsafe extern "C" {
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
}
unsafe extern "C" {
    pub fn g_mapped_file_free(file: *mut GMappedFile);
}
pub const G_MARKUP_ERROR_BAD_UTF8: GMarkupError = 0;
pub const G_MARKUP_ERROR_EMPTY: GMarkupError = 1;
pub const G_MARKUP_ERROR_PARSE: GMarkupError = 2;
pub const G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = 3;
pub const G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = 4;
pub const G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = 5;
pub const G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = 6;
#[doc = " GMarkupError:\n @G_MARKUP_ERROR_BAD_UTF8: text being parsed was not valid UTF-8\n @G_MARKUP_ERROR_EMPTY: document contained nothing, or only whitespace\n @G_MARKUP_ERROR_PARSE: document was ill-formed\n @G_MARKUP_ERROR_UNKNOWN_ELEMENT: error should be set by #GMarkupParser\n     functions; element wasn't known\n @G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: error should be set by #GMarkupParser\n     functions; attribute wasn't known\n @G_MARKUP_ERROR_INVALID_CONTENT: error should be set by #GMarkupParser\n     functions; content was invalid\n @G_MARKUP_ERROR_MISSING_ATTRIBUTE: error should be set by #GMarkupParser\n     functions; a required attribute was missing\n\n Error codes returned by markup parsing."]
pub type GMarkupError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_markup_error_quark() -> GQuark;
}
pub const G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: GMarkupParseFlags = 1;
pub const G_MARKUP_TREAT_CDATA_AS_TEXT: GMarkupParseFlags = 2;
pub const G_MARKUP_PREFIX_ERROR_POSITION: GMarkupParseFlags = 4;
pub const G_MARKUP_IGNORE_QUALIFIED: GMarkupParseFlags = 8;
#[doc = " GMarkupParseFlags:\n @G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: flag you should not use\n @G_MARKUP_TREAT_CDATA_AS_TEXT: When this flag is set, CDATA marked\n     sections are not passed literally to the @passthrough function of\n     the parser. Instead, the content of the section (without the\n     `<![CDATA[` and `]]>`) is\n     passed to the @text function. This flag was added in GLib 2.12\n @G_MARKUP_PREFIX_ERROR_POSITION: Normally errors caught by GMarkup\n     itself have line/column information prefixed to them to let the\n     caller know the location of the error. When this flag is set the\n     location information is also prefixed to errors generated by the\n     #GMarkupParser implementation functions\n @G_MARKUP_IGNORE_QUALIFIED: Ignore (don't report) qualified\n     attributes and tags, along with their contents.  A qualified\n     attribute or tag is one that contains ':' in its name (ie: is in\n     another namespace).  Since: 2.40.\n\n Flags that affect the behaviour of the parser."]
pub type GMarkupParseFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParseContext {
    _unused: [u8; 0],
}
#[doc = " GMarkupParseContext:\n\n A parse context is used to parse a stream of bytes that\n you expect to contain marked-up text.\n\n See g_markup_parse_context_new(), #GMarkupParser, and so\n on for more details."]
pub type GMarkupParseContext = _GMarkupParseContext;
#[doc = " GMarkupParser:\n @start_element: Callback to invoke when the opening tag of an element\n     is seen. The callback's @attribute_names and @attribute_values parameters\n     are %NULL-terminated.\n @end_element: Callback to invoke when the closing tag of an element\n     is seen. Note that this is also called for empty tags like\n     `<empty/>`.\n @text: Callback to invoke when some text is seen (text is always\n     inside an element). Note that the text of an element may be spread\n     over multiple calls of this function. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also\n     called for the content of CDATA marked sections.\n @passthrough: Callback to invoke for comments, processing instructions\n     and doctype declarations; if you're re-writing the parsed document,\n     write the passthrough text back out in the same position. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also\n     called for CDATA marked sections.\n @error: Callback to invoke when an error occurs.\n\n Any of the fields in #GMarkupParser can be %NULL, in which case they\n will be ignored. Except for the @error function, any of these callbacks\n can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,\n %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT\n errors are intended to be set from these callbacks. If you set an error\n from a callback, g_markup_parse_context_parse() will report that error\n back to its caller."]
pub type GMarkupParser = _GMarkupParser;
#[doc = " GMarkupParser:\n @start_element: Callback to invoke when the opening tag of an element\n     is seen. The callback's @attribute_names and @attribute_values parameters\n     are %NULL-terminated.\n @end_element: Callback to invoke when the closing tag of an element\n     is seen. Note that this is also called for empty tags like\n     `<empty/>`.\n @text: Callback to invoke when some text is seen (text is always\n     inside an element). Note that the text of an element may be spread\n     over multiple calls of this function. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also\n     called for the content of CDATA marked sections.\n @passthrough: Callback to invoke for comments, processing instructions\n     and doctype declarations; if you're re-writing the parsed document,\n     write the passthrough text back out in the same position. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also\n     called for CDATA marked sections.\n @error: Callback to invoke when an error occurs.\n\n Any of the fields in #GMarkupParser can be %NULL, in which case they\n will be ignored. Except for the @error function, any of these callbacks\n can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,\n %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT\n errors are intended to be set from these callbacks. If you set an error\n from a callback, g_markup_parse_context_parse() will report that error\n back to its caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParser {
    pub start_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            attribute_names: *mut *const gchar,
            attribute_values: *mut *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub end_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub passthrough: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            passthrough_text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            error: *mut GError,
            user_data: gpointer,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMarkupParser"][::std::mem::size_of::<_GMarkupParser>() - 40usize];
    ["Alignment of _GMarkupParser"][::std::mem::align_of::<_GMarkupParser>() - 8usize];
    ["Offset of field: _GMarkupParser::start_element"]
        [::std::mem::offset_of!(_GMarkupParser, start_element) - 0usize];
    ["Offset of field: _GMarkupParser::end_element"]
        [::std::mem::offset_of!(_GMarkupParser, end_element) - 8usize];
    ["Offset of field: _GMarkupParser::text"]
        [::std::mem::offset_of!(_GMarkupParser, text) - 16usize];
    ["Offset of field: _GMarkupParser::passthrough"]
        [::std::mem::offset_of!(_GMarkupParser, passthrough) - 24usize];
    ["Offset of field: _GMarkupParser::error"]
        [::std::mem::offset_of!(_GMarkupParser, error) - 32usize];
};
unsafe extern "C" {
    pub fn g_markup_parse_context_new(
        parser: *const GMarkupParser,
        flags: GMarkupParseFlags,
        user_data: gpointer,
        user_data_dnotify: GDestroyNotify,
    ) -> *mut GMarkupParseContext;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_ref(
        context: *mut GMarkupParseContext,
    ) -> *mut GMarkupParseContext;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
}
unsafe extern "C" {
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
}
unsafe extern "C" {
    pub fn g_markup_parse_context_parse(
        context: *mut GMarkupParseContext,
        text: *const gchar,
        text_len: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_push(
        context: *mut GMarkupParseContext,
        parser: *const GMarkupParser,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_end_parse(
        context: *mut GMarkupParseContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_get_element_stack(
        context: *mut GMarkupParseContext,
    ) -> *const GSList;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_get_position(
        context: *mut GMarkupParseContext,
        line_number: *mut gint,
        char_number: *mut gint,
    );
}
unsafe extern "C" {
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
}
unsafe extern "C" {
    pub fn g_markup_escape_text(text: *const gchar, length: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_markup_printf_escaped(format: *const ::std::os::raw::c_char, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_markup_vprintf_escaped(
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> *mut gchar;
}
pub const G_MARKUP_COLLECT_INVALID: GMarkupCollectType = 0;
pub const G_MARKUP_COLLECT_STRING: GMarkupCollectType = 1;
pub const G_MARKUP_COLLECT_STRDUP: GMarkupCollectType = 2;
pub const G_MARKUP_COLLECT_BOOLEAN: GMarkupCollectType = 3;
pub const G_MARKUP_COLLECT_TRISTATE: GMarkupCollectType = 4;
pub const G_MARKUP_COLLECT_OPTIONAL: GMarkupCollectType = 65536;
pub type GMarkupCollectType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_markup_collect_attributes(
        element_name: *const gchar,
        attribute_names: *mut *const gchar,
        attribute_values: *mut *const gchar,
        error: *mut *mut GError,
        first_type: GMarkupCollectType,
        first_attr: *const gchar,
        ...
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantType {
    _unused: [u8; 0],
}
#[doc = " GVariantType:\n\n A type in the GVariant type system.\n\n Two types may not be compared by value; use g_variant_type_equal() or\n g_variant_type_is_subtype_of().  May be copied using\n g_variant_type_copy() and freed using g_variant_type_free()."]
pub type GVariantType = _GVariantType;
unsafe extern "C" {
    pub fn g_variant_type_string_is_valid(type_string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_string_scan(
        string: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_free(type_: *mut GVariantType);
}
unsafe extern "C" {
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_hash(type_: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_subtype_of(
        type_: *const GVariantType,
        supertype: *const GVariantType,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new_tuple(
        items: *const *const GVariantType,
        length: gint,
    ) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new_dict_entry(
        key: *const GVariantType,
        value: *const GVariantType,
    ) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_checked_(arg1: *const gchar) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_string_get_depth_(type_string: *const gchar) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariant {
    _unused: [u8; 0],
}
pub type GVariant = _GVariant;
pub const G_VARIANT_CLASS_BOOLEAN: GVariantClass = 98;
pub const G_VARIANT_CLASS_BYTE: GVariantClass = 121;
pub const G_VARIANT_CLASS_INT16: GVariantClass = 110;
pub const G_VARIANT_CLASS_UINT16: GVariantClass = 113;
pub const G_VARIANT_CLASS_INT32: GVariantClass = 105;
pub const G_VARIANT_CLASS_UINT32: GVariantClass = 117;
pub const G_VARIANT_CLASS_INT64: GVariantClass = 120;
pub const G_VARIANT_CLASS_UINT64: GVariantClass = 116;
pub const G_VARIANT_CLASS_HANDLE: GVariantClass = 104;
pub const G_VARIANT_CLASS_DOUBLE: GVariantClass = 100;
pub const G_VARIANT_CLASS_STRING: GVariantClass = 115;
pub const G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = 111;
pub const G_VARIANT_CLASS_SIGNATURE: GVariantClass = 103;
pub const G_VARIANT_CLASS_VARIANT: GVariantClass = 118;
pub const G_VARIANT_CLASS_MAYBE: GVariantClass = 109;
pub const G_VARIANT_CLASS_ARRAY: GVariantClass = 97;
pub const G_VARIANT_CLASS_TUPLE: GVariantClass = 40;
pub const G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = 123;
pub type GVariantClass = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_variant_unref(value: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
}
unsafe extern "C" {
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_byte(value: guint8) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_printf(format_string: *const gchar, ...) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_object_path(object_path: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_bytestring_array(
        strv: *const *const gchar,
        length: gssize,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_fixed_array(
        element_type: *const GVariantType,
        elements: gconstpointer,
        n_elements: gsize,
        element_size: gsize,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_get_byte(value: *mut GVariant) -> guint8;
}
unsafe extern "C" {
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
}
unsafe extern "C" {
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
}
unsafe extern "C" {
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
}
unsafe extern "C" {
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
}
unsafe extern "C" {
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
}
unsafe extern "C" {
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
}
unsafe extern "C" {
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
}
unsafe extern "C" {
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
}
unsafe extern "C" {
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_get_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_new_maybe(
        child_type: *const GVariantType,
        child: *mut GVariant,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_array(
        child_type: *const GVariantType,
        children: *const *mut GVariant,
        n_children: gsize,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_tuple(children: *const *mut GVariant, n_children: gsize) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_get_child(
        value: *mut GVariant,
        index_: gsize,
        format_string: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_lookup(
        dictionary: *mut GVariant,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_lookup_value(
        dictionary: *mut GVariant,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_fixed_array(
        value: *mut GVariant,
        n_elements: *mut gsize,
        element_size: gsize,
    ) -> gconstpointer;
}
unsafe extern "C" {
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
}
unsafe extern "C" {
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
}
unsafe extern "C" {
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_print_string(
        value: *mut GVariant,
        string: *mut GString,
        type_annotate: gboolean,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_variant_hash(value: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_from_bytes(
        type_: *const GVariantType,
        bytes: *mut GBytes,
        trusted: gboolean,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_from_data(
        type_: *const GVariantType,
        data: gconstpointer,
        size: gsize,
        trusted: gboolean,
        notify: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GVariant;
}
pub type GVariantIter = _GVariantIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantIter {
    pub x: [gsize; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantIter"][::std::mem::size_of::<_GVariantIter>() - 128usize];
    ["Alignment of _GVariantIter"][::std::mem::align_of::<_GVariantIter>() - 8usize];
    ["Offset of field: _GVariantIter::x"][::std::mem::offset_of!(_GVariantIter, x) - 0usize];
};
unsafe extern "C" {
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
}
unsafe extern "C" {
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
}
unsafe extern "C" {
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
}
unsafe extern "C" {
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_iter_next(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_iter_loop(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
pub type GVariantBuilder = _GVariantBuilder;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantBuilder {
    pub u: _GVariantBuilder__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantBuilder__bindgen_ty_1 {
    pub s: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 {
    pub partial_magic: gsize,
    pub type_: *const GVariantType,
    pub y: [gsize; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantBuilder__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>() - 128usize];
    ["Alignment of _GVariantBuilder__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1::partial_magic"][::std::mem::offset_of!(
        _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
        partial_magic
    ) - 0usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1::type_"]
        [::std::mem::offset_of!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1, type_) - 8usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1::y"]
        [::std::mem::offset_of!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1, y) - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantBuilder__bindgen_ty_1"]
        [::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1>() - 128usize];
    ["Alignment of _GVariantBuilder__bindgen_ty_1"]
        [::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1::s"]
        [::std::mem::offset_of!(_GVariantBuilder__bindgen_ty_1, s) - 0usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1::x"]
        [::std::mem::offset_of!(_GVariantBuilder__bindgen_ty_1, x) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantBuilder"][::std::mem::size_of::<_GVariantBuilder>() - 128usize];
    ["Alignment of _GVariantBuilder"][::std::mem::align_of::<_GVariantBuilder>() - 8usize];
    ["Offset of field: _GVariantBuilder::u"][::std::mem::offset_of!(_GVariantBuilder, u) - 0usize];
};
pub const G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = 0;
pub const G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = 1;
pub const G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = 2;
pub const G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = 3;
pub const G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = 4;
pub const G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = 5;
pub const G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = 6;
pub const G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = 7;
pub const G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = 8;
pub const G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = 9;
pub const G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = 10;
pub const G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = 11;
pub const G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = 12;
pub const G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = 13;
pub const G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = 14;
pub const G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = 15;
pub const G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT: GVariantParseError = 16;
pub const G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = 17;
pub const G_VARIANT_PARSE_ERROR_RECURSION: GVariantParseError = 18;
pub type GVariantParseError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_variant_parser_get_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_variant_parse_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
}
unsafe extern "C" {
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
}
unsafe extern "C" {
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
}
unsafe extern "C" {
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
unsafe extern "C" {
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
}
unsafe extern "C" {
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
unsafe extern "C" {
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
}
unsafe extern "C" {
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get(value: *mut GVariant, format_string: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_variant_new_va(
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_va(
        value: *mut GVariant,
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    );
}
unsafe extern "C" {
    pub fn g_variant_check_format_string(
        value: *mut GVariant,
        format_string: *const gchar,
        copy_only: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_parse(
        type_: *const GVariantType,
        text: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_parse_error_print_context(
        error: *mut GError,
        source_str: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
}
pub type GVariantDict = _GVariantDict;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantDict {
    pub u: _GVariantDict__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantDict__bindgen_ty_1 {
    pub s: _GVariantDict__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantDict__bindgen_ty_1__bindgen_ty_1 {
    pub asv: *mut GVariant,
    pub partial_magic: gsize,
    pub y: [gsize; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantDict__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>() - 128usize];
    ["Alignment of _GVariantDict__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1__bindgen_ty_1::asv"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1__bindgen_ty_1, asv) - 0usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1__bindgen_ty_1::partial_magic"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1__bindgen_ty_1, partial_magic) - 8usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1__bindgen_ty_1::y"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1__bindgen_ty_1, y) - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantDict__bindgen_ty_1"]
        [::std::mem::size_of::<_GVariantDict__bindgen_ty_1>() - 128usize];
    ["Alignment of _GVariantDict__bindgen_ty_1"]
        [::std::mem::align_of::<_GVariantDict__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1::s"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1, s) - 0usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1::x"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1, x) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantDict"][::std::mem::size_of::<_GVariantDict>() - 128usize];
    ["Alignment of _GVariantDict"][::std::mem::align_of::<_GVariantDict>() - 8usize];
    ["Offset of field: _GVariantDict::u"][::std::mem::offset_of!(_GVariantDict, u) - 0usize];
};
unsafe extern "C" {
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
}
unsafe extern "C" {
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_variant_dict_lookup(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_dict_lookup_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_dict_insert(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_variant_dict_insert_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        value: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
}
unsafe extern "C" {
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
}
unsafe extern "C" {
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
}
unsafe extern "C" {
    pub fn g_printf_string_upper_bound(format: *const gchar, args: *mut __va_list_tag) -> gsize;
}
pub const G_LOG_FLAG_RECURSION: GLogLevelFlags = 1;
pub const G_LOG_FLAG_FATAL: GLogLevelFlags = 2;
pub const G_LOG_LEVEL_ERROR: GLogLevelFlags = 4;
pub const G_LOG_LEVEL_CRITICAL: GLogLevelFlags = 8;
pub const G_LOG_LEVEL_WARNING: GLogLevelFlags = 16;
pub const G_LOG_LEVEL_MESSAGE: GLogLevelFlags = 32;
pub const G_LOG_LEVEL_INFO: GLogLevelFlags = 64;
pub const G_LOG_LEVEL_DEBUG: GLogLevelFlags = 128;
pub const G_LOG_LEVEL_MASK: GLogLevelFlags = -4;
pub type GLogLevelFlags = ::std::os::raw::c_int;
pub type GLogFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ),
>;
unsafe extern "C" {
    pub fn g_log_set_handler(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_log_set_handler_full(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
}
unsafe extern "C" {
    pub fn g_log_default_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
}
unsafe extern "C" {
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_logv(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_log_set_fatal_mask(
        log_domain: *const gchar,
        fatal_mask: GLogLevelFlags,
    ) -> GLogLevelFlags;
}
unsafe extern "C" {
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
}
pub const G_LOG_WRITER_HANDLED: GLogWriterOutput = 1;
pub const G_LOG_WRITER_UNHANDLED: GLogWriterOutput = 0;
#[doc = " GLogWriterOutput:\n @G_LOG_WRITER_HANDLED: Log writer has handled the log entry.\n @G_LOG_WRITER_UNHANDLED: Log writer could not handle the log entry.\n\n Return values from #GLogWriterFuncs to indicate whether the given log entry\n was successfully handled by the writer, or whether there was an error in\n handling it (and hence a fallback writer should be used).\n\n If a #GLogWriterFunc ignores a log entry, it should return\n %G_LOG_WRITER_HANDLED.\n\n Since: 2.50"]
pub type GLogWriterOutput = ::std::os::raw::c_uint;
#[doc = " GLogField:\n @key: field name (UTF-8 string)\n @value: field value (arbitrary bytes)\n @length: length of @value, in bytes, or -1 if it is nul-terminated\n\n Structure representing a single field in a structured log entry. See\n g_log_structured() for details.\n\n Log fields may contain arbitrary values, including binary with embedded nul\n bytes. If the field contains a string, the string must be UTF-8 encoded and\n have a trailing nul byte. Otherwise, @length must be set to a non-negative\n value.\n\n Since: 2.50"]
pub type GLogField = _GLogField;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLogField {
    pub key: *const gchar,
    pub value: gconstpointer,
    pub length: gssize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GLogField"][::std::mem::size_of::<_GLogField>() - 24usize];
    ["Alignment of _GLogField"][::std::mem::align_of::<_GLogField>() - 8usize];
    ["Offset of field: _GLogField::key"][::std::mem::offset_of!(_GLogField, key) - 0usize];
    ["Offset of field: _GLogField::value"][::std::mem::offset_of!(_GLogField, value) - 8usize];
    ["Offset of field: _GLogField::length"][::std::mem::offset_of!(_GLogField, length) - 16usize];
};
#[doc = " GLogWriterFunc:\n @log_level: log level of the message\n @fields: (array length=n_fields): fields forming the message\n @n_fields: number of @fields\n @user_data: user data passed to g_log_set_writer_func()\n\n Writer function for log entries. A log entry is a collection of one or more\n #GLogFields, using the standard [field names from journal\n specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html).\n See g_log_structured() for more information.\n\n Writer functions must ignore fields which they do not recognise, unless they\n can write arbitrary binary output, as field values may be arbitrary binary.\n\n @log_level is guaranteed to be included in @fields as the `PRIORITY` field,\n but is provided separately for convenience of deciding whether or where to\n output the log entry.\n\n Writer functions should return %G_LOG_WRITER_HANDLED if they handled the log\n message successfully or if they deliberately ignored it. If there was an\n error handling the message (for example, if the writer function is meant to\n send messages to a remote logging server and there is a network error), it\n should return %G_LOG_WRITER_UNHANDLED. This allows writer functions to be\n chained and fall back to simpler handlers in case of failure.\n\n Returns: %G_LOG_WRITER_HANDLED if the log entry was handled successfully;\n   %G_LOG_WRITER_UNHANDLED otherwise\n\n Since: 2.50"]
pub type GLogWriterFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput,
>;
unsafe extern "C" {
    pub fn g_log_structured(log_domain: *const gchar, log_level: GLogLevelFlags, ...);
}
unsafe extern "C" {
    pub fn g_log_structured_array(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
    );
}
unsafe extern "C" {
    pub fn g_log_variant(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        fields: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_log_set_writer_func(
        func: GLogWriterFunc,
        user_data: gpointer,
        user_data_free: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_log_writer_supports_color(output_fd: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_log_writer_is_journald(output_fd: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_log_writer_format_fields(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        use_color: gboolean,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_log_writer_journald(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
unsafe extern "C" {
    pub fn g_log_writer_standard_streams(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
unsafe extern "C" {
    pub fn g_log_writer_default(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
unsafe extern "C" {
    pub fn g_log_writer_default_set_use_stderr(use_stderr: gboolean);
}
unsafe extern "C" {
    pub fn g_log_writer_default_would_drop(
        log_level: GLogLevelFlags,
        log_domain: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_log_get_debug_enabled() -> gboolean;
}
unsafe extern "C" {
    pub fn g_log_set_debug_enabled(enabled: gboolean);
}
unsafe extern "C" {
    pub fn _g_log_fallback_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_return_if_fail_warning(
        log_domain: *const ::std::os::raw::c_char,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_warn_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        warnexpr: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assert_warning(
        log_domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn g_log_structured_standard(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        file: *const gchar,
        line: *const gchar,
        func: *const gchar,
        message_format: *const gchar,
        ...
    );
}
#[doc = " GPrintFunc:\n @string: the message to output\n\n Specifies the type of the print handler functions.\n These are called with the complete formatted string to output."]
pub type GPrintFunc = ::std::option::Option<unsafe extern "C" fn(string: *const gchar)>;
unsafe extern "C" {
    pub fn g_print(format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
}
unsafe extern "C" {
    pub fn g_printerr(format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionContext {
    _unused: [u8; 0],
}
#[doc = " GOptionContext:\n\n A `GOptionContext` struct defines which options\n are accepted by the commandline option parser. The struct has only private\n fields and should not be directly accessed."]
pub type GOptionContext = _GOptionContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionGroup {
    _unused: [u8; 0],
}
#[doc = " GOptionGroup:\n\n A `GOptionGroup` struct defines the options in a single\n group. The struct has only private fields and should not be directly accessed.\n\n All options in a group share the same translation function. Libraries which\n need to parse commandline options are expected to provide a function for\n getting a `GOptionGroup` holding their options, which\n the application can then add to its #GOptionContext."]
pub type GOptionGroup = _GOptionGroup;
#[doc = " GOptionEntry:\n @long_name: The long name of an option can be used to specify it\n     in a commandline as `--long_name`. Every option must have a\n     long name. To resolve conflicts if multiple option groups contain\n     the same long name, it is also possible to specify the option as\n     `--groupname-long_name`.\n @short_name: If an option has a short name, it can be specified\n     `-short_name` in a commandline. @short_name must be  a printable\n     ASCII character different from '-', or zero if the option has no\n     short name.\n @flags: Flags from #GOptionFlags\n @arg: The type of the option, as a #GOptionArg\n @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data\n     must point to a #GOptionArgFunc callback function, which will be\n     called to handle the extra argument. Otherwise, @arg_data is a\n     pointer to a location to store the value, the required type of\n     the location depends on the @arg type:\n     - %G_OPTION_ARG_NONE: %gboolean\n     - %G_OPTION_ARG_STRING: %gchar*\n     - %G_OPTION_ARG_INT: %gint\n     - %G_OPTION_ARG_FILENAME: %gchar*\n     - %G_OPTION_ARG_STRING_ARRAY: %gchar**\n     - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**\n     - %G_OPTION_ARG_DOUBLE: %gdouble\n     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,\n     the location will contain a newly allocated string if the option\n     was given. That string needs to be freed by the callee using g_free().\n     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or\n     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().\n @description: the description for the option in `--help`\n     output. The @description is translated using the @translate_func\n     of the group, see g_option_group_set_translation_domain().\n @arg_description: The placeholder to use for the extra argument parsed\n     by the option in `--help` output. The @arg_description is translated\n     using the @translate_func of the group, see\n     g_option_group_set_translation_domain().\n\n A GOptionEntry struct defines a single option. To have an effect, they\n must be added to a #GOptionGroup with g_option_context_add_main_entries()\n or g_option_group_add_entries()."]
pub type GOptionEntry = _GOptionEntry;
pub const G_OPTION_FLAG_NONE: GOptionFlags = 0;
pub const G_OPTION_FLAG_HIDDEN: GOptionFlags = 1;
pub const G_OPTION_FLAG_IN_MAIN: GOptionFlags = 2;
pub const G_OPTION_FLAG_REVERSE: GOptionFlags = 4;
pub const G_OPTION_FLAG_NO_ARG: GOptionFlags = 8;
pub const G_OPTION_FLAG_FILENAME: GOptionFlags = 16;
pub const G_OPTION_FLAG_OPTIONAL_ARG: GOptionFlags = 32;
pub const G_OPTION_FLAG_NOALIAS: GOptionFlags = 64;
#[doc = " GOptionFlags:\n @G_OPTION_FLAG_NONE: No flags. Since: 2.42.\n @G_OPTION_FLAG_HIDDEN: The option doesn't appear in `--help` output.\n @G_OPTION_FLAG_IN_MAIN: The option appears in the main section of the\n     `--help` output, even if it is defined in a group.\n @G_OPTION_FLAG_REVERSE: For options of the %G_OPTION_ARG_NONE kind, this\n     flag indicates that the sense of the option is reversed.\n @G_OPTION_FLAG_NO_ARG: For options of the %G_OPTION_ARG_CALLBACK kind,\n     this flag indicates that the callback does not take any argument\n     (like a %G_OPTION_ARG_NONE option). Since 2.8\n @G_OPTION_FLAG_FILENAME: For options of the %G_OPTION_ARG_CALLBACK\n     kind, this flag indicates that the argument should be passed to the\n     callback in the GLib filename encoding rather than UTF-8. Since 2.8\n @G_OPTION_FLAG_OPTIONAL_ARG: For options of the %G_OPTION_ARG_CALLBACK\n     kind, this flag indicates that the argument supply is optional.\n     If no argument is given then data of %GOptionParseFunc will be\n     set to NULL. Since 2.8\n @G_OPTION_FLAG_NOALIAS: This flag turns off the automatic conflict\n     resolution which prefixes long option names with `groupname-` if\n     there is a conflict. This option should only be used in situations\n     where aliasing is necessary to model some legacy commandline interface.\n     It is not safe to use this option, unless all option groups are under\n     your direct control. Since 2.8.\n\n Flags which modify individual options."]
pub type GOptionFlags = ::std::os::raw::c_uint;
pub const G_OPTION_ARG_NONE: GOptionArg = 0;
pub const G_OPTION_ARG_STRING: GOptionArg = 1;
pub const G_OPTION_ARG_INT: GOptionArg = 2;
pub const G_OPTION_ARG_CALLBACK: GOptionArg = 3;
pub const G_OPTION_ARG_FILENAME: GOptionArg = 4;
pub const G_OPTION_ARG_STRING_ARRAY: GOptionArg = 5;
pub const G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = 6;
pub const G_OPTION_ARG_DOUBLE: GOptionArg = 7;
pub const G_OPTION_ARG_INT64: GOptionArg = 8;
#[doc = " GOptionArg:\n @G_OPTION_ARG_NONE: No extra argument. This is useful for simple flags.\n @G_OPTION_ARG_STRING: The option takes a UTF-8 string argument.\n @G_OPTION_ARG_INT: The option takes an integer argument.\n @G_OPTION_ARG_CALLBACK: The option provides a callback (of type\n     #GOptionArgFunc) to parse the extra argument.\n @G_OPTION_ARG_FILENAME: The option takes a filename as argument, which will\nbe in the GLib filename encoding rather than UTF-8.\n @G_OPTION_ARG_STRING_ARRAY: The option takes a string argument, multiple\n     uses of the option are collected into an array of strings.\n @G_OPTION_ARG_FILENAME_ARRAY: The option takes a filename as argument,\n     multiple uses of the option are collected into an array of strings.\n @G_OPTION_ARG_DOUBLE: The option takes a double argument. The argument\n     can be formatted either for the user's locale or for the \"C\" locale.\n     Since 2.12\n @G_OPTION_ARG_INT64: The option takes a 64-bit integer. Like\n     %G_OPTION_ARG_INT but for larger numbers. The number can be in\n     decimal base, or in hexadecimal (when prefixed with `0x`, for\n     example, `0xffffffff`). Since 2.12\n\n The #GOptionArg enum values determine which type of extra argument the\n options expect to find. If an option expects an extra argument, it can\n be specified in several ways; with a short option: `-x arg`, with a long\n option: `--name arg` or combined in a single argument: `--name=arg`."]
pub type GOptionArg = ::std::os::raw::c_uint;
#[doc = " GOptionArgFunc:\n @option_name: The name of the option being parsed. This will be either a\n  single dash followed by a single letter (for a short name) or two dashes\n  followed by a long option name.\n @value: The value to be parsed.\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: A return location for errors. The error code %G_OPTION_ERROR_FAILED\n  is intended to be used for errors in #GOptionArgFunc callbacks.\n\n The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK\n options.\n\n Returns: %TRUE if the option was successfully parsed, %FALSE if an error\n  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionArgFunc = ::std::option::Option<
    unsafe extern "C" fn(
        option_name: *const gchar,
        value: *const gchar,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionParseFunc:\n @context: The active #GOptionContext\n @group: The group to which the function belongs\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: A return location for error details\n\n The type of function that can be called before and after parsing.\n\n Returns: %TRUE if the function completed successfully, %FALSE if an error\n  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionParseFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionErrorFunc:\n @context: The active #GOptionContext\n @group: The group to which the function belongs\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: The #GError containing details about the parse error\n\n The type of function to be used as callback when a parse error occurs."]
pub type GOptionErrorFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ),
>;
pub const G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = 0;
pub const G_OPTION_ERROR_BAD_VALUE: GOptionError = 1;
pub const G_OPTION_ERROR_FAILED: GOptionError = 2;
#[doc = " GOptionError:\n @G_OPTION_ERROR_UNKNOWN_OPTION: An option was not known to the parser.\n  This error will only be reported, if the parser hasn't been instructed\n  to ignore unknown options, see g_option_context_set_ignore_unknown_options().\n @G_OPTION_ERROR_BAD_VALUE: A value couldn't be parsed.\n @G_OPTION_ERROR_FAILED: A #GOptionArgFunc callback failed.\n\n Error codes returned by option parsing."]
pub type GOptionError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_option_error_quark() -> GQuark;
}
#[doc = " GOptionEntry:\n @long_name: The long name of an option can be used to specify it\n     in a commandline as `--long_name`. Every option must have a\n     long name. To resolve conflicts if multiple option groups contain\n     the same long name, it is also possible to specify the option as\n     `--groupname-long_name`.\n @short_name: If an option has a short name, it can be specified\n     `-short_name` in a commandline. @short_name must be  a printable\n     ASCII character different from '-', or zero if the option has no\n     short name.\n @flags: Flags from #GOptionFlags\n @arg: The type of the option, as a #GOptionArg\n @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data\n     must point to a #GOptionArgFunc callback function, which will be\n     called to handle the extra argument. Otherwise, @arg_data is a\n     pointer to a location to store the value, the required type of\n     the location depends on the @arg type:\n     - %G_OPTION_ARG_NONE: %gboolean\n     - %G_OPTION_ARG_STRING: %gchar*\n     - %G_OPTION_ARG_INT: %gint\n     - %G_OPTION_ARG_FILENAME: %gchar*\n     - %G_OPTION_ARG_STRING_ARRAY: %gchar**\n     - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**\n     - %G_OPTION_ARG_DOUBLE: %gdouble\n     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,\n     the location will contain a newly allocated string if the option\n     was given. That string needs to be freed by the callee using g_free().\n     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or\n     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().\n @description: the description for the option in `--help`\n     output. The @description is translated using the @translate_func\n     of the group, see g_option_group_set_translation_domain().\n @arg_description: The placeholder to use for the extra argument parsed\n     by the option in `--help` output. The @arg_description is translated\n     using the @translate_func of the group, see\n     g_option_group_set_translation_domain().\n\n A GOptionEntry struct defines a single option. To have an effect, they\n must be added to a #GOptionGroup with g_option_context_add_main_entries()\n or g_option_group_add_entries()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GOptionEntry"][::std::mem::size_of::<_GOptionEntry>() - 48usize];
    ["Alignment of _GOptionEntry"][::std::mem::align_of::<_GOptionEntry>() - 8usize];
    ["Offset of field: _GOptionEntry::long_name"]
        [::std::mem::offset_of!(_GOptionEntry, long_name) - 0usize];
    ["Offset of field: _GOptionEntry::short_name"]
        [::std::mem::offset_of!(_GOptionEntry, short_name) - 8usize];
    ["Offset of field: _GOptionEntry::flags"]
        [::std::mem::offset_of!(_GOptionEntry, flags) - 12usize];
    ["Offset of field: _GOptionEntry::arg"][::std::mem::offset_of!(_GOptionEntry, arg) - 16usize];
    ["Offset of field: _GOptionEntry::arg_data"]
        [::std::mem::offset_of!(_GOptionEntry, arg_data) - 24usize];
    ["Offset of field: _GOptionEntry::description"]
        [::std::mem::offset_of!(_GOptionEntry, description) - 32usize];
    ["Offset of field: _GOptionEntry::arg_description"]
        [::std::mem::offset_of!(_GOptionEntry, arg_description) - 40usize];
};
unsafe extern "C" {
    pub fn g_option_context_new(parameter_string: *const gchar) -> *mut GOptionContext;
}
unsafe extern "C" {
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const gchar);
}
unsafe extern "C" {
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_option_context_set_description(
        context: *mut GOptionContext,
        description: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_option_context_free(context: *mut GOptionContext);
}
unsafe extern "C" {
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
}
unsafe extern "C" {
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_set_ignore_unknown_options(
        context: *mut GOptionContext,
        ignore_unknown: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
}
unsafe extern "C" {
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_add_main_entries(
        context: *mut GOptionContext,
        entries: *const GOptionEntry,
        translation_domain: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_option_context_parse(
        context: *mut GOptionContext,
        argc: *mut gint,
        argv: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_parse_strv(
        context: *mut GOptionContext,
        arguments: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_set_translate_func(
        context: *mut GOptionContext,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_option_context_set_translation_domain(
        context: *mut GOptionContext,
        domain: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
unsafe extern "C" {
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
unsafe extern "C" {
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
}
unsafe extern "C" {
    pub fn g_option_context_get_help(
        context: *mut GOptionContext,
        main_help: gboolean,
        group: *mut GOptionGroup,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_option_group_new(
        name: *const gchar,
        description: *const gchar,
        help_description: *const gchar,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> *mut GOptionGroup;
}
unsafe extern "C" {
    pub fn g_option_group_set_parse_hooks(
        group: *mut GOptionGroup,
        pre_parse_func: GOptionParseFunc,
        post_parse_func: GOptionParseFunc,
    );
}
unsafe extern "C" {
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
}
unsafe extern "C" {
    pub fn g_option_group_free(group: *mut GOptionGroup);
}
unsafe extern "C" {
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
}
unsafe extern "C" {
    pub fn g_option_group_unref(group: *mut GOptionGroup);
}
unsafe extern "C" {
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
}
unsafe extern "C" {
    pub fn g_option_group_set_translate_func(
        group: *mut GOptionGroup,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPatternSpec {
    _unused: [u8; 0],
}
pub type GPatternSpec = _GPatternSpec;
unsafe extern "C" {
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
}
unsafe extern "C" {
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
}
unsafe extern "C" {
    pub fn g_pattern_spec_copy(pspec: *mut GPatternSpec) -> *mut GPatternSpec;
}
unsafe extern "C" {
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_spec_match(
        pspec: *mut GPatternSpec,
        string_length: gsize,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_spec_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_match(
        pspec: *mut GPatternSpec,
        string_length: guint,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spaced_primes_closest(num: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_qsort_with_data(
        pbase: gconstpointer,
        total_elems: gint,
        size: gsize,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
#[doc = " GQueue:\n @head: a pointer to the first element of the queue\n @tail: a pointer to the last element of the queue\n @length: the number of elements in the queue\n\n Contains the public fields of a\n [Queue][glib-Double-ended-Queues]."]
pub type GQueue = _GQueue;
#[doc = " GQueue:\n @head: a pointer to the first element of the queue\n @tail: a pointer to the last element of the queue\n @length: the number of elements in the queue\n\n Contains the public fields of a\n [Queue][glib-Double-ended-Queues]."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GQueue"][::std::mem::size_of::<_GQueue>() - 24usize];
    ["Alignment of _GQueue"][::std::mem::align_of::<_GQueue>() - 8usize];
    ["Offset of field: _GQueue::head"][::std::mem::offset_of!(_GQueue, head) - 0usize];
    ["Offset of field: _GQueue::tail"][::std::mem::offset_of!(_GQueue, tail) - 8usize];
    ["Offset of field: _GQueue::length"][::std::mem::offset_of!(_GQueue, length) - 16usize];
};
unsafe extern "C" {
    pub fn g_queue_new() -> *mut GQueue;
}
unsafe extern "C" {
    pub fn g_queue_free(queue: *mut GQueue);
}
unsafe extern "C" {
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_queue_init(queue: *mut GQueue);
}
unsafe extern "C" {
    pub fn g_queue_clear(queue: *mut GQueue);
}
unsafe extern "C" {
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_queue_clear_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
}
unsafe extern "C" {
    pub fn g_queue_reverse(queue: *mut GQueue);
}
unsafe extern "C" {
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
}
unsafe extern "C" {
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_find_custom(
        queue: *mut GQueue,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
}
unsafe extern "C" {
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_insert_before_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_insert_after_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_insert_sorted(
        queue: *mut GQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
}
unsafe extern "C" {
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRand {
    _unused: [u8; 0],
}
pub type GRand = _GRand;
unsafe extern "C" {
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
}
unsafe extern "C" {
    pub fn g_rand_new_with_seed_array(seed: *const guint32, seed_length: guint) -> *mut GRand;
}
unsafe extern "C" {
    pub fn g_rand_new() -> *mut GRand;
}
unsafe extern "C" {
    pub fn g_rand_free(rand_: *mut GRand);
}
unsafe extern "C" {
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
}
unsafe extern "C" {
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
}
unsafe extern "C" {
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32, seed_length: guint);
}
unsafe extern "C" {
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
}
unsafe extern "C" {
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32) -> gint32;
}
unsafe extern "C" {
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
}
unsafe extern "C" {
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble, end: gdouble) -> gdouble;
}
unsafe extern "C" {
    pub fn g_random_set_seed(seed: guint32);
}
unsafe extern "C" {
    pub fn g_random_int() -> guint32;
}
unsafe extern "C" {
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
}
unsafe extern "C" {
    pub fn g_random_double() -> gdouble;
}
unsafe extern "C" {
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
}
unsafe extern "C" {
    pub fn g_rc_box_alloc(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_rc_box_alloc0(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_rc_box_release(mem_block: gpointer);
}
unsafe extern "C" {
    pub fn g_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_rc_box_get_size(mem_block: gpointer) -> gsize;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_alloc(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_alloc0(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_release(mem_block: gpointer);
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_get_size(mem_block: gpointer) -> gsize;
}
unsafe extern "C" {
    pub fn g_ref_count_init(rc: *mut grefcount);
}
unsafe extern "C" {
    pub fn g_ref_count_inc(rc: *mut grefcount);
}
unsafe extern "C" {
    pub fn g_ref_count_dec(rc: *mut grefcount) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ref_count_compare(rc: *mut grefcount, val: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_ref_count_init(arc: *mut gatomicrefcount);
}
unsafe extern "C" {
    pub fn g_atomic_ref_count_inc(arc: *mut gatomicrefcount);
}
unsafe extern "C" {
    pub fn g_atomic_ref_count_dec(arc: *mut gatomicrefcount) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_ref_count_compare(arc: *mut gatomicrefcount, val: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ref_string_new(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_ref_string_new_len(
        str_: *const ::std::os::raw::c_char,
        len: gssize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_ref_string_new_intern(
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_ref_string_acquire(str_: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_ref_string_release(str_: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_ref_string_length(str_: *mut ::std::os::raw::c_char) -> gsize;
}
#[doc = " GRefString:\n\n A typedef for a reference-counted string. A pointer to a #GRefString can be\n treated like a standard `char*` array by all code, but can additionally have\n `g_ref_string_*()` methods called on it. `g_ref_string_*()` methods cannot be\n called on `char*` arrays not allocated using g_ref_string_new().\n\n If using #GRefString with autocleanups, g_autoptr() must be used rather than\n g_autofree(), so that the reference counting metadata is also freed.\n\n Since: 2.58"]
pub type GRefString = ::std::os::raw::c_char;
pub const G_REGEX_ERROR_COMPILE: GRegexError = 0;
pub const G_REGEX_ERROR_OPTIMIZE: GRegexError = 1;
pub const G_REGEX_ERROR_REPLACE: GRegexError = 2;
pub const G_REGEX_ERROR_MATCH: GRegexError = 3;
pub const G_REGEX_ERROR_INTERNAL: GRegexError = 4;
pub const G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = 101;
pub const G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = 102;
pub const G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = 103;
pub const G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = 104;
pub const G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = 105;
pub const G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = 106;
pub const G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = 107;
pub const G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = 108;
pub const G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = 109;
pub const G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = 112;
pub const G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = 113;
pub const G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = 114;
pub const G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = 115;
pub const G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = 118;
pub const G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = 120;
pub const G_REGEX_ERROR_MEMORY_ERROR: GRegexError = 121;
pub const G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = 125;
pub const G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = 126;
pub const G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = 127;
pub const G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = 128;
pub const G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = 130;
pub const G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = 131;
pub const G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = 134;
pub const G_REGEX_ERROR_INVALID_CONDITION: GRegexError = 135;
pub const G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = 136;
pub const G_REGEX_ERROR_INFINITE_LOOP: GRegexError = 140;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = 142;
pub const G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = 143;
pub const G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = 146;
pub const G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = 147;
pub const G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = 148;
pub const G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = 149;
pub const G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = 151;
pub const G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = 154;
pub const G_REGEX_ERROR_DEFINE_REPETION: GRegexError = 155;
pub const G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = 156;
pub const G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = 157;
pub const G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = 158;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = 159;
pub const G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = 160;
pub const G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = 161;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = 162;
pub const G_REGEX_ERROR_MISSING_DIGIT: GRegexError = 163;
pub const G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = 164;
pub const G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = 165;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = 166;
pub const G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = 168;
pub const G_REGEX_ERROR_MISSING_NAME: GRegexError = 169;
pub const G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = 171;
pub const G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = 172;
pub const G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = 175;
pub const G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = 176;
#[doc = " GRegexError:\n @G_REGEX_ERROR_COMPILE: Compilation of the regular expression failed.\n @G_REGEX_ERROR_OPTIMIZE: Optimization of the regular expression failed.\n @G_REGEX_ERROR_REPLACE: Replacement failed due to an ill-formed replacement\n     string.\n @G_REGEX_ERROR_MATCH: The match process failed.\n @G_REGEX_ERROR_INTERNAL: Internal error of the regular expression engine.\n     Since 2.16\n @G_REGEX_ERROR_STRAY_BACKSLASH: \"\\\\\" at end of pattern. Since 2.16\n @G_REGEX_ERROR_MISSING_CONTROL_CHAR: \"\\\\c\" at end of pattern. Since 2.16\n @G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: Unrecognized character follows \"\\\\\".\n     Since 2.16\n @G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: Numbers out of order in \"{}\"\n     quantifier. Since 2.16\n @G_REGEX_ERROR_QUANTIFIER_TOO_BIG: Number too big in \"{}\" quantifier.\n     Since 2.16\n @G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: Missing terminating \"]\" for\n     character class. Since 2.16\n @G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: Invalid escape sequence\n     in character class. Since 2.16\n @G_REGEX_ERROR_RANGE_OUT_OF_ORDER: Range out of order in character class.\n     Since 2.16\n @G_REGEX_ERROR_NOTHING_TO_REPEAT: Nothing to repeat. Since 2.16\n @G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: Unrecognized character after \"(?\",\n     \"(?<\" or \"(?P\". Since 2.16\n @G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: POSIX named classes are\n     supported only within a class. Since 2.16\n @G_REGEX_ERROR_UNMATCHED_PARENTHESIS: Missing terminating \")\" or \")\"\n     without opening \"(\". Since 2.16\n @G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: Reference to non-existent\n     subpattern. Since 2.16\n @G_REGEX_ERROR_UNTERMINATED_COMMENT: Missing terminating \")\" after comment.\n     Since 2.16\n @G_REGEX_ERROR_EXPRESSION_TOO_LARGE: Regular expression too large.\n     Since 2.16\n @G_REGEX_ERROR_MEMORY_ERROR: Failed to get memory. Since 2.16\n @G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: Lookbehind assertion is not\n     fixed length. Since 2.16\n @G_REGEX_ERROR_MALFORMED_CONDITION: Malformed number or name after \"(?(\".\n     Since 2.16\n @G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: Conditional group contains\n     more than two branches. Since 2.16\n @G_REGEX_ERROR_ASSERTION_EXPECTED: Assertion expected after \"(?(\".\n     Since 2.16\n @G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: Unknown POSIX class name.\n     Since 2.16\n @G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: POSIX collating\n     elements are not supported. Since 2.16\n @G_REGEX_ERROR_HEX_CODE_TOO_LARGE: Character value in \"\\\\x{...}\" sequence\n     is too large. Since 2.16\n @G_REGEX_ERROR_INVALID_CONDITION: Invalid condition \"(?(0)\". Since 2.16\n @G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: \\\\C not allowed in\n     lookbehind assertion. Since 2.16\n @G_REGEX_ERROR_INFINITE_LOOP: Recursive call could loop indefinitely.\n     Since 2.16\n @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: Missing terminator\n     in subpattern name. Since 2.16\n @G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: Two named subpatterns have\n     the same name. Since 2.16\n @G_REGEX_ERROR_MALFORMED_PROPERTY: Malformed \"\\\\P\" or \"\\\\p\" sequence.\n     Since 2.16\n @G_REGEX_ERROR_UNKNOWN_PROPERTY: Unknown property name after \"\\\\P\" or\n     \"\\\\p\". Since 2.16\n @G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: Subpattern name is too long\n     (maximum 32 characters). Since 2.16\n @G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: Too many named subpatterns (maximum\n     10,000). Since 2.16\n @G_REGEX_ERROR_INVALID_OCTAL_VALUE: Octal value is greater than \"\\\\377\".\n     Since 2.16\n @G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: \"DEFINE\" group contains more\n     than one branch. Since 2.16\n @G_REGEX_ERROR_DEFINE_REPETION: Repeating a \"DEFINE\" group is not allowed.\n     This error is never raised. Since: 2.16 Deprecated: 2.34\n @G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: Inconsistent newline options.\n     Since 2.16\n @G_REGEX_ERROR_MISSING_BACK_REFERENCE: \"\\\\g\" is not followed by a braced,\n      angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16\n @G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: relative reference must not be zero. Since: 2.34\n @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: the backtracing\n     control verb used does not allow an argument. Since: 2.34\n @G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: unknown backtracing\n     control verb. Since: 2.34\n @G_REGEX_ERROR_NUMBER_TOO_BIG: number is too big in escape sequence. Since: 2.34\n @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: Missing subpattern name. Since: 2.34\n @G_REGEX_ERROR_MISSING_DIGIT: Missing digit. Since 2.34\n @G_REGEX_ERROR_INVALID_DATA_CHARACTER: In JavaScript compatibility mode,\n     \"[\" is an invalid data character. Since: 2.34\n @G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: different names for subpatterns of the\n     same number are not allowed. Since: 2.34\n @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: the backtracing control\n     verb requires an argument. Since: 2.34\n @G_REGEX_ERROR_INVALID_CONTROL_CHAR: \"\\\\c\" must be followed by an ASCII\n     character. Since: 2.34\n @G_REGEX_ERROR_MISSING_NAME: \"\\\\k\" is not followed by a braced, angle-bracketed, or\n     quoted name. Since: 2.34\n @G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: \"\\\\N\" is not supported in a class. Since: 2.34\n @G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: too many forward references. Since: 2.34\n @G_REGEX_ERROR_NAME_TOO_LONG: the name is too long in \"(*MARK)\", \"(*PRUNE)\",\n     \"(*SKIP)\", or \"(*THEN)\". Since: 2.34\n @G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: the character value in the \\\\u sequence is\n     too large. Since: 2.34\n\n Error codes returned by regular expressions functions.\n\n Since: 2.14"]
pub type GRegexError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_regex_error_quark() -> GQuark;
}
pub const G_REGEX_CASELESS: GRegexCompileFlags = 1;
pub const G_REGEX_MULTILINE: GRegexCompileFlags = 2;
pub const G_REGEX_DOTALL: GRegexCompileFlags = 4;
pub const G_REGEX_EXTENDED: GRegexCompileFlags = 8;
pub const G_REGEX_ANCHORED: GRegexCompileFlags = 16;
pub const G_REGEX_DOLLAR_ENDONLY: GRegexCompileFlags = 32;
pub const G_REGEX_UNGREEDY: GRegexCompileFlags = 512;
pub const G_REGEX_RAW: GRegexCompileFlags = 2048;
pub const G_REGEX_NO_AUTO_CAPTURE: GRegexCompileFlags = 4096;
pub const G_REGEX_OPTIMIZE: GRegexCompileFlags = 8192;
pub const G_REGEX_FIRSTLINE: GRegexCompileFlags = 262144;
pub const G_REGEX_DUPNAMES: GRegexCompileFlags = 524288;
pub const G_REGEX_NEWLINE_CR: GRegexCompileFlags = 1048576;
pub const G_REGEX_NEWLINE_LF: GRegexCompileFlags = 2097152;
pub const G_REGEX_NEWLINE_CRLF: GRegexCompileFlags = 3145728;
pub const G_REGEX_NEWLINE_ANYCRLF: GRegexCompileFlags = 5242880;
pub const G_REGEX_BSR_ANYCRLF: GRegexCompileFlags = 8388608;
pub const G_REGEX_JAVASCRIPT_COMPAT: GRegexCompileFlags = 33554432;
#[doc = " GRegexCompileFlags:\n @G_REGEX_CASELESS: Letters in the pattern match both upper- and\n     lowercase letters. This option can be changed within a pattern\n     by a \"(?i)\" option setting.\n @G_REGEX_MULTILINE: By default, GRegex treats the strings as consisting\n     of a single line of characters (even if it actually contains\n     newlines). The \"start of line\" metacharacter (\"^\") matches only\n     at the start of the string, while the \"end of line\" metacharacter\n     (\"$\") matches only at the end of the string, or before a terminating\n     newline (unless %G_REGEX_DOLLAR_ENDONLY is set). When\n     %G_REGEX_MULTILINE is set, the \"start of line\" and \"end of line\"\n     constructs match immediately following or immediately before any\n     newline in the string, respectively, as well as at the very start\n     and end. This can be changed within a pattern by a \"(?m)\" option\n     setting.\n @G_REGEX_DOTALL: A dot metacharacter (\".\") in the pattern matches all\n     characters, including newlines. Without it, newlines are excluded.\n     This option can be changed within a pattern by a (\"?s\") option setting.\n @G_REGEX_EXTENDED: Whitespace data characters in the pattern are\n     totally ignored except when escaped or inside a character class.\n     Whitespace does not include the VT character (code 11). In addition,\n     characters between an unescaped \"#\" outside a character class and\n     the next newline character, inclusive, are also ignored. This can\n     be changed within a pattern by a \"(?x)\" option setting.\n @G_REGEX_ANCHORED: The pattern is forced to be \"anchored\", that is,\n     it is constrained to match only at the first matching point in the\n     string that is being searched. This effect can also be achieved by\n     appropriate constructs in the pattern itself such as the \"^\"\n     metacharacter.\n @G_REGEX_DOLLAR_ENDONLY: A dollar metacharacter (\"$\") in the pattern\n     matches only at the end of the string. Without this option, a\n     dollar also matches immediately before the final character if\n     it is a newline (but not before any other newlines). This option\n     is ignored if %G_REGEX_MULTILINE is set.\n @G_REGEX_UNGREEDY: Inverts the \"greediness\" of the quantifiers so that\n     they are not greedy by default, but become greedy if followed by \"?\".\n     It can also be set by a \"(?U)\" option setting within the pattern.\n @G_REGEX_RAW: Usually strings must be valid UTF-8 strings, using this\n     flag they are considered as a raw sequence of bytes.\n @G_REGEX_NO_AUTO_CAPTURE: Disables the use of numbered capturing\n     parentheses in the pattern. Any opening parenthesis that is not\n     followed by \"?\" behaves as if it were followed by \"?:\" but named\n     parentheses can still be used for capturing (and they acquire numbers\n     in the usual way).\n @G_REGEX_OPTIMIZE: Optimize the regular expression. If the pattern will\n     be used many times, then it may be worth the effort to optimize it\n     to improve the speed of matches.\n @G_REGEX_FIRSTLINE: Limits an unanchored pattern to match before (or at) the\n     first newline. Since: 2.34\n @G_REGEX_DUPNAMES: Names used to identify capturing subpatterns need not\n     be unique. This can be helpful for certain types of pattern when it\n     is known that only one instance of the named subpattern can ever be\n     matched.\n @G_REGEX_NEWLINE_CR: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     is '\\r'.\n @G_REGEX_NEWLINE_LF: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     is '\\n'.\n @G_REGEX_NEWLINE_CRLF: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     sequence is '\\r\\n'.\n @G_REGEX_NEWLINE_ANYCRLF: Usually any newline character or character sequence\n     is recognized. If this option is set, the only recognized newline character\n     sequences are '\\r', '\\n', and '\\r\\n'. Since: 2.34\n @G_REGEX_BSR_ANYCRLF: Usually any newline character or character sequence\n     is recognised. If this option is set, then \"\\R\" only recognizes the newline\n    characters '\\r', '\\n' and '\\r\\n'. Since: 2.34\n @G_REGEX_JAVASCRIPT_COMPAT: Changes behaviour so that it is compatible with\n     JavaScript rather than PCRE. Since: 2.34\n\n Flags specifying compile-time options.\n\n Since: 2.14"]
pub type GRegexCompileFlags = ::std::os::raw::c_uint;
pub const G_REGEX_MATCH_ANCHORED: GRegexMatchFlags = 16;
pub const G_REGEX_MATCH_NOTBOL: GRegexMatchFlags = 128;
pub const G_REGEX_MATCH_NOTEOL: GRegexMatchFlags = 256;
pub const G_REGEX_MATCH_NOTEMPTY: GRegexMatchFlags = 1024;
pub const G_REGEX_MATCH_PARTIAL: GRegexMatchFlags = 32768;
pub const G_REGEX_MATCH_NEWLINE_CR: GRegexMatchFlags = 1048576;
pub const G_REGEX_MATCH_NEWLINE_LF: GRegexMatchFlags = 2097152;
pub const G_REGEX_MATCH_NEWLINE_CRLF: GRegexMatchFlags = 3145728;
pub const G_REGEX_MATCH_NEWLINE_ANY: GRegexMatchFlags = 4194304;
pub const G_REGEX_MATCH_NEWLINE_ANYCRLF: GRegexMatchFlags = 5242880;
pub const G_REGEX_MATCH_BSR_ANYCRLF: GRegexMatchFlags = 8388608;
pub const G_REGEX_MATCH_BSR_ANY: GRegexMatchFlags = 16777216;
pub const G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags = 32768;
pub const G_REGEX_MATCH_PARTIAL_HARD: GRegexMatchFlags = 134217728;
pub const G_REGEX_MATCH_NOTEMPTY_ATSTART: GRegexMatchFlags = 268435456;
#[doc = " GRegexMatchFlags:\n @G_REGEX_MATCH_ANCHORED: The pattern is forced to be \"anchored\", that is,\n     it is constrained to match only at the first matching point in the\n     string that is being searched. This effect can also be achieved by\n     appropriate constructs in the pattern itself such as the \"^\"\n     metacharacter.\n @G_REGEX_MATCH_NOTBOL: Specifies that first character of the string is\n     not the beginning of a line, so the circumflex metacharacter should\n     not match before it. Setting this without %G_REGEX_MULTILINE (at\n     compile time) causes circumflex never to match. This option affects\n     only the behaviour of the circumflex metacharacter, it does not\n     affect \"\\A\".\n @G_REGEX_MATCH_NOTEOL: Specifies that the end of the subject string is\n     not the end of a line, so the dollar metacharacter should not match\n     it nor (except in multiline mode) a newline immediately before it.\n     Setting this without %G_REGEX_MULTILINE (at compile time) causes\n     dollar never to match. This option affects only the behaviour of\n     the dollar metacharacter, it does not affect \"\\Z\" or \"\\z\".\n @G_REGEX_MATCH_NOTEMPTY: An empty string is not considered to be a valid\n     match if this option is set. If there are alternatives in the pattern,\n     they are tried. If all the alternatives match the empty string, the\n     entire match fails. For example, if the pattern \"a?b?\" is applied to\n     a string not beginning with \"a\" or \"b\", it matches the empty string\n     at the start of the string. With this flag set, this match is not\n     valid, so GRegex searches further into the string for occurrences\n     of \"a\" or \"b\".\n @G_REGEX_MATCH_PARTIAL: Turns on the partial matching feature, for more\n     documentation on partial matching see g_match_info_is_partial_match().\n @G_REGEX_MATCH_NEWLINE_CR: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\r' character as line terminator.\n @G_REGEX_MATCH_NEWLINE_LF: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\n' character as line terminator.\n @G_REGEX_MATCH_NEWLINE_CRLF: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\r\\n' characters sequence as line terminator.\n @G_REGEX_MATCH_NEWLINE_ANY: Overrides the newline definition set when\n     creating a new #GRegex, any Unicode newline sequence\n     is recognised as a newline. These are '\\r', '\\n' and '\\rn', and the\n     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),\n     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and\n     U+2029 PARAGRAPH SEPARATOR.\n @G_REGEX_MATCH_NEWLINE_ANYCRLF: Overrides the newline definition set when\n     creating a new #GRegex; any '\\r', '\\n', or '\\r\\n' character sequence\n     is recognized as a newline. Since: 2.34\n @G_REGEX_MATCH_BSR_ANYCRLF: Overrides the newline definition for \"\\R\" set when\n     creating a new #GRegex; only '\\r', '\\n', or '\\r\\n' character sequences\n     are recognized as a newline by \"\\R\". Since: 2.34\n @G_REGEX_MATCH_BSR_ANY: Overrides the newline definition for \"\\R\" set when\n     creating a new #GRegex; any Unicode newline character or character sequence\n     are recognized as a newline by \"\\R\". These are '\\r', '\\n' and '\\rn', and the\n     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),\n     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and\n     U+2029 PARAGRAPH SEPARATOR. Since: 2.34\n @G_REGEX_MATCH_PARTIAL_SOFT: An alias for %G_REGEX_MATCH_PARTIAL. Since: 2.34\n @G_REGEX_MATCH_PARTIAL_HARD: Turns on the partial matching feature. In contrast to\n     to %G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match\n     is found, without continuing to search for a possible complete match. See\n     g_match_info_is_partial_match() for more information. Since: 2.34\n @G_REGEX_MATCH_NOTEMPTY_ATSTART: Like %G_REGEX_MATCH_NOTEMPTY, but only applied to\n     the start of the matched string. For anchored\n     patterns this can only happen for pattern containing \"\\K\". Since: 2.34\n\n Flags specifying match-time options.\n\n Since: 2.14"]
pub type GRegexMatchFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRegex {
    _unused: [u8; 0],
}
#[doc = " GRegex:\n\n A GRegex is the \"compiled\" form of a regular expression pattern.\n This structure is opaque and its fields cannot be accessed directly.\n\n Since: 2.14"]
pub type GRegex = _GRegex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMatchInfo {
    _unused: [u8; 0],
}
#[doc = " GMatchInfo:\n\n A GMatchInfo is an opaque struct used to return information about\n matches."]
pub type GMatchInfo = _GMatchInfo;
#[doc = " GRegexEvalCallback:\n @match_info: the #GMatchInfo generated by the match.\n     Use g_match_info_get_regex() and g_match_info_get_string() if you\n     need the #GRegex or the matched string.\n @result: a #GString containing the new string\n @user_data: user data passed to g_regex_replace_eval()\n\n Specifies the type of the function passed to g_regex_replace_eval().\n It is called for each occurrence of the pattern in the string passed\n to g_regex_replace_eval(), and it should append the replacement to\n @result.\n\n Returns: %FALSE to continue the replacement process, %TRUE to stop it\n\n Since: 2.14"]
pub type GRegexEvalCallback = ::std::option::Option<
    unsafe extern "C" fn(
        match_info: *const GMatchInfo,
        result: *mut GString,
        user_data: gpointer,
    ) -> gboolean,
>;
unsafe extern "C" {
    pub fn g_regex_new(
        pattern: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut GRegex;
}
unsafe extern "C" {
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
}
unsafe extern "C" {
    pub fn g_regex_unref(regex: *mut GRegex);
}
unsafe extern "C" {
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
}
unsafe extern "C" {
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
}
unsafe extern "C" {
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
}
unsafe extern "C" {
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_regex_escape_string(string: *const gchar, length: gint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_escape_nul(string: *const gchar, length: gint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
}
unsafe extern "C" {
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
}
unsafe extern "C" {
    pub fn g_regex_match_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_match(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_match_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_match_all(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_match_all_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_split_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_split(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_split_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        max_tokens: gint,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_replace(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_replace_literal(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_replace_eval(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        eval: GRegexEvalCallback,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_check_replacement(
        replacement: *const gchar,
        has_references: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
}
unsafe extern "C" {
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
}
unsafe extern "C" {
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
}
unsafe extern "C" {
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
}
unsafe extern "C" {
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> gint;
}
unsafe extern "C" {
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_expand_references(
        match_info: *const GMatchInfo,
        string_to_expand: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_match_info_fetch_pos(
        match_info: *const GMatchInfo,
        match_num: gint,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_fetch_named(
        match_info: *const GMatchInfo,
        name: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_match_info_fetch_named_pos(
        match_info: *const GMatchInfo,
        name: *const gchar,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut gchar;
}
pub type GScanner = _GScanner;
pub type GScannerConfig = _GScannerConfig;
pub type GTokenValue = _GTokenValue;
pub type GScannerMsgFunc = ::std::option::Option<
    unsafe extern "C" fn(scanner: *mut GScanner, message: *mut gchar, error: gboolean),
>;
pub const G_ERR_UNKNOWN: GErrorType = 0;
pub const G_ERR_UNEXP_EOF: GErrorType = 1;
pub const G_ERR_UNEXP_EOF_IN_STRING: GErrorType = 2;
pub const G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = 3;
pub const G_ERR_NON_DIGIT_IN_CONST: GErrorType = 4;
pub const G_ERR_DIGIT_RADIX: GErrorType = 5;
pub const G_ERR_FLOAT_RADIX: GErrorType = 6;
pub const G_ERR_FLOAT_MALFORMED: GErrorType = 7;
pub type GErrorType = ::std::os::raw::c_uint;
pub const G_TOKEN_EOF: GTokenType = 0;
pub const G_TOKEN_LEFT_PAREN: GTokenType = 40;
pub const G_TOKEN_RIGHT_PAREN: GTokenType = 41;
pub const G_TOKEN_LEFT_CURLY: GTokenType = 123;
pub const G_TOKEN_RIGHT_CURLY: GTokenType = 125;
pub const G_TOKEN_LEFT_BRACE: GTokenType = 91;
pub const G_TOKEN_RIGHT_BRACE: GTokenType = 93;
pub const G_TOKEN_EQUAL_SIGN: GTokenType = 61;
pub const G_TOKEN_COMMA: GTokenType = 44;
pub const G_TOKEN_NONE: GTokenType = 256;
pub const G_TOKEN_ERROR: GTokenType = 257;
pub const G_TOKEN_CHAR: GTokenType = 258;
pub const G_TOKEN_BINARY: GTokenType = 259;
pub const G_TOKEN_OCTAL: GTokenType = 260;
pub const G_TOKEN_INT: GTokenType = 261;
pub const G_TOKEN_HEX: GTokenType = 262;
pub const G_TOKEN_FLOAT: GTokenType = 263;
pub const G_TOKEN_STRING: GTokenType = 264;
pub const G_TOKEN_SYMBOL: GTokenType = 265;
pub const G_TOKEN_IDENTIFIER: GTokenType = 266;
pub const G_TOKEN_IDENTIFIER_NULL: GTokenType = 267;
pub const G_TOKEN_COMMENT_SINGLE: GTokenType = 268;
pub const G_TOKEN_COMMENT_MULTI: GTokenType = 269;
pub const G_TOKEN_LAST: GTokenType = 270;
pub type GTokenType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GTokenValue {
    pub v_symbol: gpointer,
    pub v_identifier: *mut gchar,
    pub v_binary: gulong,
    pub v_octal: gulong,
    pub v_int: gulong,
    pub v_int64: guint64,
    pub v_float: gdouble,
    pub v_hex: gulong,
    pub v_string: *mut gchar,
    pub v_comment: *mut gchar,
    pub v_char: guchar,
    pub v_error: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTokenValue"][::std::mem::size_of::<_GTokenValue>() - 8usize];
    ["Alignment of _GTokenValue"][::std::mem::align_of::<_GTokenValue>() - 8usize];
    ["Offset of field: _GTokenValue::v_symbol"]
        [::std::mem::offset_of!(_GTokenValue, v_symbol) - 0usize];
    ["Offset of field: _GTokenValue::v_identifier"]
        [::std::mem::offset_of!(_GTokenValue, v_identifier) - 0usize];
    ["Offset of field: _GTokenValue::v_binary"]
        [::std::mem::offset_of!(_GTokenValue, v_binary) - 0usize];
    ["Offset of field: _GTokenValue::v_octal"]
        [::std::mem::offset_of!(_GTokenValue, v_octal) - 0usize];
    ["Offset of field: _GTokenValue::v_int"][::std::mem::offset_of!(_GTokenValue, v_int) - 0usize];
    ["Offset of field: _GTokenValue::v_int64"]
        [::std::mem::offset_of!(_GTokenValue, v_int64) - 0usize];
    ["Offset of field: _GTokenValue::v_float"]
        [::std::mem::offset_of!(_GTokenValue, v_float) - 0usize];
    ["Offset of field: _GTokenValue::v_hex"][::std::mem::offset_of!(_GTokenValue, v_hex) - 0usize];
    ["Offset of field: _GTokenValue::v_string"]
        [::std::mem::offset_of!(_GTokenValue, v_string) - 0usize];
    ["Offset of field: _GTokenValue::v_comment"]
        [::std::mem::offset_of!(_GTokenValue, v_comment) - 0usize];
    ["Offset of field: _GTokenValue::v_char"]
        [::std::mem::offset_of!(_GTokenValue, v_char) - 0usize];
    ["Offset of field: _GTokenValue::v_error"]
        [::std::mem::offset_of!(_GTokenValue, v_error) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub padding_dummy: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GScannerConfig"][::std::mem::size_of::<_GScannerConfig>() - 40usize];
    ["Alignment of _GScannerConfig"][::std::mem::align_of::<_GScannerConfig>() - 8usize];
    ["Offset of field: _GScannerConfig::cset_skip_characters"]
        [::std::mem::offset_of!(_GScannerConfig, cset_skip_characters) - 0usize];
    ["Offset of field: _GScannerConfig::cset_identifier_first"]
        [::std::mem::offset_of!(_GScannerConfig, cset_identifier_first) - 8usize];
    ["Offset of field: _GScannerConfig::cset_identifier_nth"]
        [::std::mem::offset_of!(_GScannerConfig, cset_identifier_nth) - 16usize];
    ["Offset of field: _GScannerConfig::cpair_comment_single"]
        [::std::mem::offset_of!(_GScannerConfig, cpair_comment_single) - 24usize];
    ["Offset of field: _GScannerConfig::padding_dummy"]
        [::std::mem::offset_of!(_GScannerConfig, padding_dummy) - 36usize];
};
impl _GScannerConfig {
    #[inline]
    pub fn case_sensitive(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_case_sensitive(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn case_sensitive_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_case_sensitive_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_comment_multi_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_comment_multi_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_comment_single(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_single(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_comment_single_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_comment_single_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_comment_multi_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_comment_multi_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_identifier(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_identifier_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_identifier_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_identifier_1char(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_1char(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_identifier_1char_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_identifier_1char_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_identifier_NULL(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_NULL(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_identifier_NULL_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_identifier_NULL_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_symbols(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_symbols(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_symbols_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_symbols_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_binary(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_binary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_binary_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_binary_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_octal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_octal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_octal_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_octal_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_float_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_float_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_hex(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_hex_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_hex_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_hex_dollar(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex_dollar(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_hex_dollar_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_hex_dollar_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_string_sq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_sq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_string_sq_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_string_sq_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_string_dq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_dq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_string_dq_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_string_dq_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numbers_2_int(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_numbers_2_int(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numbers_2_int_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numbers_2_int_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn int_2_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_int_2_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn int_2_float_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_int_2_float_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn identifier_2_string(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_identifier_2_string(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn identifier_2_string_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_identifier_2_string_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn char_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_char_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn char_2_token_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_char_2_token_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn symbol_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_symbol_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn symbol_2_token_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_symbol_2_token_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scope_0_fallback(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scope_0_fallback(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scope_0_fallback_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scope_0_fallback_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn store_int64(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store_int64(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn store_int64_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_store_int64_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        case_sensitive: guint,
        skip_comment_multi: guint,
        skip_comment_single: guint,
        scan_comment_multi: guint,
        scan_identifier: guint,
        scan_identifier_1char: guint,
        scan_identifier_NULL: guint,
        scan_symbols: guint,
        scan_binary: guint,
        scan_octal: guint,
        scan_float: guint,
        scan_hex: guint,
        scan_hex_dollar: guint,
        scan_string_sq: guint,
        scan_string_dq: guint,
        numbers_2_int: guint,
        int_2_float: guint,
        identifier_2_string: guint,
        char_2_token: guint,
        symbol_2_token: guint,
        scope_0_fallback: guint,
        store_int64: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let case_sensitive: u32 = unsafe { ::std::mem::transmute(case_sensitive) };
            case_sensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip_comment_multi: u32 = unsafe { ::std::mem::transmute(skip_comment_multi) };
            skip_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skip_comment_single: u32 = unsafe { ::std::mem::transmute(skip_comment_single) };
            skip_comment_single as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_comment_multi: u32 = unsafe { ::std::mem::transmute(scan_comment_multi) };
            scan_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_identifier: u32 = unsafe { ::std::mem::transmute(scan_identifier) };
            scan_identifier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scan_identifier_1char: u32 =
                unsafe { ::std::mem::transmute(scan_identifier_1char) };
            scan_identifier_1char as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scan_identifier_NULL: u32 = unsafe { ::std::mem::transmute(scan_identifier_NULL) };
            scan_identifier_NULL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let scan_symbols: u32 = unsafe { ::std::mem::transmute(scan_symbols) };
            scan_symbols as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let scan_binary: u32 = unsafe { ::std::mem::transmute(scan_binary) };
            scan_binary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scan_octal: u32 = unsafe { ::std::mem::transmute(scan_octal) };
            scan_octal as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let scan_float: u32 = unsafe { ::std::mem::transmute(scan_float) };
            scan_float as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let scan_hex: u32 = unsafe { ::std::mem::transmute(scan_hex) };
            scan_hex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let scan_hex_dollar: u32 = unsafe { ::std::mem::transmute(scan_hex_dollar) };
            scan_hex_dollar as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let scan_string_sq: u32 = unsafe { ::std::mem::transmute(scan_string_sq) };
            scan_string_sq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scan_string_dq: u32 = unsafe { ::std::mem::transmute(scan_string_dq) };
            scan_string_dq as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let numbers_2_int: u32 = unsafe { ::std::mem::transmute(numbers_2_int) };
            numbers_2_int as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let int_2_float: u32 = unsafe { ::std::mem::transmute(int_2_float) };
            int_2_float as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let identifier_2_string: u32 = unsafe { ::std::mem::transmute(identifier_2_string) };
            identifier_2_string as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let char_2_token: u32 = unsafe { ::std::mem::transmute(char_2_token) };
            char_2_token as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let symbol_2_token: u32 = unsafe { ::std::mem::transmute(symbol_2_token) };
            symbol_2_token as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scope_0_fallback: u32 = unsafe { ::std::mem::transmute(scope_0_fallback) };
            scope_0_fallback as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let store_int64: u32 = unsafe { ::std::mem::transmute(store_int64) };
            store_int64 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GScanner"][::std::mem::size_of::<_GScanner>() - 144usize];
    ["Alignment of _GScanner"][::std::mem::align_of::<_GScanner>() - 8usize];
    ["Offset of field: _GScanner::user_data"]
        [::std::mem::offset_of!(_GScanner, user_data) - 0usize];
    ["Offset of field: _GScanner::max_parse_errors"]
        [::std::mem::offset_of!(_GScanner, max_parse_errors) - 8usize];
    ["Offset of field: _GScanner::parse_errors"]
        [::std::mem::offset_of!(_GScanner, parse_errors) - 12usize];
    ["Offset of field: _GScanner::input_name"]
        [::std::mem::offset_of!(_GScanner, input_name) - 16usize];
    ["Offset of field: _GScanner::qdata"][::std::mem::offset_of!(_GScanner, qdata) - 24usize];
    ["Offset of field: _GScanner::config"][::std::mem::offset_of!(_GScanner, config) - 32usize];
    ["Offset of field: _GScanner::token"][::std::mem::offset_of!(_GScanner, token) - 40usize];
    ["Offset of field: _GScanner::value"][::std::mem::offset_of!(_GScanner, value) - 48usize];
    ["Offset of field: _GScanner::line"][::std::mem::offset_of!(_GScanner, line) - 56usize];
    ["Offset of field: _GScanner::position"][::std::mem::offset_of!(_GScanner, position) - 60usize];
    ["Offset of field: _GScanner::next_token"]
        [::std::mem::offset_of!(_GScanner, next_token) - 64usize];
    ["Offset of field: _GScanner::next_value"]
        [::std::mem::offset_of!(_GScanner, next_value) - 72usize];
    ["Offset of field: _GScanner::next_line"]
        [::std::mem::offset_of!(_GScanner, next_line) - 80usize];
    ["Offset of field: _GScanner::next_position"]
        [::std::mem::offset_of!(_GScanner, next_position) - 84usize];
    ["Offset of field: _GScanner::symbol_table"]
        [::std::mem::offset_of!(_GScanner, symbol_table) - 88usize];
    ["Offset of field: _GScanner::input_fd"][::std::mem::offset_of!(_GScanner, input_fd) - 96usize];
    ["Offset of field: _GScanner::text"][::std::mem::offset_of!(_GScanner, text) - 104usize];
    ["Offset of field: _GScanner::text_end"]
        [::std::mem::offset_of!(_GScanner, text_end) - 112usize];
    ["Offset of field: _GScanner::buffer"][::std::mem::offset_of!(_GScanner, buffer) - 120usize];
    ["Offset of field: _GScanner::scope_id"]
        [::std::mem::offset_of!(_GScanner, scope_id) - 128usize];
    ["Offset of field: _GScanner::msg_handler"]
        [::std::mem::offset_of!(_GScanner, msg_handler) - 136usize];
};
unsafe extern "C" {
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;
}
unsafe extern "C" {
    pub fn g_scanner_destroy(scanner: *mut GScanner);
}
unsafe extern "C" {
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
}
unsafe extern "C" {
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
}
unsafe extern "C" {
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar, text_len: guint);
}
unsafe extern "C" {
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
}
unsafe extern "C" {
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
}
unsafe extern "C" {
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
}
unsafe extern "C" {
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
}
unsafe extern "C" {
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
}
unsafe extern "C" {
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
}
unsafe extern "C" {
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
}
unsafe extern "C" {
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_scanner_scope_add_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
        value: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_scanner_scope_remove_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_scanner_scope_lookup_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_scanner_scope_foreach_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        func: GHFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const gchar) -> gpointer;
}
unsafe extern "C" {
    pub fn g_scanner_unexp_token(
        scanner: *mut GScanner,
        expected_token: GTokenType,
        identifier_spec: *const gchar,
        symbol_spec: *const gchar,
        symbol_name: *const gchar,
        message: *const gchar,
        is_error: gint,
    );
}
unsafe extern "C" {
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequence {
    _unused: [u8; 0],
}
pub type GSequence = _GSequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequenceNode {
    _unused: [u8; 0],
}
pub type GSequenceIter = _GSequenceNode;
pub type GSequenceIterCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(a: *mut GSequenceIter, b: *mut GSequenceIter, data: gpointer) -> gint,
>;
unsafe extern "C" {
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
}
unsafe extern "C" {
    pub fn g_sequence_free(seq: *mut GSequence);
}
unsafe extern "C" {
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
}
unsafe extern "C" {
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_sequence_foreach_range(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
        func: GFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
}
unsafe extern "C" {
    pub fn g_sequence_sort_iter(
        seq: *mut GSequence,
        cmp_func: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
}
unsafe extern "C" {
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
        -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
}
unsafe extern "C" {
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
}
unsafe extern "C" {
    pub fn g_sequence_insert_sorted(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_insert_sorted_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_sort_changed(
        iter: *mut GSequenceIter,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_sequence_sort_changed_iter(
        iter: *mut GSequenceIter,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
}
unsafe extern "C" {
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
}
unsafe extern "C" {
    pub fn g_sequence_move_range(
        dest: *mut GSequenceIter,
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    );
}
unsafe extern "C" {
    pub fn g_sequence_search(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_search_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_lookup(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_lookup_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
}
unsafe extern "C" {
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
}
unsafe extern "C" {
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
}
unsafe extern "C" {
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
}
unsafe extern "C" {
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
}
unsafe extern "C" {
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
}
unsafe extern "C" {
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> gint;
}
unsafe extern "C" {
    pub fn g_sequence_range_get_midpoint(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    ) -> *mut GSequenceIter;
}
pub const G_SHELL_ERROR_BAD_QUOTING: GShellError = 0;
pub const G_SHELL_ERROR_EMPTY_STRING: GShellError = 1;
pub const G_SHELL_ERROR_FAILED: GShellError = 2;
pub type GShellError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_shell_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_shell_unquote(quoted_string: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_shell_parse_argv(
        command_line: *const gchar,
        argcp: *mut gint,
        argvp: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
}
unsafe extern "C" {
    pub fn g_slice_free_chain_with_offset(
        block_size: gsize,
        mem_chain: gpointer,
        next_offset: gsize,
    );
}
pub const G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = 1;
pub const G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = 2;
pub const G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = 3;
pub const G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = 4;
pub const G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = 5;
pub const G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = 6;
pub type GSliceConfig = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
}
unsafe extern "C" {
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
}
unsafe extern "C" {
    pub fn g_slice_get_config_state(
        ckey: GSliceConfig,
        address: gint64,
        n_values: *mut guint,
    ) -> *mut gint64;
}
pub const G_SPAWN_ERROR_FORK: GSpawnError = 0;
pub const G_SPAWN_ERROR_READ: GSpawnError = 1;
pub const G_SPAWN_ERROR_CHDIR: GSpawnError = 2;
pub const G_SPAWN_ERROR_ACCES: GSpawnError = 3;
pub const G_SPAWN_ERROR_PERM: GSpawnError = 4;
pub const G_SPAWN_ERROR_TOO_BIG: GSpawnError = 5;
pub const G_SPAWN_ERROR_2BIG: GSpawnError = 5;
pub const G_SPAWN_ERROR_NOEXEC: GSpawnError = 6;
pub const G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = 7;
pub const G_SPAWN_ERROR_NOENT: GSpawnError = 8;
pub const G_SPAWN_ERROR_NOMEM: GSpawnError = 9;
pub const G_SPAWN_ERROR_NOTDIR: GSpawnError = 10;
pub const G_SPAWN_ERROR_LOOP: GSpawnError = 11;
pub const G_SPAWN_ERROR_TXTBUSY: GSpawnError = 12;
pub const G_SPAWN_ERROR_IO: GSpawnError = 13;
pub const G_SPAWN_ERROR_NFILE: GSpawnError = 14;
pub const G_SPAWN_ERROR_MFILE: GSpawnError = 15;
pub const G_SPAWN_ERROR_INVAL: GSpawnError = 16;
pub const G_SPAWN_ERROR_ISDIR: GSpawnError = 17;
pub const G_SPAWN_ERROR_LIBBAD: GSpawnError = 18;
pub const G_SPAWN_ERROR_FAILED: GSpawnError = 19;
#[doc = " GSpawnError:\n @G_SPAWN_ERROR_FORK: Fork failed due to lack of memory.\n @G_SPAWN_ERROR_READ: Read or select on pipes failed.\n @G_SPAWN_ERROR_CHDIR: Changing to working directory failed.\n @G_SPAWN_ERROR_ACCES: execv() returned `EACCES`\n @G_SPAWN_ERROR_PERM: execv() returned `EPERM`\n @G_SPAWN_ERROR_TOO_BIG: execv() returned `E2BIG`\n @G_SPAWN_ERROR_2BIG: deprecated alias for %G_SPAWN_ERROR_TOO_BIG (deprecated since GLib 2.32)\n @G_SPAWN_ERROR_NOEXEC: execv() returned `ENOEXEC`\n @G_SPAWN_ERROR_NAMETOOLONG: execv() returned `ENAMETOOLONG`\n @G_SPAWN_ERROR_NOENT: execv() returned `ENOENT`\n @G_SPAWN_ERROR_NOMEM: execv() returned `ENOMEM`\n @G_SPAWN_ERROR_NOTDIR: execv() returned `ENOTDIR`\n @G_SPAWN_ERROR_LOOP: execv() returned `ELOOP`\n @G_SPAWN_ERROR_TXTBUSY: execv() returned `ETXTBUSY`\n @G_SPAWN_ERROR_IO: execv() returned `EIO`\n @G_SPAWN_ERROR_NFILE: execv() returned `ENFILE`\n @G_SPAWN_ERROR_MFILE: execv() returned `EMFILE`\n @G_SPAWN_ERROR_INVAL: execv() returned `EINVAL`\n @G_SPAWN_ERROR_ISDIR: execv() returned `EISDIR`\n @G_SPAWN_ERROR_LIBBAD: execv() returned `ELIBBAD`\n @G_SPAWN_ERROR_FAILED: Some other fatal failure,\n   `error->message` should explain.\n\n Error codes returned by spawning processes."]
pub type GSpawnError = ::std::os::raw::c_uint;
#[doc = " GSpawnChildSetupFunc:\n @user_data: (closure): user data to pass to the function.\n\n Specifies the type of the setup function passed to g_spawn_async(),\n g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very\n limited ways, be used to affect the child's execution.\n\n On POSIX platforms, the function is called in the child after GLib\n has performed all the setup it plans to perform, but before calling\n exec(). Actions taken in this function will only affect the child,\n not the parent.\n\n On Windows, the function is called in the parent. Its usefulness on\n Windows is thus questionable. In many cases executing the child setup\n function in the parent can have ill effects, and you should be very\n careful when porting software to Windows that uses child setup\n functions.\n\n However, even on POSIX, you are extremely limited in what you can\n safely do from a #GSpawnChildSetupFunc, because any mutexes that were\n held by other threads in the parent process at the time of the fork()\n will still be locked in the child process, and they will never be\n unlocked (since the threads that held them don't exist in the child).\n POSIX allows only async-signal-safe functions (see signal(7)) to be\n called in the child between fork() and exec(), which drastically limits\n the usefulness of child setup functions.\n\n In particular, it is not safe to call any function which may\n call malloc(), which includes POSIX functions such as setenv().\n If you need to set up the child environment differently from\n the parent, you should use g_get_environ(), g_environ_setenv(),\n and g_environ_unsetenv(), and then pass the complete environment\n list to the `g_spawn...` function."]
pub type GSpawnChildSetupFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
pub const G_SPAWN_DEFAULT: GSpawnFlags = 0;
pub const G_SPAWN_LEAVE_DESCRIPTORS_OPEN: GSpawnFlags = 1;
pub const G_SPAWN_DO_NOT_REAP_CHILD: GSpawnFlags = 2;
pub const G_SPAWN_SEARCH_PATH: GSpawnFlags = 4;
pub const G_SPAWN_STDOUT_TO_DEV_NULL: GSpawnFlags = 8;
pub const G_SPAWN_STDERR_TO_DEV_NULL: GSpawnFlags = 16;
pub const G_SPAWN_CHILD_INHERITS_STDIN: GSpawnFlags = 32;
pub const G_SPAWN_FILE_AND_ARGV_ZERO: GSpawnFlags = 64;
pub const G_SPAWN_SEARCH_PATH_FROM_ENVP: GSpawnFlags = 128;
pub const G_SPAWN_CLOEXEC_PIPES: GSpawnFlags = 256;
#[doc = " GSpawnFlags:\n @G_SPAWN_DEFAULT: no flags, default behaviour\n @G_SPAWN_LEAVE_DESCRIPTORS_OPEN: the parent's open file descriptors will\n     be inherited by the child; otherwise all descriptors except stdin,\n     stdout and stderr will be closed before calling exec() in the child.\n @G_SPAWN_DO_NOT_REAP_CHILD: the child will not be automatically reaped;\n     you must use g_child_watch_add() yourself (or call waitpid() or handle\n     `SIGCHLD` yourself), or the child will become a zombie.\n @G_SPAWN_SEARCH_PATH: `argv[0]` need not be an absolute path, it will be\n     looked for in the user's `PATH`.\n @G_SPAWN_STDOUT_TO_DEV_NULL: the child's standard output will be discarded,\n     instead of going to the same location as the parent's standard output.\n @G_SPAWN_STDERR_TO_DEV_NULL: the child's standard error will be discarded.\n @G_SPAWN_CHILD_INHERITS_STDIN: the child will inherit the parent's standard\n     input (by default, the child's standard input is attached to `/dev/null`).\n @G_SPAWN_FILE_AND_ARGV_ZERO: the first element of `argv` is the file to\n     execute, while the remaining elements are the actual argument vector\n     to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`\n     as the file to execute, and passes all of `argv` to the child.\n @G_SPAWN_SEARCH_PATH_FROM_ENVP: if `argv[0]` is not an absolute path,\n     it will be looked for in the `PATH` from the passed child environment.\n     Since: 2.34\n @G_SPAWN_CLOEXEC_PIPES: create all pipes with the `O_CLOEXEC` flag set.\n     Since: 2.40\n\n Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes()."]
pub type GSpawnFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_spawn_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_spawn_exit_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_spawn_async(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_async_with_pipes(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut gint,
        standard_output: *mut gint,
        standard_error: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_async_with_pipes_and_fds(
        working_directory: *const gchar,
        argv: *const *const gchar,
        envp: *const *const gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        source_fds: *const gint,
        target_fds: *const gint,
        n_fds: gsize,
        child_pid_out: *mut GPid,
        stdin_pipe_out: *mut gint,
        stdout_pipe_out: *mut gint,
        stderr_pipe_out: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_async_with_fds(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_sync(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        wait_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_command_line_sync(
        command_line: *const gchar,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        wait_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_command_line_async(
        command_line: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_check_wait_status(wait_status: gint, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_check_exit_status(wait_status: gint, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_close_pid(pid: GPid);
}
pub const G_ASCII_ALNUM: GAsciiType = 1;
pub const G_ASCII_ALPHA: GAsciiType = 2;
pub const G_ASCII_CNTRL: GAsciiType = 4;
pub const G_ASCII_DIGIT: GAsciiType = 8;
pub const G_ASCII_GRAPH: GAsciiType = 16;
pub const G_ASCII_LOWER: GAsciiType = 32;
pub const G_ASCII_PRINT: GAsciiType = 64;
pub const G_ASCII_PUNCT: GAsciiType = 128;
pub const G_ASCII_SPACE: GAsciiType = 256;
pub const G_ASCII_UPPER: GAsciiType = 512;
pub const G_ASCII_XDIGIT: GAsciiType = 1024;
pub type GAsciiType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static g_ascii_table: *const guint16;
}
unsafe extern "C" {
    pub fn g_ascii_tolower(c: gchar) -> gchar;
}
unsafe extern "C" {
    pub fn g_ascii_toupper(c: gchar) -> gchar;
}
unsafe extern "C" {
    pub fn g_ascii_digit_value(c: gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_strdelimit(
        string: *mut gchar,
        delimiters: *const gchar,
        new_delimiter: gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strcanon(
        string: *mut gchar,
        valid_chars: *const gchar,
        substitutor: gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strerror(errnum: gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_strsignal(signum: gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
unsafe extern "C" {
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
unsafe extern "C" {
    pub fn g_strstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strrstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_has_suffix(str_: *const gchar, suffix: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_str_has_prefix(str_: *const gchar, prefix: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
unsafe extern "C" {
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
unsafe extern "C" {
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> guint64;
}
unsafe extern "C" {
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> gint64;
}
unsafe extern "C" {
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_ascii_formatd(
        buffer: *mut gchar,
        buf_len: gint,
        format: *const gchar,
        d: gdouble,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize) -> gint;
}
unsafe extern "C" {
    pub fn g_ascii_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_ascii_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_is_ascii(str_: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint) -> gint;
}
unsafe extern "C" {
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strdup(str_: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strdup_vprintf(format: *const gchar, args: *mut __va_list_tag) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strndup(str_: *const gchar, n: gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_memdup2(mem: gconstpointer, byte_size: gsize) -> gpointer;
}
pub type GStrv = *mut *mut gchar;
unsafe extern "C" {
    pub fn g_strsplit(
        string: *const gchar,
        delimiter: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_strsplit_set(
        string: *const gchar,
        delimiters: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strfreev(str_array: *mut *mut gchar);
}
unsafe extern "C" {
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
}
unsafe extern "C" {
    pub fn g_stpcpy(dest: *mut gchar, src: *const ::std::os::raw::c_char) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_to_ascii(str_: *const gchar, from_locale: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_tokenize_and_fold(
        string: *const gchar,
        translit_locale: *const gchar,
        ascii_alternates: *mut *mut *mut gchar,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_match_string(
        search_term: *const gchar,
        potential_hit: *const gchar,
        accept_alternates: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_strv_contains(strv: *const *const gchar, str_: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_strv_equal(strv1: *const *const gchar, strv2: *const *const gchar) -> gboolean;
}
pub const G_NUMBER_PARSER_ERROR_INVALID: GNumberParserError = 0;
pub const G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: GNumberParserError = 1;
#[doc = " GNumberParserError:\n @G_NUMBER_PARSER_ERROR_INVALID: String was not a valid number.\n @G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: String was a number, but out of bounds.\n\n Error codes returned by functions converting a string to a number.\n\n Since: 2.54"]
pub type GNumberParserError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_number_parser_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_ascii_string_to_signed(
        str_: *const gchar,
        base: guint,
        min: gint64,
        max: gint64,
        out_num: *mut gint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ascii_string_to_unsigned(
        str_: *const gchar,
        base: guint,
        min: guint64,
        max: guint64,
        out_num: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStringChunk {
    _unused: [u8; 0],
}
pub type GStringChunk = _GStringChunk;
unsafe extern "C" {
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
}
unsafe extern "C" {
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
}
unsafe extern "C" {
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
}
unsafe extern "C" {
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_string_chunk_insert_len(
        chunk: *mut GStringChunk,
        string: *const gchar,
        len: gssize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_string_chunk_insert_const(
        chunk: *mut GStringChunk,
        string: *const gchar,
    ) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStrvBuilder {
    _unused: [u8; 0],
}
#[doc = " GStrvBuilder:\n\n A helper object to build a %NULL-terminated string array\n by appending. See g_strv_builder_new().\n\n Since: 2.68"]
pub type GStrvBuilder = _GStrvBuilder;
unsafe extern "C" {
    pub fn g_strv_builder_new() -> *mut GStrvBuilder;
}
unsafe extern "C" {
    pub fn g_strv_builder_unref(builder: *mut GStrvBuilder);
}
unsafe extern "C" {
    pub fn g_strv_builder_ref(builder: *mut GStrvBuilder) -> *mut GStrvBuilder;
}
unsafe extern "C" {
    pub fn g_strv_builder_add(builder: *mut GStrvBuilder, value: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_strv_builder_addv(
        builder: *mut GStrvBuilder,
        value: *mut *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_strv_builder_add_many(builder: *mut GStrvBuilder, ...);
}
unsafe extern "C" {
    pub fn g_strv_builder_end(builder: *mut GStrvBuilder) -> GStrv;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestCase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestSuite {
    _unused: [u8; 0],
}
pub type GTestFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type GTestDataFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc =
    ::std::option::Option<unsafe extern "C" fn(fixture: gpointer, user_data: gconstpointer)>;
unsafe extern "C" {
    pub fn g_strcmp0(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_test_minimized_result(
        minimized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn g_test_maximized_result(
        maximized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn g_test_init(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn g_test_subprocess() -> gboolean;
}
unsafe extern "C" {
    pub fn g_test_run() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_test_add_func(testpath: *const ::std::os::raw::c_char, test_func: GTestFunc);
}
unsafe extern "C" {
    pub fn g_test_add_data_func(
        testpath: *const ::std::os::raw::c_char,
        test_data: gconstpointer,
        test_func: GTestDataFunc,
    );
}
unsafe extern "C" {
    pub fn g_test_add_data_func_full(
        testpath: *const ::std::os::raw::c_char,
        test_data: gpointer,
        test_func: GTestDataFunc,
        data_free_func: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_test_get_path() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_test_fail();
}
unsafe extern "C" {
    pub fn g_test_fail_printf(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn g_test_incomplete(msg: *const gchar);
}
unsafe extern "C" {
    pub fn g_test_incomplete_printf(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn g_test_skip(msg: *const gchar);
}
unsafe extern "C" {
    pub fn g_test_skip_printf(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn g_test_failed() -> gboolean;
}
unsafe extern "C" {
    pub fn g_test_set_nonfatal_assertions();
}
unsafe extern "C" {
    pub fn g_test_message(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn g_test_bug_base(uri_pattern: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_test_bug(bug_uri_snippet: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_test_summary(summary: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_test_timer_start();
}
unsafe extern "C" {
    pub fn g_test_timer_elapsed() -> f64;
}
unsafe extern "C" {
    pub fn g_test_timer_last() -> f64;
}
unsafe extern "C" {
    pub fn g_test_queue_free(gfree_pointer: gpointer);
}
unsafe extern "C" {
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
}
pub const G_TEST_TRAP_SILENCE_STDOUT: GTestTrapFlags = 128;
pub const G_TEST_TRAP_SILENCE_STDERR: GTestTrapFlags = 256;
pub const G_TEST_TRAP_INHERIT_STDIN: GTestTrapFlags = 512;
#[doc = " GTestTrapFlags:\n @G_TEST_TRAP_SILENCE_STDOUT: Redirect stdout of the test child to\n     `/dev/null` so it cannot be observed on the console during test\n     runs. The actual output is still captured though to allow later\n     tests with g_test_trap_assert_stdout().\n @G_TEST_TRAP_SILENCE_STDERR: Redirect stderr of the test child to\n     `/dev/null` so it cannot be observed on the console during test\n     runs. The actual output is still captured though to allow later\n     tests with g_test_trap_assert_stderr().\n @G_TEST_TRAP_INHERIT_STDIN: If this flag is given, stdin of the\n     child process is shared with stdin of its parent process.\n     It is redirected to `/dev/null` otherwise.\n\n Test traps are guards around forked tests.\n These flags determine what traps to set.\n\n Deprecated: 2.38: #GTestTrapFlags is used only with g_test_trap_fork(),\n which is deprecated. g_test_trap_subprocess() uses\n #GTestSubprocessFlags."]
pub type GTestTrapFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) -> gboolean;
}
pub const G_TEST_SUBPROCESS_INHERIT_STDIN: GTestSubprocessFlags = 1;
pub const G_TEST_SUBPROCESS_INHERIT_STDOUT: GTestSubprocessFlags = 2;
pub const G_TEST_SUBPROCESS_INHERIT_STDERR: GTestSubprocessFlags = 4;
pub type GTestSubprocessFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_test_trap_subprocess(
        test_path: *const ::std::os::raw::c_char,
        usec_timeout: guint64,
        test_flags: GTestSubprocessFlags,
    );
}
unsafe extern "C" {
    pub fn g_test_trap_has_passed() -> gboolean;
}
unsafe extern "C" {
    pub fn g_test_trap_reached_timeout() -> gboolean;
}
unsafe extern "C" {
    pub fn g_test_rand_int() -> gint32;
}
unsafe extern "C" {
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
}
unsafe extern "C" {
    pub fn g_test_rand_double() -> f64;
}
unsafe extern "C" {
    pub fn g_test_rand_double_range(range_start: f64, range_end: f64) -> f64;
}
unsafe extern "C" {
    pub fn g_test_create_case(
        test_name: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    ) -> *mut GTestCase;
}
unsafe extern "C" {
    pub fn g_test_create_suite(suite_name: *const ::std::os::raw::c_char) -> *mut GTestSuite;
}
unsafe extern "C" {
    pub fn g_test_get_root() -> *mut GTestSuite;
}
unsafe extern "C" {
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
}
unsafe extern "C" {
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
}
unsafe extern "C" {
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_test_case_free(test_case: *mut GTestCase);
}
unsafe extern "C" {
    pub fn g_test_suite_free(suite: *mut GTestSuite);
}
unsafe extern "C" {
    pub fn g_test_trap_assertions(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        assertion_flags: guint64,
        pattern: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message_expr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn g_assertion_message_cmpstr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        cmp: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message_cmpstrv(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const *const ::std::os::raw::c_char,
        arg2: *const *const ::std::os::raw::c_char,
        first_wrong_idx: gsize,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message_cmpnum(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: u128,
        cmp: *const ::std::os::raw::c_char,
        arg2: u128,
        numtype: ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message_error(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        error: *const GError,
        error_domain: GQuark,
        error_code: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn g_test_add_vtable(
        testpath: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GTestConfig"][::std::mem::size_of::<GTestConfig>() - 24usize];
    ["Alignment of GTestConfig"][::std::mem::align_of::<GTestConfig>() - 4usize];
    ["Offset of field: GTestConfig::test_initialized"]
        [::std::mem::offset_of!(GTestConfig, test_initialized) - 0usize];
    ["Offset of field: GTestConfig::test_quick"]
        [::std::mem::offset_of!(GTestConfig, test_quick) - 4usize];
    ["Offset of field: GTestConfig::test_perf"]
        [::std::mem::offset_of!(GTestConfig, test_perf) - 8usize];
    ["Offset of field: GTestConfig::test_verbose"]
        [::std::mem::offset_of!(GTestConfig, test_verbose) - 12usize];
    ["Offset of field: GTestConfig::test_quiet"]
        [::std::mem::offset_of!(GTestConfig, test_quiet) - 16usize];
    ["Offset of field: GTestConfig::test_undefined"]
        [::std::mem::offset_of!(GTestConfig, test_undefined) - 20usize];
};
unsafe extern "C" {
    pub static g_test_config_vars: *const GTestConfig;
}
pub const G_TEST_RUN_SUCCESS: GTestResult = 0;
pub const G_TEST_RUN_SKIPPED: GTestResult = 1;
pub const G_TEST_RUN_FAILURE: GTestResult = 2;
pub const G_TEST_RUN_INCOMPLETE: GTestResult = 3;
pub type GTestResult = ::std::os::raw::c_uint;
pub const G_TEST_LOG_NONE: GTestLogType = 0;
pub const G_TEST_LOG_ERROR: GTestLogType = 1;
pub const G_TEST_LOG_START_BINARY: GTestLogType = 2;
pub const G_TEST_LOG_LIST_CASE: GTestLogType = 3;
pub const G_TEST_LOG_SKIP_CASE: GTestLogType = 4;
pub const G_TEST_LOG_START_CASE: GTestLogType = 5;
pub const G_TEST_LOG_STOP_CASE: GTestLogType = 6;
pub const G_TEST_LOG_MIN_RESULT: GTestLogType = 7;
pub const G_TEST_LOG_MAX_RESULT: GTestLogType = 8;
pub const G_TEST_LOG_MESSAGE: GTestLogType = 9;
pub const G_TEST_LOG_START_SUITE: GTestLogType = 10;
pub const G_TEST_LOG_STOP_SUITE: GTestLogType = 11;
pub type GTestLogType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GTestLogMsg"][::std::mem::size_of::<GTestLogMsg>() - 32usize];
    ["Alignment of GTestLogMsg"][::std::mem::align_of::<GTestLogMsg>() - 8usize];
    ["Offset of field: GTestLogMsg::log_type"]
        [::std::mem::offset_of!(GTestLogMsg, log_type) - 0usize];
    ["Offset of field: GTestLogMsg::n_strings"]
        [::std::mem::offset_of!(GTestLogMsg, n_strings) - 4usize];
    ["Offset of field: GTestLogMsg::strings"]
        [::std::mem::offset_of!(GTestLogMsg, strings) - 8usize];
    ["Offset of field: GTestLogMsg::n_nums"][::std::mem::offset_of!(GTestLogMsg, n_nums) - 16usize];
    ["Offset of field: GTestLogMsg::nums"][::std::mem::offset_of!(GTestLogMsg, nums) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GTestLogBuffer"][::std::mem::size_of::<GTestLogBuffer>() - 16usize];
    ["Alignment of GTestLogBuffer"][::std::mem::align_of::<GTestLogBuffer>() - 8usize];
    ["Offset of field: GTestLogBuffer::data"]
        [::std::mem::offset_of!(GTestLogBuffer, data) - 0usize];
    ["Offset of field: GTestLogBuffer::msgs"]
        [::std::mem::offset_of!(GTestLogBuffer, msgs) - 8usize];
};
unsafe extern "C" {
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
}
unsafe extern "C" {
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
}
unsafe extern "C" {
    pub fn g_test_log_buffer_push(
        tbuffer: *mut GTestLogBuffer,
        n_bytes: guint,
        bytes: *const guint8,
    );
}
unsafe extern "C" {
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
}
unsafe extern "C" {
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
}
#[doc = " GTestLogFatalFunc:\n @log_domain: the log domain of the message\n @log_level: the log level of the message (including the fatal and recursion flags)\n @message: the message to process\n @user_data: user data, set in g_test_log_set_fatal_handler()\n\n Specifies the prototype of fatal log handler functions.\n\n Returns: %TRUE if the program should abort, %FALSE otherwise\n\n Since: 2.22"]
pub type GTestLogFatalFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ) -> gboolean,
>;
unsafe extern "C" {
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_test_expect_message(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        pattern: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_test_assert_expected_messages_internal(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
pub const G_TEST_DIST: GTestFileType = 0;
pub const G_TEST_BUILT: GTestFileType = 1;
pub type GTestFileType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_test_build_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_test_get_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *const gchar;
}
pub type GThreadPool = _GThreadPool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GThreadPool"][::std::mem::size_of::<_GThreadPool>() - 24usize];
    ["Alignment of _GThreadPool"][::std::mem::align_of::<_GThreadPool>() - 8usize];
    ["Offset of field: _GThreadPool::func"][::std::mem::offset_of!(_GThreadPool, func) - 0usize];
    ["Offset of field: _GThreadPool::user_data"]
        [::std::mem::offset_of!(_GThreadPool, user_data) - 8usize];
    ["Offset of field: _GThreadPool::exclusive"]
        [::std::mem::offset_of!(_GThreadPool, exclusive) - 16usize];
};
unsafe extern "C" {
    pub fn g_thread_pool_new(
        func: GFunc,
        user_data: gpointer,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
unsafe extern "C" {
    pub fn g_thread_pool_new_full(
        func: GFunc,
        user_data: gpointer,
        item_free_func: GDestroyNotify,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
unsafe extern "C" {
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
}
unsafe extern "C" {
    pub fn g_thread_pool_push(
        pool: *mut GThreadPool,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
}
unsafe extern "C" {
    pub fn g_thread_pool_set_sort_function(
        pool: *mut GThreadPool,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_thread_pool_set_max_threads(
        pool: *mut GThreadPool,
        max_threads: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
}
unsafe extern "C" {
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
}
unsafe extern "C" {
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
}
unsafe extern "C" {
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
}
unsafe extern "C" {
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
}
unsafe extern "C" {
    pub fn g_thread_pool_stop_unused_threads();
}
unsafe extern "C" {
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
}
unsafe extern "C" {
    pub fn g_thread_pool_get_max_idle_time() -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
unsafe extern "C" {
    pub fn g_timer_new() -> *mut GTimer;
}
unsafe extern "C" {
    pub fn g_timer_destroy(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_start(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_stop(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_reset(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_continue(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong) -> gdouble;
}
unsafe extern "C" {
    pub fn g_timer_is_active(timer: *mut GTimer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_usleep(microseconds: gulong);
}
unsafe extern "C" {
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
}
unsafe extern "C" {
    pub fn g_time_val_from_iso8601(iso_date: *const gchar, time_: *mut GTimeVal) -> gboolean;
}
unsafe extern "C" {
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
}
pub type GTrashStack = _GTrashStack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTrashStack {
    pub next: *mut GTrashStack,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTrashStack"][::std::mem::size_of::<_GTrashStack>() - 8usize];
    ["Alignment of _GTrashStack"][::std::mem::align_of::<_GTrashStack>() - 8usize];
    ["Offset of field: _GTrashStack::next"][::std::mem::offset_of!(_GTrashStack, next) - 0usize];
};
unsafe extern "C" {
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);
}
unsafe extern "C" {
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
}
unsafe extern "C" {
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
}
unsafe extern "C" {
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTree {
    _unused: [u8; 0],
}
pub type GTree = _GTree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTreeNode {
    _unused: [u8; 0],
}
#[doc = " GTreeNode:\n\n An opaque type which identifies a specific node in a #GTree.\n\n Since: 2.68"]
pub type GTreeNode = _GTreeNode;
pub type GTraverseFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, data: gpointer) -> gboolean,
>;
#[doc = " GTraverseNodeFunc:\n @node: a #GTreeNode\n @data: user data passed to g_tree_foreach_node()\n\n Specifies the type of function passed to g_tree_foreach_node(). It is\n passed each node, together with the @user_data parameter passed to\n g_tree_foreach_node(). If the function returns %TRUE, the traversal is\n stopped.\n\n Returns: %TRUE to stop the traversal\n Since: 2.68"]
pub type GTraverseNodeFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GTreeNode, data: gpointer) -> gboolean>;
unsafe extern "C" {
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
}
unsafe extern "C" {
    pub fn g_tree_new_with_data(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
    ) -> *mut GTree;
}
unsafe extern "C" {
    pub fn g_tree_new_full(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GTree;
}
unsafe extern "C" {
    pub fn g_tree_node_first(tree: *mut GTree) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_node_last(tree: *mut GTree) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_node_previous(node: *mut GTreeNode) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_node_next(node: *mut GTreeNode) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
}
unsafe extern "C" {
    pub fn g_tree_unref(tree: *mut GTree);
}
unsafe extern "C" {
    pub fn g_tree_destroy(tree: *mut GTree);
}
unsafe extern "C" {
    pub fn g_tree_insert_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
}
unsafe extern "C" {
    pub fn g_tree_replace_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
}
unsafe extern "C" {
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tree_remove_all(tree: *mut GTree);
}
unsafe extern "C" {
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tree_node_key(node: *mut GTreeNode) -> gpointer;
}
unsafe extern "C" {
    pub fn g_tree_node_value(node: *mut GTreeNode) -> gpointer;
}
unsafe extern "C" {
    pub fn g_tree_lookup_node(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_tree_lookup_extended(
        tree: *mut GTree,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_tree_foreach_node(tree: *mut GTree, func: GTraverseNodeFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_tree_traverse(
        tree: *mut GTree,
        traverse_func: GTraverseFunc,
        traverse_type: GTraverseType,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_tree_search_node(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_search(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_tree_lower_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_upper_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_height(tree: *mut GTree) -> gint;
}
unsafe extern "C" {
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUri {
    _unused: [u8; 0],
}
pub type GUri = _GUri;
unsafe extern "C" {
    pub fn g_uri_ref(uri: *mut GUri) -> *mut GUri;
}
unsafe extern "C" {
    pub fn g_uri_unref(uri: *mut GUri);
}
pub const G_URI_FLAGS_NONE: GUriFlags = 0;
pub const G_URI_FLAGS_PARSE_RELAXED: GUriFlags = 1;
pub const G_URI_FLAGS_HAS_PASSWORD: GUriFlags = 2;
pub const G_URI_FLAGS_HAS_AUTH_PARAMS: GUriFlags = 4;
pub const G_URI_FLAGS_ENCODED: GUriFlags = 8;
pub const G_URI_FLAGS_NON_DNS: GUriFlags = 16;
pub const G_URI_FLAGS_ENCODED_QUERY: GUriFlags = 32;
pub const G_URI_FLAGS_ENCODED_PATH: GUriFlags = 64;
pub const G_URI_FLAGS_ENCODED_FRAGMENT: GUriFlags = 128;
pub const G_URI_FLAGS_SCHEME_NORMALIZE: GUriFlags = 256;
#[doc = " GUriFlags:\n @G_URI_FLAGS_NONE: No flags set.\n @G_URI_FLAGS_PARSE_RELAXED: Parse the URI more relaxedly than the\n     [RFC 3986](https://tools.ietf.org/html/rfc3986) grammar specifies,\n     fixing up or ignoring common mistakes in URIs coming from external\n     sources. This is also needed for some obscure URI schemes where `;`\n     separates the host from the path. Dont use this flag unless you need to.\n @G_URI_FLAGS_HAS_PASSWORD: The userinfo field may contain a password,\n     which will be separated from the username by `:`.\n @G_URI_FLAGS_HAS_AUTH_PARAMS: The userinfo may contain additional\n     authentication-related parameters, which will be separated from\n     the username and/or password by `;`.\n @G_URI_FLAGS_NON_DNS: The host component should not be assumed to be a\n     DNS hostname or IP address (for example, for `smb` URIs with NetBIOS\n     hostnames).\n @G_URI_FLAGS_ENCODED: When parsing a URI, this indicates that `%`-encoded\n     characters in the userinfo, path, query, and fragment fields\n     should not be decoded. (And likewise the host field if\n     %G_URI_FLAGS_NON_DNS is also set.) When building a URI, it indicates\n     that you have already `%`-encoded the components, and so #GUri\n     should not do any encoding itself.\n @G_URI_FLAGS_ENCODED_QUERY: Same as %G_URI_FLAGS_ENCODED, for the query\n     field only.\n @G_URI_FLAGS_ENCODED_PATH: Same as %G_URI_FLAGS_ENCODED, for the path only.\n @G_URI_FLAGS_ENCODED_FRAGMENT: Same as %G_URI_FLAGS_ENCODED, for the\n     fragment only.\n @G_URI_FLAGS_SCHEME_NORMALIZE: A scheme-based normalization will be applied.\n     For example, when parsing an HTTP URI changing omitted path to `/` and\n     omitted port to `80`; and when building a URI, changing empty path to `/`\n     and default port `80`). This only supports a subset of known schemes. (Since: 2.68)\n\n Flags that describe a URI.\n\n When parsing a URI, if you need to choose different flags based on\n the type of URI, you can use g_uri_peek_scheme() on the URI string\n to check the scheme first, and use that to decide what flags to\n parse it with.\n\n Since: 2.66"]
pub type GUriFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_uri_split(
        uri_ref: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        userinfo: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        path: *mut *mut gchar,
        query: *mut *mut gchar,
        fragment: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_split_with_user(
        uri_ref: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        user: *mut *mut gchar,
        password: *mut *mut gchar,
        auth_params: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        path: *mut *mut gchar,
        query: *mut *mut gchar,
        fragment: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_split_network(
        uri_string: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_is_valid(
        uri_string: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_join(
        flags: GUriFlags,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_uri_join_with_user(
        flags: GUriFlags,
        scheme: *const gchar,
        user: *const gchar,
        password: *const gchar,
        auth_params: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_uri_parse(
        uri_string: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
}
unsafe extern "C" {
    pub fn g_uri_parse_relative(
        base_uri: *mut GUri,
        uri_ref: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
}
unsafe extern "C" {
    pub fn g_uri_resolve_relative(
        base_uri_string: *const gchar,
        uri_ref: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_uri_build(
        flags: GUriFlags,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GUri;
}
unsafe extern "C" {
    pub fn g_uri_build_with_user(
        flags: GUriFlags,
        scheme: *const gchar,
        user: *const gchar,
        password: *const gchar,
        auth_params: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GUri;
}
pub const G_URI_HIDE_NONE: GUriHideFlags = 0;
pub const G_URI_HIDE_USERINFO: GUriHideFlags = 1;
pub const G_URI_HIDE_PASSWORD: GUriHideFlags = 2;
pub const G_URI_HIDE_AUTH_PARAMS: GUriHideFlags = 4;
pub const G_URI_HIDE_QUERY: GUriHideFlags = 8;
pub const G_URI_HIDE_FRAGMENT: GUriHideFlags = 16;
#[doc = " GUriHideFlags:\n @G_URI_HIDE_NONE: No flags set.\n @G_URI_HIDE_USERINFO: Hide the userinfo.\n @G_URI_HIDE_PASSWORD: Hide the password.\n @G_URI_HIDE_AUTH_PARAMS: Hide the auth_params.\n @G_URI_HIDE_QUERY: Hide the query.\n @G_URI_HIDE_FRAGMENT: Hide the fragment.\n\n Flags describing what parts of the URI to hide in\n g_uri_to_string_partial(). Note that %G_URI_HIDE_PASSWORD and\n %G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with\n the corresponding flags.\n\n Since: 2.66"]
pub type GUriHideFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_uri_to_string(uri: *mut GUri) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_to_string_partial(
        uri: *mut GUri,
        flags: GUriHideFlags,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_get_scheme(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_userinfo(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_user(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_password(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_auth_params(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_host(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_port(uri: *mut GUri) -> gint;
}
unsafe extern "C" {
    pub fn g_uri_get_path(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_query(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_fragment(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_flags(uri: *mut GUri) -> GUriFlags;
}
pub const G_URI_PARAMS_NONE: GUriParamsFlags = 0;
pub const G_URI_PARAMS_CASE_INSENSITIVE: GUriParamsFlags = 1;
pub const G_URI_PARAMS_WWW_FORM: GUriParamsFlags = 2;
pub const G_URI_PARAMS_PARSE_RELAXED: GUriParamsFlags = 4;
#[doc = " GUriParamsFlags:\n @G_URI_PARAMS_NONE: No flags set.\n @G_URI_PARAMS_CASE_INSENSITIVE: Parameter names are case insensitive.\n @G_URI_PARAMS_WWW_FORM: Replace `+` with space character. Only useful for\n     URLs on the web, using the `https` or `http` schemas.\n @G_URI_PARAMS_PARSE_RELAXED: See %G_URI_FLAGS_PARSE_RELAXED.\n\n Flags modifying the way parameters are handled by g_uri_parse_params() and\n #GUriParamsIter.\n\n Since: 2.66"]
pub type GUriParamsFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_uri_parse_params(
        params: *const gchar,
        length: gssize,
        separators: *const gchar,
        flags: GUriParamsFlags,
        error: *mut *mut GError,
    ) -> *mut GHashTable;
}
pub type GUriParamsIter = _GUriParamsIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUriParamsIter {
    pub dummy0: gint,
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: [guint8; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GUriParamsIter"][::std::mem::size_of::<_GUriParamsIter>() - 280usize];
    ["Alignment of _GUriParamsIter"][::std::mem::align_of::<_GUriParamsIter>() - 8usize];
    ["Offset of field: _GUriParamsIter::dummy0"]
        [::std::mem::offset_of!(_GUriParamsIter, dummy0) - 0usize];
    ["Offset of field: _GUriParamsIter::dummy1"]
        [::std::mem::offset_of!(_GUriParamsIter, dummy1) - 8usize];
    ["Offset of field: _GUriParamsIter::dummy2"]
        [::std::mem::offset_of!(_GUriParamsIter, dummy2) - 16usize];
    ["Offset of field: _GUriParamsIter::dummy3"]
        [::std::mem::offset_of!(_GUriParamsIter, dummy3) - 24usize];
};
unsafe extern "C" {
    pub fn g_uri_params_iter_init(
        iter: *mut GUriParamsIter,
        params: *const gchar,
        length: gssize,
        separators: *const gchar,
        flags: GUriParamsFlags,
    );
}
unsafe extern "C" {
    pub fn g_uri_params_iter_next(
        iter: *mut GUriParamsIter,
        attribute: *mut *mut gchar,
        value: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_error_quark() -> GQuark;
}
pub const G_URI_ERROR_FAILED: GUriError = 0;
pub const G_URI_ERROR_BAD_SCHEME: GUriError = 1;
pub const G_URI_ERROR_BAD_USER: GUriError = 2;
pub const G_URI_ERROR_BAD_PASSWORD: GUriError = 3;
pub const G_URI_ERROR_BAD_AUTH_PARAMS: GUriError = 4;
pub const G_URI_ERROR_BAD_HOST: GUriError = 5;
pub const G_URI_ERROR_BAD_PORT: GUriError = 6;
pub const G_URI_ERROR_BAD_PATH: GUriError = 7;
pub const G_URI_ERROR_BAD_QUERY: GUriError = 8;
pub const G_URI_ERROR_BAD_FRAGMENT: GUriError = 9;
#[doc = " GUriError:\n @G_URI_ERROR_FAILED: Generic error if no more specific error is available.\n     See the error message for details.\n @G_URI_ERROR_BAD_SCHEME: The scheme of a URI could not be parsed.\n @G_URI_ERROR_BAD_USER: The user/userinfo of a URI could not be parsed.\n @G_URI_ERROR_BAD_PASSWORD: The password of a URI could not be parsed.\n @G_URI_ERROR_BAD_AUTH_PARAMS: The authentication parameters of a URI could not be parsed.\n @G_URI_ERROR_BAD_HOST: The host of a URI could not be parsed.\n @G_URI_ERROR_BAD_PORT: The port of a URI could not be parsed.\n @G_URI_ERROR_BAD_PATH: The path of a URI could not be parsed.\n @G_URI_ERROR_BAD_QUERY: The query of a URI could not be parsed.\n @G_URI_ERROR_BAD_FRAGMENT: The fragment of a URI could not be parsed.\n\n Error codes returned by #GUri methods.\n\n Since: 2.66"]
pub type GUriError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_uri_unescape_string(
        escaped_string: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_unescape_segment(
        escaped_string: *const ::std::os::raw::c_char,
        escaped_string_end: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_parse_scheme(uri: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_peek_scheme(uri: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_escape_string(
        unescaped: *const ::std::os::raw::c_char,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
        allow_utf8: gboolean,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_unescape_bytes(
        escaped_string: *const ::std::os::raw::c_char,
        length: gssize,
        illegal_characters: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_uri_escape_bytes(
        unescaped: *const guint8,
        length: gsize,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uuid_string_is_valid(str_: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uuid_string_random() -> *mut gchar;
}
unsafe extern "C" {
    pub static glib_major_version: guint;
}
unsafe extern "C" {
    pub static glib_minor_version: guint;
}
unsafe extern "C" {
    pub static glib_micro_version: guint;
}
unsafe extern "C" {
    pub static glib_interface_age: guint;
}
unsafe extern "C" {
    pub static glib_binary_age: guint;
}
unsafe extern "C" {
    pub fn glib_check_version(
        required_major: guint,
        required_minor: guint,
        required_micro: guint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAllocator {
    _unused: [u8; 0],
}
pub type GAllocator = _GAllocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemChunk {
    _unused: [u8; 0],
}
pub type GMemChunk = _GMemChunk;
unsafe extern "C" {
    pub fn g_mem_chunk_new(
        name: *const gchar,
        atom_size: gint,
        area_size: gsize,
        type_: gint,
    ) -> *mut GMemChunk;
}
unsafe extern "C" {
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
}
unsafe extern "C" {
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
}
unsafe extern "C" {
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
}
unsafe extern "C" {
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
}
unsafe extern "C" {
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
}
unsafe extern "C" {
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
}
unsafe extern "C" {
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
}
unsafe extern "C" {
    pub fn g_mem_chunk_info();
}
unsafe extern "C" {
    pub fn g_blow_chunks();
}
unsafe extern "C" {
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint) -> *mut GAllocator;
}
unsafe extern "C" {
    pub fn g_allocator_free(allocator: *mut GAllocator);
}
unsafe extern "C" {
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
}
unsafe extern "C" {
    pub fn g_list_pop_allocator();
}
unsafe extern "C" {
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
}
unsafe extern "C" {
    pub fn g_slist_pop_allocator();
}
unsafe extern "C" {
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
}
unsafe extern "C" {
    pub fn g_node_pop_allocator();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCache {
    _unused: [u8; 0],
}
pub type GCache = _GCache;
pub type GCacheNewFunc = ::std::option::Option<unsafe extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer)>;
unsafe extern "C" {
    pub fn g_cache_new(
        value_new_func: GCacheNewFunc,
        value_destroy_func: GCacheDestroyFunc,
        key_dup_func: GCacheDupFunc,
        key_destroy_func: GCacheDestroyFunc,
        hash_key_func: GHashFunc,
        hash_value_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> *mut GCache;
}
unsafe extern "C" {
    pub fn g_cache_destroy(cache: *mut GCache);
}
unsafe extern "C" {
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
}
unsafe extern "C" {
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
pub type GCompletion = _GCompletion;
pub type GCompletionFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc = ::std::option::Option<
    unsafe extern "C" fn(s1: *const gchar, s2: *const gchar, n: gsize) -> gint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GCompletion"][::std::mem::size_of::<_GCompletion>() - 40usize];
    ["Alignment of _GCompletion"][::std::mem::align_of::<_GCompletion>() - 8usize];
    ["Offset of field: _GCompletion::items"][::std::mem::offset_of!(_GCompletion, items) - 0usize];
    ["Offset of field: _GCompletion::func"][::std::mem::offset_of!(_GCompletion, func) - 8usize];
    ["Offset of field: _GCompletion::prefix"]
        [::std::mem::offset_of!(_GCompletion, prefix) - 16usize];
    ["Offset of field: _GCompletion::cache"][::std::mem::offset_of!(_GCompletion, cache) - 24usize];
    ["Offset of field: _GCompletion::strncmp_func"]
        [::std::mem::offset_of!(_GCompletion, strncmp_func) - 32usize];
};
unsafe extern "C" {
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
}
unsafe extern "C" {
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
}
unsafe extern "C" {
    pub fn g_completion_remove_items(cmp: *mut GCompletion, items: *mut GList);
}
unsafe extern "C" {
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
}
unsafe extern "C" {
    pub fn g_completion_complete(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_completion_complete_utf8(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_completion_set_compare(cmp: *mut GCompletion, strncmp_func: GCompletionStrncmpFunc);
}
unsafe extern "C" {
    pub fn g_completion_free(cmp: *mut GCompletion);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRelation {
    _unused: [u8; 0],
}
pub type GRelation = _GRelation;
pub type GTuples = _GTuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTuples {
    pub len: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTuples"][::std::mem::size_of::<_GTuples>() - 4usize];
    ["Alignment of _GTuples"][::std::mem::align_of::<_GTuples>() - 4usize];
    ["Offset of field: _GTuples::len"][::std::mem::offset_of!(_GTuples, len) - 0usize];
};
unsafe extern "C" {
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
}
unsafe extern "C" {
    pub fn g_relation_destroy(relation: *mut GRelation);
}
unsafe extern "C" {
    pub fn g_relation_index(
        relation: *mut GRelation,
        field: gint,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
    );
}
unsafe extern "C" {
    pub fn g_relation_insert(relation: *mut GRelation, ...);
}
unsafe extern "C" {
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_relation_select(
        relation: *mut GRelation,
        key: gconstpointer,
        field: gint,
    ) -> *mut GTuples;
}
unsafe extern "C" {
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
}
unsafe extern "C" {
    pub fn g_relation_print(relation: *mut GRelation);
}
unsafe extern "C" {
    pub fn g_tuples_destroy(tuples: *mut GTuples);
}
unsafe extern "C" {
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint) -> gpointer;
}
pub const G_THREAD_PRIORITY_LOW: GThreadPriority = 0;
pub const G_THREAD_PRIORITY_NORMAL: GThreadPriority = 1;
pub const G_THREAD_PRIORITY_HIGH: GThreadPriority = 2;
pub const G_THREAD_PRIORITY_URGENT: GThreadPriority = 3;
pub type GThreadPriority = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GThread"][::std::mem::size_of::<_GThread>() - 24usize];
    ["Alignment of _GThread"][::std::mem::align_of::<_GThread>() - 8usize];
    ["Offset of field: _GThread::func"][::std::mem::offset_of!(_GThread, func) - 0usize];
    ["Offset of field: _GThread::data"][::std::mem::offset_of!(_GThread, data) - 8usize];
    ["Offset of field: _GThread::joinable"][::std::mem::offset_of!(_GThread, joinable) - 16usize];
    ["Offset of field: _GThread::priority"][::std::mem::offset_of!(_GThread, priority) - 20usize];
};
pub type GThreadFunctions = _GThreadFunctions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadFunctions {
    pub mutex_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_trylock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex) -> gboolean>,
    pub mutex_unlock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_free: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub cond_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_broadcast: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_wait:
        ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex)>,
    pub cond_timed_wait: ::std::option::Option<
        unsafe extern "C" fn(
            cond: *mut GCond,
            mutex: *mut GMutex,
            end_time: *mut GTimeVal,
        ) -> gboolean,
    >,
    pub cond_free: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub private_new:
        ::std::option::Option<unsafe extern "C" fn(destructor: GDestroyNotify) -> *mut GPrivate>,
    pub private_get:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate) -> gpointer>,
    pub private_set:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate, data: gpointer)>,
    pub thread_create: ::std::option::Option<
        unsafe extern "C" fn(
            func: GThreadFunc,
            data: gpointer,
            stack_size: gulong,
            joinable: gboolean,
            bound: gboolean,
            priority: GThreadPriority,
            thread: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub thread_yield: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_join: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_set_priority:
        ::std::option::Option<unsafe extern "C" fn(thread: gpointer, priority: GThreadPriority)>,
    pub thread_self: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::std::option::Option<
        unsafe extern "C" fn(thread1: gpointer, thread2: gpointer) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GThreadFunctions"][::std::mem::size_of::<_GThreadFunctions>() - 168usize];
    ["Alignment of _GThreadFunctions"][::std::mem::align_of::<_GThreadFunctions>() - 8usize];
    ["Offset of field: _GThreadFunctions::mutex_new"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_new) - 0usize];
    ["Offset of field: _GThreadFunctions::mutex_lock"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_lock) - 8usize];
    ["Offset of field: _GThreadFunctions::mutex_trylock"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_trylock) - 16usize];
    ["Offset of field: _GThreadFunctions::mutex_unlock"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_unlock) - 24usize];
    ["Offset of field: _GThreadFunctions::mutex_free"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_free) - 32usize];
    ["Offset of field: _GThreadFunctions::cond_new"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_new) - 40usize];
    ["Offset of field: _GThreadFunctions::cond_signal"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_signal) - 48usize];
    ["Offset of field: _GThreadFunctions::cond_broadcast"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_broadcast) - 56usize];
    ["Offset of field: _GThreadFunctions::cond_wait"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_wait) - 64usize];
    ["Offset of field: _GThreadFunctions::cond_timed_wait"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_timed_wait) - 72usize];
    ["Offset of field: _GThreadFunctions::cond_free"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_free) - 80usize];
    ["Offset of field: _GThreadFunctions::private_new"]
        [::std::mem::offset_of!(_GThreadFunctions, private_new) - 88usize];
    ["Offset of field: _GThreadFunctions::private_get"]
        [::std::mem::offset_of!(_GThreadFunctions, private_get) - 96usize];
    ["Offset of field: _GThreadFunctions::private_set"]
        [::std::mem::offset_of!(_GThreadFunctions, private_set) - 104usize];
    ["Offset of field: _GThreadFunctions::thread_create"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_create) - 112usize];
    ["Offset of field: _GThreadFunctions::thread_yield"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_yield) - 120usize];
    ["Offset of field: _GThreadFunctions::thread_join"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_join) - 128usize];
    ["Offset of field: _GThreadFunctions::thread_exit"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_exit) - 136usize];
    ["Offset of field: _GThreadFunctions::thread_set_priority"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_set_priority) - 144usize];
    ["Offset of field: _GThreadFunctions::thread_self"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_self) - 152usize];
    ["Offset of field: _GThreadFunctions::thread_equal"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_equal) - 160usize];
};
unsafe extern "C" {
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
}
unsafe extern "C" {
    pub static mut g_thread_use_default_impl: gboolean;
}
unsafe extern "C" {
    pub static mut g_thread_gettime: ::std::option::Option<unsafe extern "C" fn() -> guint64>;
}
unsafe extern "C" {
    pub fn g_thread_create(
        func: GThreadFunc,
        data: gpointer,
        joinable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_create_full(
        func: GThreadFunc,
        data: gpointer,
        stack_size: gulong,
        joinable: gboolean,
        bound: gboolean,
        priority: GThreadPriority,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_set_priority(thread: *mut GThread, priority: GThreadPriority);
}
unsafe extern "C" {
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sched_param"][::std::mem::size_of::<sched_param>() - 4usize];
    ["Alignment of sched_param"][::std::mem::align_of::<sched_param>() - 4usize];
    ["Offset of field: sched_param::sched_priority"]
        [::std::mem::offset_of!(sched_param, sched_priority) - 0usize];
};
unsafe extern "C" {
    pub fn clone(
        __fn: ::std::option::Option<
            unsafe extern "C" fn(__arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        __child_stack: *mut ::std::os::raw::c_void,
        __flags: ::std::os::raw::c_int,
        __arg: *mut ::std::os::raw::c_void,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unshare(__flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getcpu() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getcpu(
        arg1: *mut ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setns(
        __fd: ::std::os::raw::c_int,
        __nstype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cpu_set_t"][::std::mem::size_of::<cpu_set_t>() - 128usize];
    ["Alignment of cpu_set_t"][::std::mem::align_of::<cpu_set_t>() - 8usize];
    ["Offset of field: cpu_set_t::__bits"][::std::mem::offset_of!(cpu_set_t, __bits) - 0usize];
};
unsafe extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
unsafe extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
unsafe extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_setaffinity(
        __pid: __pid_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getaffinity(
        __pid: __pid_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_27 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_27 = 1;
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_28 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_28 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_28 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_28 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_28 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_28 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_28 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_28 = 0;
pub const PTHREAD_MUTEX_FAST_NP: _bindgen_ty_28 = 0;
pub type _bindgen_ty_28 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_29 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_29 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_29 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_29 = 1;
pub type _bindgen_ty_29 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_30 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_30 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_30 = 2;
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_31 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_31 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_31 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_31 = 0;
pub type _bindgen_ty_31 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_32 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_32 = 1;
pub type _bindgen_ty_32 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_33 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_33 = 1;
pub type _bindgen_ty_33 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_34 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_34 = 1;
pub type _bindgen_ty_34 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _pthread_cleanup_buffer"][::std::mem::size_of::<_pthread_cleanup_buffer>() - 32usize];
    ["Alignment of _pthread_cleanup_buffer"]
        [::std::mem::align_of::<_pthread_cleanup_buffer>() - 8usize];
    ["Offset of field: _pthread_cleanup_buffer::__routine"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __routine) - 0usize];
    ["Offset of field: _pthread_cleanup_buffer::__arg"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __arg) - 8usize];
    ["Offset of field: _pthread_cleanup_buffer::__canceltype"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __canceltype) - 16usize];
    ["Offset of field: _pthread_cleanup_buffer::__prev"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __prev) - 24usize];
};
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_35 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_35 = 1;
pub type _bindgen_ty_35 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_36 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_36 = 1;
pub type _bindgen_ty_36 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
unsafe extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_tryjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_timedjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_clockjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_self() -> pthread_t;
}
unsafe extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setaffinity_np(
        __attr: *mut pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getaffinity_np(
        __attr: *const pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getattr_default_np(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setsigmask_np(
        __attr: *mut pthread_attr_t,
        sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getsigmask_np(
        __attr: *const pthread_attr_t,
        sigmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setattr_default_np(__attr: *const pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getattr_np(
        __th: pthread_t,
        __attr: *mut pthread_attr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getname_np(
        __target_thread: pthread_t,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setname_np(
        __target_thread: pthread_t,
        __name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setconcurrency(__level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_yield() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __cancel_jmp_buf_tag"][::std::mem::size_of::<__cancel_jmp_buf_tag>() - 72usize];
    ["Alignment of __cancel_jmp_buf_tag"][::std::mem::align_of::<__cancel_jmp_buf_tag>() - 8usize];
    ["Offset of field: __cancel_jmp_buf_tag::__cancel_jmp_buf"]
        [::std::mem::offset_of!(__cancel_jmp_buf_tag, __cancel_jmp_buf) - 0usize];
    ["Offset of field: __cancel_jmp_buf_tag::__mask_was_saved"]
        [::std::mem::offset_of!(__cancel_jmp_buf_tag, __mask_was_saved) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_unwind_buf_t"][::std::mem::size_of::<__pthread_unwind_buf_t>() - 104usize];
    ["Alignment of __pthread_unwind_buf_t"]
        [::std::mem::align_of::<__pthread_unwind_buf_t>() - 8usize];
    ["Offset of field: __pthread_unwind_buf_t::__cancel_jmp_buf"]
        [::std::mem::offset_of!(__pthread_unwind_buf_t, __cancel_jmp_buf) - 0usize];
    ["Offset of field: __pthread_unwind_buf_t::__pad"]
        [::std::mem::offset_of!(__pthread_unwind_buf_t, __pad) - 72usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cleanup_frame"][::std::mem::size_of::<__pthread_cleanup_frame>() - 24usize];
    ["Alignment of __pthread_cleanup_frame"]
        [::std::mem::align_of::<__pthread_cleanup_frame>() - 8usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_routine"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_routine) - 0usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_arg"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_arg) - 8usize];
    ["Offset of field: __pthread_cleanup_frame::__do_it"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __do_it) - 16usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_type"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_type) - 20usize];
};
unsafe extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
unsafe extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
unsafe extern "C" {
    pub fn __pthread_register_cancel_defer(__buf: *mut __pthread_unwind_buf_t);
}
unsafe extern "C" {
    pub fn __pthread_unregister_cancel_restore(__buf: *mut __pthread_unwind_buf_t);
}
unsafe extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
unsafe extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_clocklock(
        __mutex: *mut pthread_mutex_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_clockrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_clockwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_clockwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __clock_id: __clockid_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GStaticMutex {
    pub mutex: *mut GMutex,
    pub unused: pthread_mutex_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GStaticMutex"][::std::mem::size_of::<GStaticMutex>() - 48usize];
    ["Alignment of GStaticMutex"][::std::mem::align_of::<GStaticMutex>() - 8usize];
    ["Offset of field: GStaticMutex::mutex"][::std::mem::offset_of!(GStaticMutex, mutex) - 0usize];
    ["Offset of field: GStaticMutex::unused"]
        [::std::mem::offset_of!(GStaticMutex, unused) - 8usize];
};
unsafe extern "C" {
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
}
unsafe extern "C" {
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
}
unsafe extern "C" {
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex) -> *mut GMutex;
}
pub type GStaticRecMutex = _GStaticRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: _GStaticRecMutex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GStaticRecMutex__bindgen_ty_1 {
    pub owner: pthread_t,
    pub dummy: gdouble,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GStaticRecMutex__bindgen_ty_1"]
        [::std::mem::size_of::<_GStaticRecMutex__bindgen_ty_1>() - 8usize];
    ["Alignment of _GStaticRecMutex__bindgen_ty_1"]
        [::std::mem::align_of::<_GStaticRecMutex__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GStaticRecMutex__bindgen_ty_1::owner"]
        [::std::mem::offset_of!(_GStaticRecMutex__bindgen_ty_1, owner) - 0usize];
    ["Offset of field: _GStaticRecMutex__bindgen_ty_1::dummy"]
        [::std::mem::offset_of!(_GStaticRecMutex__bindgen_ty_1, dummy) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GStaticRecMutex"][::std::mem::size_of::<_GStaticRecMutex>() - 64usize];
    ["Alignment of _GStaticRecMutex"][::std::mem::align_of::<_GStaticRecMutex>() - 8usize];
    ["Offset of field: _GStaticRecMutex::mutex"]
        [::std::mem::offset_of!(_GStaticRecMutex, mutex) - 0usize];
    ["Offset of field: _GStaticRecMutex::depth"]
        [::std::mem::offset_of!(_GStaticRecMutex, depth) - 48usize];
    ["Offset of field: _GStaticRecMutex::unused"]
        [::std::mem::offset_of!(_GStaticRecMutex, unused) - 56usize];
};
unsafe extern "C" {
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex) -> gboolean;
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex, depth: guint);
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex) -> guint;
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
}
pub type GStaticRWLock = _GStaticRWLock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GStaticRWLock"][::std::mem::size_of::<_GStaticRWLock>() - 80usize];
    ["Alignment of _GStaticRWLock"][::std::mem::align_of::<_GStaticRWLock>() - 8usize];
    ["Offset of field: _GStaticRWLock::mutex"]
        [::std::mem::offset_of!(_GStaticRWLock, mutex) - 0usize];
    ["Offset of field: _GStaticRWLock::read_cond"]
        [::std::mem::offset_of!(_GStaticRWLock, read_cond) - 48usize];
    ["Offset of field: _GStaticRWLock::write_cond"]
        [::std::mem::offset_of!(_GStaticRWLock, write_cond) - 56usize];
    ["Offset of field: _GStaticRWLock::read_counter"]
        [::std::mem::offset_of!(_GStaticRWLock, read_counter) - 64usize];
    ["Offset of field: _GStaticRWLock::have_writer"]
        [::std::mem::offset_of!(_GStaticRWLock, have_writer) - 68usize];
    ["Offset of field: _GStaticRWLock::want_to_read"]
        [::std::mem::offset_of!(_GStaticRWLock, want_to_read) - 72usize];
    ["Offset of field: _GStaticRWLock::want_to_write"]
        [::std::mem::offset_of!(_GStaticRWLock, want_to_write) - 76usize];
};
unsafe extern "C" {
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
unsafe extern "C" {
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
unsafe extern "C" {
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
}
pub type GStaticPrivate = _GStaticPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticPrivate {
    pub index: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GStaticPrivate"][::std::mem::size_of::<_GStaticPrivate>() - 4usize];
    ["Alignment of _GStaticPrivate"][::std::mem::align_of::<_GStaticPrivate>() - 4usize];
    ["Offset of field: _GStaticPrivate::index"]
        [::std::mem::offset_of!(_GStaticPrivate, index) - 0usize];
};
unsafe extern "C" {
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
}
unsafe extern "C" {
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
}
unsafe extern "C" {
    pub fn g_static_private_set(
        private_key: *mut GStaticPrivate,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
}
unsafe extern "C" {
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
}
unsafe extern "C" {
    pub fn g_thread_init(vtable: gpointer);
}
unsafe extern "C" {
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
}
unsafe extern "C" {
    pub fn g_thread_get_initialized() -> gboolean;
}
unsafe extern "C" {
    pub static mut g_threads_got_initialized: gboolean;
}
unsafe extern "C" {
    pub fn g_mutex_new() -> *mut GMutex;
}
unsafe extern "C" {
    pub fn g_mutex_free(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_cond_new() -> *mut GCond;
}
unsafe extern "C" {
    pub fn g_cond_free(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_timed_wait(
        cond: *mut GCond,
        mutex: *mut GMutex,
        timeval: *mut GTimeVal,
    ) -> gboolean;
}
pub type GAsyncQueue_autoptr = *mut GAsyncQueue;
pub type GAsyncQueue_listautoptr = *mut GList;
pub type GAsyncQueue_slistautoptr = *mut GSList;
pub type GAsyncQueue_queueautoptr = *mut GQueue;
pub type GBookmarkFile_autoptr = *mut GBookmarkFile;
pub type GBookmarkFile_listautoptr = *mut GList;
pub type GBookmarkFile_slistautoptr = *mut GSList;
pub type GBookmarkFile_queueautoptr = *mut GQueue;
pub type GBytes_autoptr = *mut GBytes;
pub type GBytes_listautoptr = *mut GList;
pub type GBytes_slistautoptr = *mut GSList;
pub type GBytes_queueautoptr = *mut GQueue;
pub type GChecksum_autoptr = *mut GChecksum;
pub type GChecksum_listautoptr = *mut GList;
pub type GChecksum_slistautoptr = *mut GSList;
pub type GChecksum_queueautoptr = *mut GQueue;
pub type GDateTime_autoptr = *mut GDateTime;
pub type GDateTime_listautoptr = *mut GList;
pub type GDateTime_slistautoptr = *mut GSList;
pub type GDateTime_queueautoptr = *mut GQueue;
pub type GDate_autoptr = *mut GDate;
pub type GDate_listautoptr = *mut GList;
pub type GDate_slistautoptr = *mut GSList;
pub type GDate_queueautoptr = *mut GQueue;
pub type GDir_autoptr = *mut GDir;
pub type GDir_listautoptr = *mut GList;
pub type GDir_slistautoptr = *mut GSList;
pub type GDir_queueautoptr = *mut GQueue;
pub type GError_autoptr = *mut GError;
pub type GError_listautoptr = *mut GList;
pub type GError_slistautoptr = *mut GSList;
pub type GError_queueautoptr = *mut GQueue;
pub type GHashTable_autoptr = *mut GHashTable;
pub type GHashTable_listautoptr = *mut GList;
pub type GHashTable_slistautoptr = *mut GSList;
pub type GHashTable_queueautoptr = *mut GQueue;
pub type GHmac_autoptr = *mut GHmac;
pub type GHmac_listautoptr = *mut GList;
pub type GHmac_slistautoptr = *mut GSList;
pub type GHmac_queueautoptr = *mut GQueue;
pub type GIOChannel_autoptr = *mut GIOChannel;
pub type GIOChannel_listautoptr = *mut GList;
pub type GIOChannel_slistautoptr = *mut GSList;
pub type GIOChannel_queueautoptr = *mut GQueue;
pub type GKeyFile_autoptr = *mut GKeyFile;
pub type GKeyFile_listautoptr = *mut GList;
pub type GKeyFile_slistautoptr = *mut GSList;
pub type GKeyFile_queueautoptr = *mut GQueue;
pub type GList_autoptr = *mut GList;
pub type GList_listautoptr = *mut GList;
pub type GList_slistautoptr = *mut GSList;
pub type GList_queueautoptr = *mut GQueue;
pub type GArray_autoptr = *mut GArray;
pub type GArray_listautoptr = *mut GList;
pub type GArray_slistautoptr = *mut GSList;
pub type GArray_queueautoptr = *mut GQueue;
pub type GPtrArray_autoptr = *mut GPtrArray;
pub type GPtrArray_listautoptr = *mut GList;
pub type GPtrArray_slistautoptr = *mut GSList;
pub type GPtrArray_queueautoptr = *mut GQueue;
pub type GByteArray_autoptr = *mut GByteArray;
pub type GByteArray_listautoptr = *mut GList;
pub type GByteArray_slistautoptr = *mut GSList;
pub type GByteArray_queueautoptr = *mut GQueue;
pub type GMainContext_autoptr = *mut GMainContext;
pub type GMainContext_listautoptr = *mut GList;
pub type GMainContext_slistautoptr = *mut GSList;
pub type GMainContext_queueautoptr = *mut GQueue;
pub type GMainContextPusher_autoptr = *mut GMainContextPusher;
pub type GMainContextPusher_listautoptr = *mut GList;
pub type GMainContextPusher_slistautoptr = *mut GSList;
pub type GMainContextPusher_queueautoptr = *mut GQueue;
pub type GMainLoop_autoptr = *mut GMainLoop;
pub type GMainLoop_listautoptr = *mut GList;
pub type GMainLoop_slistautoptr = *mut GSList;
pub type GMainLoop_queueautoptr = *mut GQueue;
pub type GSource_autoptr = *mut GSource;
pub type GSource_listautoptr = *mut GList;
pub type GSource_slistautoptr = *mut GSList;
pub type GSource_queueautoptr = *mut GQueue;
pub type GMappedFile_autoptr = *mut GMappedFile;
pub type GMappedFile_listautoptr = *mut GList;
pub type GMappedFile_slistautoptr = *mut GSList;
pub type GMappedFile_queueautoptr = *mut GQueue;
pub type GMarkupParseContext_autoptr = *mut GMarkupParseContext;
pub type GMarkupParseContext_listautoptr = *mut GList;
pub type GMarkupParseContext_slistautoptr = *mut GSList;
pub type GMarkupParseContext_queueautoptr = *mut GQueue;
pub type GNode_autoptr = *mut GNode;
pub type GNode_listautoptr = *mut GList;
pub type GNode_slistautoptr = *mut GSList;
pub type GNode_queueautoptr = *mut GQueue;
pub type GOptionContext_autoptr = *mut GOptionContext;
pub type GOptionContext_listautoptr = *mut GList;
pub type GOptionContext_slistautoptr = *mut GSList;
pub type GOptionContext_queueautoptr = *mut GQueue;
pub type GOptionGroup_autoptr = *mut GOptionGroup;
pub type GOptionGroup_listautoptr = *mut GList;
pub type GOptionGroup_slistautoptr = *mut GSList;
pub type GOptionGroup_queueautoptr = *mut GQueue;
pub type GPatternSpec_autoptr = *mut GPatternSpec;
pub type GPatternSpec_listautoptr = *mut GList;
pub type GPatternSpec_slistautoptr = *mut GSList;
pub type GPatternSpec_queueautoptr = *mut GQueue;
pub type GQueue_autoptr = *mut GQueue;
pub type GQueue_listautoptr = *mut GList;
pub type GQueue_slistautoptr = *mut GSList;
pub type GQueue_queueautoptr = *mut GQueue;
pub type GRand_autoptr = *mut GRand;
pub type GRand_listautoptr = *mut GList;
pub type GRand_slistautoptr = *mut GSList;
pub type GRand_queueautoptr = *mut GQueue;
pub type GRegex_autoptr = *mut GRegex;
pub type GRegex_listautoptr = *mut GList;
pub type GRegex_slistautoptr = *mut GSList;
pub type GRegex_queueautoptr = *mut GQueue;
pub type GMatchInfo_autoptr = *mut GMatchInfo;
pub type GMatchInfo_listautoptr = *mut GList;
pub type GMatchInfo_slistautoptr = *mut GSList;
pub type GMatchInfo_queueautoptr = *mut GQueue;
pub type GScanner_autoptr = *mut GScanner;
pub type GScanner_listautoptr = *mut GList;
pub type GScanner_slistautoptr = *mut GSList;
pub type GScanner_queueautoptr = *mut GQueue;
pub type GSequence_autoptr = *mut GSequence;
pub type GSequence_listautoptr = *mut GList;
pub type GSequence_slistautoptr = *mut GSList;
pub type GSequence_queueautoptr = *mut GQueue;
pub type GSList_autoptr = *mut GSList;
pub type GSList_listautoptr = *mut GList;
pub type GSList_slistautoptr = *mut GSList;
pub type GSList_queueautoptr = *mut GQueue;
pub type GString_autoptr = *mut GString;
pub type GString_listautoptr = *mut GList;
pub type GString_slistautoptr = *mut GSList;
pub type GString_queueautoptr = *mut GQueue;
pub type GStringChunk_autoptr = *mut GStringChunk;
pub type GStringChunk_listautoptr = *mut GList;
pub type GStringChunk_slistautoptr = *mut GSList;
pub type GStringChunk_queueautoptr = *mut GQueue;
pub type GStrvBuilder_autoptr = *mut GStrvBuilder;
pub type GStrvBuilder_listautoptr = *mut GList;
pub type GStrvBuilder_slistautoptr = *mut GSList;
pub type GStrvBuilder_queueautoptr = *mut GQueue;
pub type GThread_autoptr = *mut GThread;
pub type GThread_listautoptr = *mut GList;
pub type GThread_slistautoptr = *mut GSList;
pub type GThread_queueautoptr = *mut GQueue;
pub type GMutexLocker_autoptr = *mut GMutexLocker;
pub type GMutexLocker_listautoptr = *mut GList;
pub type GMutexLocker_slistautoptr = *mut GSList;
pub type GMutexLocker_queueautoptr = *mut GQueue;
pub type GRecMutexLocker_autoptr = *mut GRecMutexLocker;
pub type GRecMutexLocker_listautoptr = *mut GList;
pub type GRecMutexLocker_slistautoptr = *mut GSList;
pub type GRecMutexLocker_queueautoptr = *mut GQueue;
pub type GRWLockWriterLocker_autoptr = *mut GRWLockWriterLocker;
pub type GRWLockWriterLocker_listautoptr = *mut GList;
pub type GRWLockWriterLocker_slistautoptr = *mut GSList;
pub type GRWLockWriterLocker_queueautoptr = *mut GQueue;
pub type GRWLockReaderLocker_autoptr = *mut GRWLockReaderLocker;
pub type GRWLockReaderLocker_listautoptr = *mut GList;
pub type GRWLockReaderLocker_slistautoptr = *mut GSList;
pub type GRWLockReaderLocker_queueautoptr = *mut GQueue;
pub type GTimer_autoptr = *mut GTimer;
pub type GTimer_listautoptr = *mut GList;
pub type GTimer_slistautoptr = *mut GSList;
pub type GTimer_queueautoptr = *mut GQueue;
pub type GTimeZone_autoptr = *mut GTimeZone;
pub type GTimeZone_listautoptr = *mut GList;
pub type GTimeZone_slistautoptr = *mut GSList;
pub type GTimeZone_queueautoptr = *mut GQueue;
pub type GTree_autoptr = *mut GTree;
pub type GTree_listautoptr = *mut GList;
pub type GTree_slistautoptr = *mut GSList;
pub type GTree_queueautoptr = *mut GQueue;
pub type GVariant_autoptr = *mut GVariant;
pub type GVariant_listautoptr = *mut GList;
pub type GVariant_slistautoptr = *mut GSList;
pub type GVariant_queueautoptr = *mut GQueue;
pub type GVariantBuilder_autoptr = *mut GVariantBuilder;
pub type GVariantBuilder_listautoptr = *mut GList;
pub type GVariantBuilder_slistautoptr = *mut GSList;
pub type GVariantBuilder_queueautoptr = *mut GQueue;
pub type GVariantIter_autoptr = *mut GVariantIter;
pub type GVariantIter_listautoptr = *mut GList;
pub type GVariantIter_slistautoptr = *mut GSList;
pub type GVariantIter_queueautoptr = *mut GQueue;
pub type GVariantDict_autoptr = *mut GVariantDict;
pub type GVariantDict_listautoptr = *mut GList;
pub type GVariantDict_slistautoptr = *mut GSList;
pub type GVariantDict_queueautoptr = *mut GQueue;
pub type GVariantType_autoptr = *mut GVariantType;
pub type GVariantType_listautoptr = *mut GList;
pub type GVariantType_slistautoptr = *mut GSList;
pub type GVariantType_queueautoptr = *mut GQueue;
pub type GRefString_autoptr = *mut GRefString;
pub type GRefString_listautoptr = *mut GList;
pub type GRefString_slistautoptr = *mut GSList;
pub type GRefString_queueautoptr = *mut GQueue;
pub type GUri_autoptr = *mut GUri;
pub type GUri_listautoptr = *mut GList;
pub type GUri_slistautoptr = *mut GSList;
pub type GUri_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn g_unix_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_unix_open_pipe(fds: *mut gint, flags: gint, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unix_set_fd_nonblocking(
        fd: gint,
        nonblock: gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unix_signal_source_new(signum: gint) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_unix_signal_add_full(
        priority: gint,
        signum: gint,
        handler: GSourceFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_unix_signal_add(signum: gint, handler: GSourceFunc, user_data: gpointer) -> guint;
}
#[doc = " GUnixFDSourceFunc:\n @fd: the fd that triggered the event\n @condition: the IO conditions reported on @fd\n @user_data: user data passed to g_unix_fd_add()\n\n The type of functions to be called when a UNIX fd watch source\n triggers.\n\n Returns: %FALSE if the source should be removed"]
pub type GUnixFDSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(fd: gint, condition: GIOCondition, user_data: gpointer) -> gboolean,
>;
unsafe extern "C" {
    pub fn g_unix_fd_source_new(fd: gint, condition: GIOCondition) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_unix_fd_add_full(
        priority: gint,
        fd: gint,
        condition: GIOCondition,
        function: GUnixFDSourceFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_unix_fd_add(
        fd: gint,
        condition: GIOCondition,
        function: GUnixFDSourceFunc,
        user_data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_unix_get_passwd_entry(user_name: *const gchar, error: *mut *mut GError)
        -> *mut passwd;
}
pub const G_MODULE_BIND_LAZY: GModuleFlags = 1;
pub const G_MODULE_BIND_LOCAL: GModuleFlags = 2;
pub const G_MODULE_BIND_MASK: GModuleFlags = 3;
#[doc = " GModuleFlags:\n @G_MODULE_BIND_LAZY: specifies that symbols are only resolved when\n     needed. The default action is to bind all symbols when the module\n     is loaded.\n @G_MODULE_BIND_LOCAL: specifies that symbols in the module should\n     not be added to the global name space. The default action on most\n     platforms is to place symbols in the module in the global name space,\n     which may cause conflicts with existing symbols.\n @G_MODULE_BIND_MASK: mask for all flags.\n\n Flags passed to g_module_open().\n Note that these flags are not supported on all platforms."]
pub type GModuleFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GModule {
    _unused: [u8; 0],
}
pub type GModule = _GModule;
pub type GModuleCheckInit =
    ::std::option::Option<unsafe extern "C" fn(module: *mut GModule) -> *const gchar>;
pub type GModuleUnload = ::std::option::Option<unsafe extern "C" fn(module: *mut GModule)>;
unsafe extern "C" {
    pub fn g_module_error_quark() -> GQuark;
}
pub const G_MODULE_ERROR_FAILED: GModuleError = 0;
pub const G_MODULE_ERROR_CHECK_FAILED: GModuleError = 1;
#[doc = " GModuleError:\n @G_MODULE_ERROR_FAILED: there was an error loading or opening a module file\n @G_MODULE_ERROR_CHECK_FAILED: a module returned an error from its `g_module_check_init()` function\n\n Errors returned by g_module_open_full().\n\n Since: 2.70"]
pub type GModuleError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_module_supported() -> gboolean;
}
unsafe extern "C" {
    pub fn g_module_open(file_name: *const gchar, flags: GModuleFlags) -> *mut GModule;
}
unsafe extern "C" {
    pub fn g_module_open_full(
        file_name: *const gchar,
        flags: GModuleFlags,
        error: *mut *mut GError,
    ) -> *mut GModule;
}
unsafe extern "C" {
    pub fn g_module_close(module: *mut GModule) -> gboolean;
}
unsafe extern "C" {
    pub fn g_module_make_resident(module: *mut GModule);
}
unsafe extern "C" {
    pub fn g_module_error() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_module_symbol(
        module: *mut GModule,
        symbol_name: *const gchar,
        symbol: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_module_name(module: *mut GModule) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_module_build_path(directory: *const gchar, module_name: *const gchar) -> *mut gchar;
}
pub type Int128 = __int128_t;
pub type Int128Aligned = __int128_t;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union Int128Alias {
    pub u: Int128Alias___uint128_t,
    pub i: __int128_t,
    pub s: Int128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Int128Alias"][::std::mem::size_of::<Int128Alias>() - 16usize];
    ["Alignment of Int128Alias"][::std::mem::align_of::<Int128Alias>() - 16usize];
    ["Offset of field: Int128Alias::u"][::std::mem::offset_of!(Int128Alias, u) - 0usize];
    ["Offset of field: Int128Alias::i"][::std::mem::offset_of!(Int128Alias, i) - 0usize];
    ["Offset of field: Int128Alias::s"][::std::mem::offset_of!(Int128Alias, s) - 0usize];
};
unsafe extern "C" {
    pub fn urshift(plow: *mut u64, phigh: *mut u64, shift: i32);
}
unsafe extern "C" {
    pub fn ulshift(plow: *mut u64, phigh: *mut u64, shift: i32, overflow: *mut bool);
}
unsafe extern "C" {
    pub fn divu256(plow: *mut Int128, phigh: *mut Int128, divisor: Int128) -> Int128;
}
unsafe extern "C" {
    pub fn divs256(plow: *mut Int128, phigh: *mut Int128, divisor: Int128) -> Int128;
}
unsafe extern "C" {
    pub fn os_set_line_buffering();
}
unsafe extern "C" {
    pub fn os_setup_early_signal_handling();
}
unsafe extern "C" {
    pub fn os_set_proc_name(s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn os_setup_signal_handling();
}
unsafe extern "C" {
    pub fn os_set_daemonize(d: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn is_daemonized() -> bool;
}
unsafe extern "C" {
    pub fn os_daemonize();
}
unsafe extern "C" {
    pub fn os_set_runas(user_id: *const ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    pub fn os_set_chroot(path: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn os_setup_limits();
}
unsafe extern "C" {
    pub fn os_setup_post();
}
unsafe extern "C" {
    pub fn os_mlock() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_alloc_stack(sz: *mut usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qemu_free_stack(stack: *mut ::std::os::raw::c_void, sz: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccelCPUState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AioContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Aml {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BdrvDirtyBitmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BdrvDirtyBitmapIter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockBackend {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockBackendRootState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockDriverState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Chardev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConfidentialGuestSupport {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DirtyBitmapSnapshot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisasContextBase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayChangeListener {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DriveInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DumpState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Error {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventNotifier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FWCfgState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HostMemoryBackend {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct I2CBus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct I2SCodec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISABus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISADevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IsaDma {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSONWriter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MACAddr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MachineClass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MachineState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryMappingList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MigrationIncomingState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MigrationState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Monitor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MSIMessage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetClientState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetFilterState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NICInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIBridge {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIBus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIDevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIEPort {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIESlot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIExpressDevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIExpressHost {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIHostDeviceAddress {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIHostState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Property {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PropertyInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QBool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QDict {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEMUBH {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuConsole {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEMUCursor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEMUFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuOpts {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEMUSGList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEMUTimer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEMUTimerListGroup {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QNull {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QNum {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QObject {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QString {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RAMBlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHPCDevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SSIBus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGCPUOps {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGHelperInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TaskState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtIODevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Visitor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VMChangeStateEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VMStateDescription {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRQState {
    _unused: [u8; 0],
}
pub type qemu_irq = *mut IRQState;
pub type qemu_irq_handler = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
    ),
>;
unsafe extern "C" {
    pub fn qemu_build_not_reached_always() -> !;
}
unsafe extern "C" {
    pub fn qemu_daemon(
        nochdir: ::std::os::raw::c_int,
        noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_anon_ram_alloc(
        size: usize,
        align: *mut u64,
        shared: bool,
        noreserve: bool,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qemu_anon_ram_free(ptr: *mut ::std::os::raw::c_void, size: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_signalfd_siginfo {
    pub ssi_signo: u32,
    pub ssi_errno: i32,
    pub ssi_code: i32,
    pub ssi_pid: u32,
    pub ssi_uid: u32,
    pub ssi_fd: i32,
    pub ssi_tid: u32,
    pub ssi_band: u32,
    pub ssi_overrun: u32,
    pub ssi_trapno: u32,
    pub ssi_status: i32,
    pub ssi_int: i32,
    pub ssi_ptr: u64,
    pub ssi_utime: u64,
    pub ssi_stime: u64,
    pub ssi_addr: u64,
    pub pad: [u8; 48usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_signalfd_siginfo"][::std::mem::size_of::<qemu_signalfd_siginfo>() - 128usize];
    ["Alignment of qemu_signalfd_siginfo"]
        [::std::mem::align_of::<qemu_signalfd_siginfo>() - 8usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_signo"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_signo) - 0usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_errno"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_errno) - 4usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_code"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_code) - 8usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_pid"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_pid) - 12usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_uid"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_uid) - 16usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_fd"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_fd) - 20usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_tid"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_tid) - 24usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_band"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_band) - 28usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_overrun"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_overrun) - 32usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_trapno"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_trapno) - 36usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_status"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_status) - 40usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_int"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_int) - 44usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_ptr"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_ptr) - 48usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_utime"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_utime) - 56usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_stime"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_stime) - 64usize];
    ["Offset of field: qemu_signalfd_siginfo::ssi_addr"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, ssi_addr) - 72usize];
    ["Offset of field: qemu_signalfd_siginfo::pad"]
        [::std::mem::offset_of!(qemu_signalfd_siginfo, pad) - 80usize];
};
unsafe extern "C" {
    pub fn qemu_signalfd(mask: *const sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigaction_invoke(action: *mut sigaction, info: *mut qemu_signalfd_siginfo);
}
unsafe extern "C" {
    pub fn qemu_open_old(
        name: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_open(
        name: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_create(
        name: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        mode: mode_t,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_close(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_unlink(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_dup_flags(
        fd: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_dup(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_lock_fd(
        fd: ::std::os::raw::c_int,
        start: i64,
        len: i64,
        exclusive: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_unlock_fd(fd: ::std::os::raw::c_int, start: i64, len: i64)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_lock_fd_test(
        fd: ::std::os::raw::c_int,
        start: i64,
        len: i64,
        exclusive: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_has_ofd_lock() -> bool;
}
unsafe extern "C" {
    pub fn qemu_has_direct_io() -> bool;
}
unsafe extern "C" {
    pub fn qemu_write_pidfile(
        pidfile: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn qemu_get_thread_id() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_write_full(
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        count: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn qemu_set_cloexec(fd: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn qemu_get_local_state_dir() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qemu_getauxval(type_: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn qemu_set_tty_echo(fd: ::std::os::raw::c_int, echo: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ThreadContext {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn qemu_prealloc_mem(
        fd: ::std::os::raw::c_int,
        area: *mut ::std::os::raw::c_char,
        sz: usize,
        max_threads: ::std::os::raw::c_int,
        tc: *mut ThreadContext,
        async_: bool,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn qemu_finish_async_prealloc_mem(errp: *mut *mut Error) -> bool;
}
unsafe extern "C" {
    pub fn qemu_get_pid_name(pid: pid_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qemu_fdatasync(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_close_all_open_fd(
        skip: *const ::std::os::raw::c_int,
        nskip: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn qemu_msync(
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_get_host_physmem() -> usize;
}
pub type hwaddr = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemMapEntry {
    pub base: hwaddr,
    pub size: hwaddr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemMapEntry"][::std::mem::size_of::<MemMapEntry>() - 16usize];
    ["Alignment of MemMapEntry"][::std::mem::align_of::<MemMapEntry>() - 8usize];
    ["Offset of field: MemMapEntry::base"][::std::mem::offset_of!(MemMapEntry, base) - 0usize];
    ["Offset of field: MemMapEntry::size"][::std::mem::offset_of!(MemMapEntry, size) - 8usize];
};
pub type vaddr = u64;
pub type aligned_int64_t = i64;
pub type aligned_uint64_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QTailQLink {
    pub tql_next: *mut ::std::os::raw::c_void,
    pub tql_prev: *mut QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QTailQLink"][::std::mem::size_of::<QTailQLink>() - 16usize];
    ["Alignment of QTailQLink"][::std::mem::align_of::<QTailQLink>() - 8usize];
    ["Offset of field: QTailQLink::tql_next"]
        [::std::mem::offset_of!(QTailQLink, tql_next) - 0usize];
    ["Offset of field: QTailQLink::tql_prev"]
        [::std::mem::offset_of!(QTailQLink, tql_prev) - 8usize];
};
unsafe extern "C" {
    pub fn find_last_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn find_next_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        offset: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn find_next_zero_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        offset: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn slow_bitmap_empty(
        bitmap: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn slow_bitmap_full(
        bitmap: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn slow_bitmap_equal(
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn slow_bitmap_complement(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    pub fn slow_bitmap_and(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn slow_bitmap_or(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    pub fn slow_bitmap_xor(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    pub fn slow_bitmap_andnot(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn slow_bitmap_intersects(
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn slow_bitmap_count_one(
        bitmap: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn bitmap_set(
        map: *mut ::std::os::raw::c_ulong,
        i: ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    pub fn bitmap_set_atomic(
        map: *mut ::std::os::raw::c_ulong,
        i: ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    pub fn bitmap_clear(
        map: *mut ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_long,
        nr: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    pub fn bitmap_test_and_clear_atomic(
        map: *mut ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_long,
        nr: ::std::os::raw::c_long,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bitmap_test_and_clear(
        map: *mut ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_long,
        nr: ::std::os::raw::c_long,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bitmap_copy_and_clear_atomic(
        dst: *mut ::std::os::raw::c_ulong,
        src: *mut ::std::os::raw::c_ulong,
        nr: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    pub fn bitmap_find_next_zero_area(
        map: *mut ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
        nr: ::std::os::raw::c_ulong,
        align_mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn bitmap_to_le(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    pub fn bitmap_from_le(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    pub fn bitmap_copy_with_src_offset(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        offset: ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_ulong,
    );
}
unsafe extern "C" {
    pub fn bitmap_copy_with_dst_offset(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        shift: ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_ulong,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QemuMutex {
    pub lock: pthread_mutex_t,
    pub initialized: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuMutex"][::std::mem::size_of::<QemuMutex>() - 48usize];
    ["Alignment of QemuMutex"][::std::mem::align_of::<QemuMutex>() - 8usize];
    ["Offset of field: QemuMutex::lock"][::std::mem::offset_of!(QemuMutex, lock) - 0usize];
    ["Offset of field: QemuMutex::initialized"]
        [::std::mem::offset_of!(QemuMutex, initialized) - 40usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QemuRecMutex {
    pub m: QemuMutex,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuRecMutex"][::std::mem::size_of::<QemuRecMutex>() - 48usize];
    ["Alignment of QemuRecMutex"][::std::mem::align_of::<QemuRecMutex>() - 8usize];
    ["Offset of field: QemuRecMutex::m"][::std::mem::offset_of!(QemuRecMutex, m) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QemuCond {
    pub cond: pthread_cond_t,
    pub initialized: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuCond"][::std::mem::size_of::<QemuCond>() - 56usize];
    ["Alignment of QemuCond"][::std::mem::align_of::<QemuCond>() - 8usize];
    ["Offset of field: QemuCond::cond"][::std::mem::offset_of!(QemuCond, cond) - 0usize];
    ["Offset of field: QemuCond::initialized"]
        [::std::mem::offset_of!(QemuCond, initialized) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QemuSemaphore {
    pub mutex: QemuMutex,
    pub cond: QemuCond,
    pub count: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuSemaphore"][::std::mem::size_of::<QemuSemaphore>() - 112usize];
    ["Alignment of QemuSemaphore"][::std::mem::align_of::<QemuSemaphore>() - 8usize];
    ["Offset of field: QemuSemaphore::mutex"]
        [::std::mem::offset_of!(QemuSemaphore, mutex) - 0usize];
    ["Offset of field: QemuSemaphore::cond"][::std::mem::offset_of!(QemuSemaphore, cond) - 48usize];
    ["Offset of field: QemuSemaphore::count"]
        [::std::mem::offset_of!(QemuSemaphore, count) - 104usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuEvent {
    pub value: ::std::os::raw::c_uint,
    pub initialized: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuEvent"][::std::mem::size_of::<QemuEvent>() - 8usize];
    ["Alignment of QemuEvent"][::std::mem::align_of::<QemuEvent>() - 4usize];
    ["Offset of field: QemuEvent::value"][::std::mem::offset_of!(QemuEvent, value) - 0usize];
    ["Offset of field: QemuEvent::initialized"]
        [::std::mem::offset_of!(QemuEvent, initialized) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuThread {
    pub thread: pthread_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuThread"][::std::mem::size_of::<QemuThread>() - 8usize];
    ["Alignment of QemuThread"][::std::mem::align_of::<QemuThread>() - 8usize];
    ["Offset of field: QemuThread::thread"][::std::mem::offset_of!(QemuThread, thread) - 0usize];
};
pub const QSP_SORT_BY_TOTAL_WAIT_TIME: QSPSortBy = 0;
pub const QSP_SORT_BY_AVG_WAIT_TIME: QSPSortBy = 1;
pub type QSPSortBy = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn qsp_report(max: usize, sort_by: QSPSortBy, callsite_coalesce: bool);
}
unsafe extern "C" {
    pub fn qsp_is_enabled() -> bool;
}
unsafe extern "C" {
    pub fn qsp_enable();
}
unsafe extern "C" {
    pub fn qsp_disable();
}
unsafe extern "C" {
    pub fn qsp_reset();
}
unsafe extern "C" {
    pub fn qemu_mutex_init(mutex: *mut QemuMutex);
}
unsafe extern "C" {
    pub fn qemu_mutex_destroy(mutex: *mut QemuMutex);
}
unsafe extern "C" {
    pub fn qemu_mutex_trylock_impl(
        mutex: *mut QemuMutex,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_mutex_lock_impl(
        mutex: *mut QemuMutex,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn qemu_mutex_unlock_impl(
        mutex: *mut QemuMutex,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn qemu_rec_mutex_init(mutex: *mut QemuRecMutex);
}
unsafe extern "C" {
    pub fn qemu_rec_mutex_destroy(mutex: *mut QemuRecMutex);
}
unsafe extern "C" {
    pub fn qemu_rec_mutex_lock_impl(
        mutex: *mut QemuRecMutex,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn qemu_rec_mutex_trylock_impl(
        mutex: *mut QemuRecMutex,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_rec_mutex_unlock_impl(
        mutex: *mut QemuRecMutex,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
pub type QemuMutexLockFunc = ::std::option::Option<
    unsafe extern "C" fn(
        m: *mut QemuMutex,
        f: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
    ),
>;
pub type QemuMutexTrylockFunc = ::std::option::Option<
    unsafe extern "C" fn(
        m: *mut QemuMutex,
        f: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type QemuRecMutexLockFunc = ::std::option::Option<
    unsafe extern "C" fn(
        m: *mut QemuRecMutex,
        f: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
    ),
>;
pub type QemuRecMutexTrylockFunc = ::std::option::Option<
    unsafe extern "C" fn(
        m: *mut QemuRecMutex,
        f: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type QemuCondWaitFunc = ::std::option::Option<
    unsafe extern "C" fn(
        c: *mut QemuCond,
        m: *mut QemuMutex,
        f: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
    ),
>;
pub type QemuCondTimedWaitFunc = ::std::option::Option<
    unsafe extern "C" fn(
        c: *mut QemuCond,
        m: *mut QemuMutex,
        ms: ::std::os::raw::c_int,
        f: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
    ) -> bool,
>;
unsafe extern "C" {
    pub static mut bql_mutex_lock_func: QemuMutexLockFunc;
}
unsafe extern "C" {
    pub static mut qemu_mutex_lock_func: QemuMutexLockFunc;
}
unsafe extern "C" {
    pub static mut qemu_mutex_trylock_func: QemuMutexTrylockFunc;
}
unsafe extern "C" {
    pub static mut qemu_rec_mutex_lock_func: QemuRecMutexLockFunc;
}
unsafe extern "C" {
    pub static mut qemu_rec_mutex_trylock_func: QemuRecMutexTrylockFunc;
}
unsafe extern "C" {
    pub static mut qemu_cond_wait_func: QemuCondWaitFunc;
}
unsafe extern "C" {
    pub static mut qemu_cond_timedwait_func: QemuCondTimedWaitFunc;
}
unsafe extern "C" {
    pub fn qemu_cond_init(cond: *mut QemuCond);
}
unsafe extern "C" {
    pub fn qemu_cond_destroy(cond: *mut QemuCond);
}
unsafe extern "C" {
    pub fn qemu_cond_signal(cond: *mut QemuCond);
}
unsafe extern "C" {
    pub fn qemu_cond_broadcast(cond: *mut QemuCond);
}
unsafe extern "C" {
    pub fn qemu_cond_wait_impl(
        cond: *mut QemuCond,
        mutex: *mut QemuMutex,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn qemu_cond_timedwait_impl(
        cond: *mut QemuCond,
        mutex: *mut QemuMutex,
        ms: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn qemu_sem_init(sem: *mut QemuSemaphore, init: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn qemu_sem_post(sem: *mut QemuSemaphore);
}
unsafe extern "C" {
    pub fn qemu_sem_wait(sem: *mut QemuSemaphore);
}
unsafe extern "C" {
    pub fn qemu_sem_timedwait(
        sem: *mut QemuSemaphore,
        ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_sem_destroy(sem: *mut QemuSemaphore);
}
unsafe extern "C" {
    pub fn qemu_event_init(ev: *mut QemuEvent, init: bool);
}
unsafe extern "C" {
    pub fn qemu_event_set(ev: *mut QemuEvent);
}
unsafe extern "C" {
    pub fn qemu_event_reset(ev: *mut QemuEvent);
}
unsafe extern "C" {
    pub fn qemu_event_wait(ev: *mut QemuEvent);
}
unsafe extern "C" {
    pub fn qemu_event_destroy(ev: *mut QemuEvent);
}
unsafe extern "C" {
    pub fn qemu_thread_create(
        thread: *mut QemuThread,
        name: *const ::std::os::raw::c_char,
        start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
        mode: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn qemu_thread_set_affinity(
        thread: *mut QemuThread,
        host_cpus: *mut ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_thread_get_affinity(
        thread: *mut QemuThread,
        host_cpus: *mut *mut ::std::os::raw::c_ulong,
        nbits: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_thread_join(thread: *mut QemuThread) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qemu_thread_get_self(thread: *mut QemuThread);
}
unsafe extern "C" {
    pub fn qemu_thread_is_self(thread: *mut QemuThread) -> bool;
}
unsafe extern "C" {
    pub fn qemu_thread_exit(retval: *mut ::std::os::raw::c_void) -> !;
}
unsafe extern "C" {
    pub fn qemu_thread_naming(enable: bool);
}
unsafe extern "C" {
    pub fn qemu_thread_atexit_add(notifier: *mut Notifier);
}
unsafe extern "C" {
    pub fn qemu_thread_atexit_remove(notifier: *mut Notifier);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuSpin {
    pub value: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuSpin"][::std::mem::size_of::<QemuSpin>() - 4usize];
    ["Alignment of QemuSpin"][::std::mem::align_of::<QemuSpin>() - 4usize];
    ["Offset of field: QemuSpin::value"][::std::mem::offset_of!(QemuSpin, value) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Notifier {
    pub notify: ::std::option::Option<
        unsafe extern "C" fn(notifier: *mut Notifier, data: *mut ::std::os::raw::c_void),
    >,
    pub node: Notifier__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Notifier__bindgen_ty_1 {
    pub le_next: *mut Notifier,
    pub le_prev: *mut *mut Notifier,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Notifier__bindgen_ty_1"][::std::mem::size_of::<Notifier__bindgen_ty_1>() - 16usize];
    ["Alignment of Notifier__bindgen_ty_1"]
        [::std::mem::align_of::<Notifier__bindgen_ty_1>() - 8usize];
    ["Offset of field: Notifier__bindgen_ty_1::le_next"]
        [::std::mem::offset_of!(Notifier__bindgen_ty_1, le_next) - 0usize];
    ["Offset of field: Notifier__bindgen_ty_1::le_prev"]
        [::std::mem::offset_of!(Notifier__bindgen_ty_1, le_prev) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Notifier"][::std::mem::size_of::<Notifier>() - 24usize];
    ["Alignment of Notifier"][::std::mem::align_of::<Notifier>() - 8usize];
    ["Offset of field: Notifier::notify"][::std::mem::offset_of!(Notifier, notify) - 0usize];
    ["Offset of field: Notifier::node"][::std::mem::offset_of!(Notifier, node) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifierList {
    pub notifiers: NotifierList__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifierList__bindgen_ty_1 {
    pub lh_first: *mut Notifier,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotifierList__bindgen_ty_1"]
        [::std::mem::size_of::<NotifierList__bindgen_ty_1>() - 8usize];
    ["Alignment of NotifierList__bindgen_ty_1"]
        [::std::mem::align_of::<NotifierList__bindgen_ty_1>() - 8usize];
    ["Offset of field: NotifierList__bindgen_ty_1::lh_first"]
        [::std::mem::offset_of!(NotifierList__bindgen_ty_1, lh_first) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotifierList"][::std::mem::size_of::<NotifierList>() - 8usize];
    ["Alignment of NotifierList"][::std::mem::align_of::<NotifierList>() - 8usize];
    ["Offset of field: NotifierList::notifiers"]
        [::std::mem::offset_of!(NotifierList, notifiers) - 0usize];
};
unsafe extern "C" {
    pub fn notifier_list_init(list: *mut NotifierList);
}
unsafe extern "C" {
    pub fn notifier_list_add(list: *mut NotifierList, notifier: *mut Notifier);
}
unsafe extern "C" {
    pub fn notifier_remove(notifier: *mut Notifier);
}
unsafe extern "C" {
    pub fn notifier_list_notify(list: *mut NotifierList, data: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn notifier_list_empty(list: *mut NotifierList) -> bool;
}
pub type NotifierWithReturnFunc = ::std::option::Option<
    unsafe extern "C" fn(
        notifier: *mut NotifierWithReturn,
        data: *mut ::std::os::raw::c_void,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifierWithReturn {
    pub notify: NotifierWithReturnFunc,
    pub node: NotifierWithReturn__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifierWithReturn__bindgen_ty_1 {
    pub le_next: *mut NotifierWithReturn,
    pub le_prev: *mut *mut NotifierWithReturn,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotifierWithReturn__bindgen_ty_1"]
        [::std::mem::size_of::<NotifierWithReturn__bindgen_ty_1>() - 16usize];
    ["Alignment of NotifierWithReturn__bindgen_ty_1"]
        [::std::mem::align_of::<NotifierWithReturn__bindgen_ty_1>() - 8usize];
    ["Offset of field: NotifierWithReturn__bindgen_ty_1::le_next"]
        [::std::mem::offset_of!(NotifierWithReturn__bindgen_ty_1, le_next) - 0usize];
    ["Offset of field: NotifierWithReturn__bindgen_ty_1::le_prev"]
        [::std::mem::offset_of!(NotifierWithReturn__bindgen_ty_1, le_prev) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotifierWithReturn"][::std::mem::size_of::<NotifierWithReturn>() - 24usize];
    ["Alignment of NotifierWithReturn"][::std::mem::align_of::<NotifierWithReturn>() - 8usize];
    ["Offset of field: NotifierWithReturn::notify"]
        [::std::mem::offset_of!(NotifierWithReturn, notify) - 0usize];
    ["Offset of field: NotifierWithReturn::node"]
        [::std::mem::offset_of!(NotifierWithReturn, node) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifierWithReturnList {
    pub notifiers: NotifierWithReturnList__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifierWithReturnList__bindgen_ty_1 {
    pub lh_first: *mut NotifierWithReturn,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotifierWithReturnList__bindgen_ty_1"]
        [::std::mem::size_of::<NotifierWithReturnList__bindgen_ty_1>() - 8usize];
    ["Alignment of NotifierWithReturnList__bindgen_ty_1"]
        [::std::mem::align_of::<NotifierWithReturnList__bindgen_ty_1>() - 8usize];
    ["Offset of field: NotifierWithReturnList__bindgen_ty_1::lh_first"]
        [::std::mem::offset_of!(NotifierWithReturnList__bindgen_ty_1, lh_first) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotifierWithReturnList"][::std::mem::size_of::<NotifierWithReturnList>() - 8usize];
    ["Alignment of NotifierWithReturnList"]
        [::std::mem::align_of::<NotifierWithReturnList>() - 8usize];
    ["Offset of field: NotifierWithReturnList::notifiers"]
        [::std::mem::offset_of!(NotifierWithReturnList, notifiers) - 0usize];
};
unsafe extern "C" {
    pub fn notifier_with_return_list_init(list: *mut NotifierWithReturnList);
}
unsafe extern "C" {
    pub fn notifier_with_return_list_add(
        list: *mut NotifierWithReturnList,
        notifier: *mut NotifierWithReturn,
    );
}
unsafe extern "C" {
    pub fn notifier_with_return_remove(notifier: *mut NotifierWithReturn);
}
unsafe extern "C" {
    pub fn notifier_with_return_list_notify(
        list: *mut NotifierWithReturnList,
        data: *mut ::std::os::raw::c_void,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut rcu_gp_ctr: ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub static mut rcu_gp_event: QemuEvent;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_reader_data {
    pub ctr: ::std::os::raw::c_ulong,
    pub waiting: bool,
    pub depth: ::std::os::raw::c_uint,
    pub node: rcu_reader_data__bindgen_ty_1,
    pub force_rcu: NotifierList,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_reader_data__bindgen_ty_1 {
    pub le_next: *mut rcu_reader_data,
    pub le_prev: *mut *mut rcu_reader_data,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rcu_reader_data__bindgen_ty_1"]
        [::std::mem::size_of::<rcu_reader_data__bindgen_ty_1>() - 16usize];
    ["Alignment of rcu_reader_data__bindgen_ty_1"]
        [::std::mem::align_of::<rcu_reader_data__bindgen_ty_1>() - 8usize];
    ["Offset of field: rcu_reader_data__bindgen_ty_1::le_next"]
        [::std::mem::offset_of!(rcu_reader_data__bindgen_ty_1, le_next) - 0usize];
    ["Offset of field: rcu_reader_data__bindgen_ty_1::le_prev"]
        [::std::mem::offset_of!(rcu_reader_data__bindgen_ty_1, le_prev) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rcu_reader_data"][::std::mem::size_of::<rcu_reader_data>() - 40usize];
    ["Alignment of rcu_reader_data"][::std::mem::align_of::<rcu_reader_data>() - 8usize];
    ["Offset of field: rcu_reader_data::ctr"]
        [::std::mem::offset_of!(rcu_reader_data, ctr) - 0usize];
    ["Offset of field: rcu_reader_data::waiting"]
        [::std::mem::offset_of!(rcu_reader_data, waiting) - 8usize];
    ["Offset of field: rcu_reader_data::depth"]
        [::std::mem::offset_of!(rcu_reader_data, depth) - 12usize];
    ["Offset of field: rcu_reader_data::node"]
        [::std::mem::offset_of!(rcu_reader_data, node) - 16usize];
    ["Offset of field: rcu_reader_data::force_rcu"]
        [::std::mem::offset_of!(rcu_reader_data, force_rcu) - 32usize];
};
unsafe extern "C" {
    pub fn get_rcu_reader() -> rcu_reader_data;
}
unsafe extern "C" {
    pub fn set_rcu_reader(v: rcu_reader_data);
}
unsafe extern "C" {
    pub fn get_ptr_rcu_reader() -> *mut rcu_reader_data;
}
unsafe extern "C" {
    pub fn synchronize_rcu();
}
unsafe extern "C" {
    pub fn rcu_register_thread();
}
unsafe extern "C" {
    pub fn rcu_unregister_thread();
}
unsafe extern "C" {
    pub fn rcu_enable_atfork();
}
unsafe extern "C" {
    pub fn rcu_disable_atfork();
}
pub type RCUCBFunc = ::std::option::Option<unsafe extern "C" fn(head: *mut rcu_head)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_head {
    pub next: *mut rcu_head,
    pub func: RCUCBFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rcu_head"][::std::mem::size_of::<rcu_head>() - 16usize];
    ["Alignment of rcu_head"][::std::mem::align_of::<rcu_head>() - 8usize];
    ["Offset of field: rcu_head::next"][::std::mem::offset_of!(rcu_head, next) - 0usize];
    ["Offset of field: rcu_head::func"][::std::mem::offset_of!(rcu_head, func) - 8usize];
};
unsafe extern "C" {
    pub fn call_rcu1(head: *mut rcu_head, func: RCUCBFunc);
}
unsafe extern "C" {
    pub fn drain_call_rcu();
}
pub type RCUReadAuto = ::std::os::raw::c_void;
pub type RCUReadAuto_autoptr = *mut RCUReadAuto;
pub type RCUReadAuto_listautoptr = *mut GList;
pub type RCUReadAuto_slistautoptr = *mut GSList;
pub type RCUReadAuto_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn rcu_add_force_rcu_notifier(n: *mut Notifier);
}
unsafe extern "C" {
    pub fn rcu_remove_force_rcu_notifier(n: *mut Notifier);
}
pub const QAPI_DEPRECATED: QapiSpecialFeature = 0;
pub const QAPI_UNSTABLE: QapiSpecialFeature = 1;
pub type QapiSpecialFeature = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEnumLookup {
    pub array: *const *const ::std::os::raw::c_char,
    pub special_features: *const ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QEnumLookup"][::std::mem::size_of::<QEnumLookup>() - 24usize];
    ["Alignment of QEnumLookup"][::std::mem::align_of::<QEnumLookup>() - 8usize];
    ["Offset of field: QEnumLookup::array"][::std::mem::offset_of!(QEnumLookup, array) - 0usize];
    ["Offset of field: QEnumLookup::special_features"]
        [::std::mem::offset_of!(QEnumLookup, special_features) - 8usize];
    ["Offset of field: QEnumLookup::size"][::std::mem::offset_of!(QEnumLookup, size) - 16usize];
};
unsafe extern "C" {
    pub fn qapi_enum_lookup(
        lookup: *const QEnumLookup,
        val: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qapi_enum_parse(
        lookup: *const QEnumLookup,
        buf: *const ::std::os::raw::c_char,
        def: ::std::os::raw::c_int,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qapi_bool_parse(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        obj: *mut bool,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn parse_qapi_name(
        name: *const ::std::os::raw::c_char,
        complete: bool,
    ) -> ::std::os::raw::c_int;
}
pub const QTYPE_NONE: QType = 0;
pub const QTYPE_QNULL: QType = 1;
pub const QTYPE_QNUM: QType = 2;
pub const QTYPE_QSTRING: QType = 3;
pub const QTYPE_QDICT: QType = 4;
pub const QTYPE_QLIST: QType = 5;
pub const QTYPE_QBOOL: QType = 6;
pub const QTYPE__MAX: QType = 7;
pub type QType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static QType_lookup: QEnumLookup;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct strList {
    pub next: *mut strList,
    pub value: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of strList"][::std::mem::size_of::<strList>() - 16usize];
    ["Alignment of strList"][::std::mem::align_of::<strList>() - 8usize];
    ["Offset of field: strList::next"][::std::mem::offset_of!(strList, next) - 0usize];
    ["Offset of field: strList::value"][::std::mem::offset_of!(strList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_strList(obj: *mut strList);
}
pub type strList_autoptr = *mut strList;
pub type strList_listautoptr = *mut GList;
pub type strList_slistautoptr = *mut GSList;
pub type strList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct numberList {
    pub next: *mut numberList,
    pub value: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of numberList"][::std::mem::size_of::<numberList>() - 16usize];
    ["Alignment of numberList"][::std::mem::align_of::<numberList>() - 8usize];
    ["Offset of field: numberList::next"][::std::mem::offset_of!(numberList, next) - 0usize];
    ["Offset of field: numberList::value"][::std::mem::offset_of!(numberList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_numberList(obj: *mut numberList);
}
pub type numberList_autoptr = *mut numberList;
pub type numberList_listautoptr = *mut GList;
pub type numberList_slistautoptr = *mut GSList;
pub type numberList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct intList {
    pub next: *mut intList,
    pub value: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of intList"][::std::mem::size_of::<intList>() - 16usize];
    ["Alignment of intList"][::std::mem::align_of::<intList>() - 8usize];
    ["Offset of field: intList::next"][::std::mem::offset_of!(intList, next) - 0usize];
    ["Offset of field: intList::value"][::std::mem::offset_of!(intList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_intList(obj: *mut intList);
}
pub type intList_autoptr = *mut intList;
pub type intList_listautoptr = *mut GList;
pub type intList_slistautoptr = *mut GSList;
pub type intList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int8List {
    pub next: *mut int8List,
    pub value: i8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of int8List"][::std::mem::size_of::<int8List>() - 16usize];
    ["Alignment of int8List"][::std::mem::align_of::<int8List>() - 8usize];
    ["Offset of field: int8List::next"][::std::mem::offset_of!(int8List, next) - 0usize];
    ["Offset of field: int8List::value"][::std::mem::offset_of!(int8List, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_int8List(obj: *mut int8List);
}
pub type int8List_autoptr = *mut int8List;
pub type int8List_listautoptr = *mut GList;
pub type int8List_slistautoptr = *mut GSList;
pub type int8List_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int16List {
    pub next: *mut int16List,
    pub value: i16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of int16List"][::std::mem::size_of::<int16List>() - 16usize];
    ["Alignment of int16List"][::std::mem::align_of::<int16List>() - 8usize];
    ["Offset of field: int16List::next"][::std::mem::offset_of!(int16List, next) - 0usize];
    ["Offset of field: int16List::value"][::std::mem::offset_of!(int16List, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_int16List(obj: *mut int16List);
}
pub type int16List_autoptr = *mut int16List;
pub type int16List_listautoptr = *mut GList;
pub type int16List_slistautoptr = *mut GSList;
pub type int16List_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int32List {
    pub next: *mut int32List,
    pub value: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of int32List"][::std::mem::size_of::<int32List>() - 16usize];
    ["Alignment of int32List"][::std::mem::align_of::<int32List>() - 8usize];
    ["Offset of field: int32List::next"][::std::mem::offset_of!(int32List, next) - 0usize];
    ["Offset of field: int32List::value"][::std::mem::offset_of!(int32List, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_int32List(obj: *mut int32List);
}
pub type int32List_autoptr = *mut int32List;
pub type int32List_listautoptr = *mut GList;
pub type int32List_slistautoptr = *mut GSList;
pub type int32List_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int64List {
    pub next: *mut int64List,
    pub value: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of int64List"][::std::mem::size_of::<int64List>() - 16usize];
    ["Alignment of int64List"][::std::mem::align_of::<int64List>() - 8usize];
    ["Offset of field: int64List::next"][::std::mem::offset_of!(int64List, next) - 0usize];
    ["Offset of field: int64List::value"][::std::mem::offset_of!(int64List, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_int64List(obj: *mut int64List);
}
pub type int64List_autoptr = *mut int64List;
pub type int64List_listautoptr = *mut GList;
pub type int64List_slistautoptr = *mut GSList;
pub type int64List_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint8List {
    pub next: *mut uint8List,
    pub value: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uint8List"][::std::mem::size_of::<uint8List>() - 16usize];
    ["Alignment of uint8List"][::std::mem::align_of::<uint8List>() - 8usize];
    ["Offset of field: uint8List::next"][::std::mem::offset_of!(uint8List, next) - 0usize];
    ["Offset of field: uint8List::value"][::std::mem::offset_of!(uint8List, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_uint8List(obj: *mut uint8List);
}
pub type uint8List_autoptr = *mut uint8List;
pub type uint8List_listautoptr = *mut GList;
pub type uint8List_slistautoptr = *mut GSList;
pub type uint8List_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint16List {
    pub next: *mut uint16List,
    pub value: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uint16List"][::std::mem::size_of::<uint16List>() - 16usize];
    ["Alignment of uint16List"][::std::mem::align_of::<uint16List>() - 8usize];
    ["Offset of field: uint16List::next"][::std::mem::offset_of!(uint16List, next) - 0usize];
    ["Offset of field: uint16List::value"][::std::mem::offset_of!(uint16List, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_uint16List(obj: *mut uint16List);
}
pub type uint16List_autoptr = *mut uint16List;
pub type uint16List_listautoptr = *mut GList;
pub type uint16List_slistautoptr = *mut GSList;
pub type uint16List_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint32List {
    pub next: *mut uint32List,
    pub value: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uint32List"][::std::mem::size_of::<uint32List>() - 16usize];
    ["Alignment of uint32List"][::std::mem::align_of::<uint32List>() - 8usize];
    ["Offset of field: uint32List::next"][::std::mem::offset_of!(uint32List, next) - 0usize];
    ["Offset of field: uint32List::value"][::std::mem::offset_of!(uint32List, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_uint32List(obj: *mut uint32List);
}
pub type uint32List_autoptr = *mut uint32List;
pub type uint32List_listautoptr = *mut GList;
pub type uint32List_slistautoptr = *mut GSList;
pub type uint32List_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint64List {
    pub next: *mut uint64List,
    pub value: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uint64List"][::std::mem::size_of::<uint64List>() - 16usize];
    ["Alignment of uint64List"][::std::mem::align_of::<uint64List>() - 8usize];
    ["Offset of field: uint64List::next"][::std::mem::offset_of!(uint64List, next) - 0usize];
    ["Offset of field: uint64List::value"][::std::mem::offset_of!(uint64List, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_uint64List(obj: *mut uint64List);
}
pub type uint64List_autoptr = *mut uint64List;
pub type uint64List_listautoptr = *mut GList;
pub type uint64List_slistautoptr = *mut GSList;
pub type uint64List_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sizeList {
    pub next: *mut sizeList,
    pub value: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sizeList"][::std::mem::size_of::<sizeList>() - 16usize];
    ["Alignment of sizeList"][::std::mem::align_of::<sizeList>() - 8usize];
    ["Offset of field: sizeList::next"][::std::mem::offset_of!(sizeList, next) - 0usize];
    ["Offset of field: sizeList::value"][::std::mem::offset_of!(sizeList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_sizeList(obj: *mut sizeList);
}
pub type sizeList_autoptr = *mut sizeList;
pub type sizeList_listautoptr = *mut GList;
pub type sizeList_slistautoptr = *mut GSList;
pub type sizeList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct boolList {
    pub next: *mut boolList,
    pub value: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of boolList"][::std::mem::size_of::<boolList>() - 16usize];
    ["Alignment of boolList"][::std::mem::align_of::<boolList>() - 8usize];
    ["Offset of field: boolList::next"][::std::mem::offset_of!(boolList, next) - 0usize];
    ["Offset of field: boolList::value"][::std::mem::offset_of!(boolList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_boolList(obj: *mut boolList);
}
pub type boolList_autoptr = *mut boolList;
pub type boolList_listautoptr = *mut GList;
pub type boolList_slistautoptr = *mut GSList;
pub type boolList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct anyList {
    pub next: *mut anyList,
    pub value: *mut QObject,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of anyList"][::std::mem::size_of::<anyList>() - 16usize];
    ["Alignment of anyList"][::std::mem::align_of::<anyList>() - 8usize];
    ["Offset of field: anyList::next"][::std::mem::offset_of!(anyList, next) - 0usize];
    ["Offset of field: anyList::value"][::std::mem::offset_of!(anyList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_anyList(obj: *mut anyList);
}
pub type anyList_autoptr = *mut anyList;
pub type anyList_listautoptr = *mut GList;
pub type anyList_slistautoptr = *mut GSList;
pub type anyList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nullList {
    pub next: *mut nullList,
    pub value: *mut QNull,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of nullList"][::std::mem::size_of::<nullList>() - 16usize];
    ["Alignment of nullList"][::std::mem::align_of::<nullList>() - 8usize];
    ["Offset of field: nullList::next"][::std::mem::offset_of!(nullList, next) - 0usize];
    ["Offset of field: nullList::value"][::std::mem::offset_of!(nullList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_nullList(obj: *mut nullList);
}
pub type nullList_autoptr = *mut nullList;
pub type nullList_listautoptr = *mut GList;
pub type nullList_slistautoptr = *mut GSList;
pub type nullList_queueautoptr = *mut GQueue;
pub const MODULE_INIT_MIGRATION: module_init_type = 0;
pub const MODULE_INIT_BLOCK: module_init_type = 1;
pub const MODULE_INIT_OPTS: module_init_type = 2;
pub const MODULE_INIT_QOM: module_init_type = 3;
pub const MODULE_INIT_TRACE: module_init_type = 4;
pub const MODULE_INIT_XEN_BACKEND: module_init_type = 5;
pub const MODULE_INIT_LIBQOS: module_init_type = 6;
pub const MODULE_INIT_FUZZ_TARGET: module_init_type = 7;
pub const MODULE_INIT_MAX: module_init_type = 8;
pub type module_init_type = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn register_module_init(
        fn_: ::std::option::Option<unsafe extern "C" fn()>,
        type_: module_init_type,
    );
}
unsafe extern "C" {
    pub fn register_dso_module_init(
        fn_: ::std::option::Option<unsafe extern "C" fn()>,
        type_: module_init_type,
    );
}
unsafe extern "C" {
    pub fn module_call_init(type_: module_init_type);
}
unsafe extern "C" {
    pub fn module_load(
        prefix: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn module_load_qom(
        type_: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn module_load_qom_all();
}
unsafe extern "C" {
    pub fn module_allow_arch(arch: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuModinfo {
    pub name: *const ::std::os::raw::c_char,
    pub arch: *const ::std::os::raw::c_char,
    pub objs: *mut *const ::std::os::raw::c_char,
    pub deps: *mut *const ::std::os::raw::c_char,
    pub opts: *mut *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuModinfo"][::std::mem::size_of::<QemuModinfo>() - 40usize];
    ["Alignment of QemuModinfo"][::std::mem::align_of::<QemuModinfo>() - 8usize];
    ["Offset of field: QemuModinfo::name"][::std::mem::offset_of!(QemuModinfo, name) - 0usize];
    ["Offset of field: QemuModinfo::arch"][::std::mem::offset_of!(QemuModinfo, arch) - 8usize];
    ["Offset of field: QemuModinfo::objs"][::std::mem::offset_of!(QemuModinfo, objs) - 16usize];
    ["Offset of field: QemuModinfo::deps"][::std::mem::offset_of!(QemuModinfo, deps) - 24usize];
    ["Offset of field: QemuModinfo::opts"][::std::mem::offset_of!(QemuModinfo, opts) - 32usize];
};
unsafe extern "C" {
    pub static qemu_modinfo: [QemuModinfo; 0usize];
}
unsafe extern "C" {
    pub fn module_init_info(info: *const QemuModinfo);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeImpl {
    _unused: [u8; 0],
}
pub type Type = *mut TypeImpl;
pub type ObjectPropertyAccessor = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut Object,
        v: *mut Visitor,
        name: *const ::std::os::raw::c_char,
        opaque: *mut ::std::os::raw::c_void,
        errp: *mut *mut Error,
    ),
>;
pub type ObjectPropertyResolve = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut Object,
        opaque: *mut ::std::os::raw::c_void,
        part: *const ::std::os::raw::c_char,
    ) -> *mut Object,
>;
pub type ObjectPropertyRelease = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        opaque: *mut ::std::os::raw::c_void,
    ),
>;
pub type ObjectPropertyInit =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut Object, prop: *mut ObjectProperty)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectProperty {
    pub name: *mut ::std::os::raw::c_char,
    pub type_: *mut ::std::os::raw::c_char,
    pub description: *mut ::std::os::raw::c_char,
    pub get: ObjectPropertyAccessor,
    pub set: ObjectPropertyAccessor,
    pub resolve: ObjectPropertyResolve,
    pub release: ObjectPropertyRelease,
    pub init: ObjectPropertyInit,
    pub opaque: *mut ::std::os::raw::c_void,
    pub defval: *mut QObject,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ObjectProperty"][::std::mem::size_of::<ObjectProperty>() - 80usize];
    ["Alignment of ObjectProperty"][::std::mem::align_of::<ObjectProperty>() - 8usize];
    ["Offset of field: ObjectProperty::name"]
        [::std::mem::offset_of!(ObjectProperty, name) - 0usize];
    ["Offset of field: ObjectProperty::type_"]
        [::std::mem::offset_of!(ObjectProperty, type_) - 8usize];
    ["Offset of field: ObjectProperty::description"]
        [::std::mem::offset_of!(ObjectProperty, description) - 16usize];
    ["Offset of field: ObjectProperty::get"][::std::mem::offset_of!(ObjectProperty, get) - 24usize];
    ["Offset of field: ObjectProperty::set"][::std::mem::offset_of!(ObjectProperty, set) - 32usize];
    ["Offset of field: ObjectProperty::resolve"]
        [::std::mem::offset_of!(ObjectProperty, resolve) - 40usize];
    ["Offset of field: ObjectProperty::release"]
        [::std::mem::offset_of!(ObjectProperty, release) - 48usize];
    ["Offset of field: ObjectProperty::init"]
        [::std::mem::offset_of!(ObjectProperty, init) - 56usize];
    ["Offset of field: ObjectProperty::opaque"]
        [::std::mem::offset_of!(ObjectProperty, opaque) - 64usize];
    ["Offset of field: ObjectProperty::defval"]
        [::std::mem::offset_of!(ObjectProperty, defval) - 72usize];
};
pub type ObjectUnparent = ::std::option::Option<unsafe extern "C" fn(obj: *mut Object)>;
pub type ObjectFree = ::std::option::Option<unsafe extern "C" fn(obj: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectClass {
    pub type_: Type,
    pub interfaces: *mut GSList,
    pub object_cast_cache: [*const ::std::os::raw::c_char; 4usize],
    pub class_cast_cache: [*const ::std::os::raw::c_char; 4usize],
    pub unparent: ObjectUnparent,
    pub properties: *mut GHashTable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ObjectClass"][::std::mem::size_of::<ObjectClass>() - 96usize];
    ["Alignment of ObjectClass"][::std::mem::align_of::<ObjectClass>() - 8usize];
    ["Offset of field: ObjectClass::type_"][::std::mem::offset_of!(ObjectClass, type_) - 0usize];
    ["Offset of field: ObjectClass::interfaces"]
        [::std::mem::offset_of!(ObjectClass, interfaces) - 8usize];
    ["Offset of field: ObjectClass::object_cast_cache"]
        [::std::mem::offset_of!(ObjectClass, object_cast_cache) - 16usize];
    ["Offset of field: ObjectClass::class_cast_cache"]
        [::std::mem::offset_of!(ObjectClass, class_cast_cache) - 48usize];
    ["Offset of field: ObjectClass::unparent"]
        [::std::mem::offset_of!(ObjectClass, unparent) - 80usize];
    ["Offset of field: ObjectClass::properties"]
        [::std::mem::offset_of!(ObjectClass, properties) - 88usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Object {
    pub class: *mut ObjectClass,
    pub free: ObjectFree,
    pub properties: *mut GHashTable,
    pub ref_: u32,
    pub parent: *mut Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Object"][::std::mem::size_of::<Object>() - 40usize];
    ["Alignment of Object"][::std::mem::align_of::<Object>() - 8usize];
    ["Offset of field: Object::class"][::std::mem::offset_of!(Object, class) - 0usize];
    ["Offset of field: Object::free"][::std::mem::offset_of!(Object, free) - 8usize];
    ["Offset of field: Object::properties"][::std::mem::offset_of!(Object, properties) - 16usize];
    ["Offset of field: Object::ref_"][::std::mem::offset_of!(Object, ref_) - 24usize];
    ["Offset of field: Object::parent"][::std::mem::offset_of!(Object, parent) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeInfo {
    pub name: *const ::std::os::raw::c_char,
    pub parent: *const ::std::os::raw::c_char,
    pub instance_size: usize,
    pub instance_align: usize,
    pub instance_init: ::std::option::Option<unsafe extern "C" fn(obj: *mut Object)>,
    pub instance_post_init: ::std::option::Option<unsafe extern "C" fn(obj: *mut Object)>,
    pub instance_finalize: ::std::option::Option<unsafe extern "C" fn(obj: *mut Object)>,
    pub abstract_: bool,
    pub class_size: usize,
    pub class_init: ::std::option::Option<
        unsafe extern "C" fn(klass: *mut ObjectClass, data: *mut ::std::os::raw::c_void),
    >,
    pub class_base_init: ::std::option::Option<
        unsafe extern "C" fn(klass: *mut ObjectClass, data: *mut ::std::os::raw::c_void),
    >,
    pub class_data: *mut ::std::os::raw::c_void,
    pub interfaces: *mut InterfaceInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TypeInfo"][::std::mem::size_of::<TypeInfo>() - 104usize];
    ["Alignment of TypeInfo"][::std::mem::align_of::<TypeInfo>() - 8usize];
    ["Offset of field: TypeInfo::name"][::std::mem::offset_of!(TypeInfo, name) - 0usize];
    ["Offset of field: TypeInfo::parent"][::std::mem::offset_of!(TypeInfo, parent) - 8usize];
    ["Offset of field: TypeInfo::instance_size"]
        [::std::mem::offset_of!(TypeInfo, instance_size) - 16usize];
    ["Offset of field: TypeInfo::instance_align"]
        [::std::mem::offset_of!(TypeInfo, instance_align) - 24usize];
    ["Offset of field: TypeInfo::instance_init"]
        [::std::mem::offset_of!(TypeInfo, instance_init) - 32usize];
    ["Offset of field: TypeInfo::instance_post_init"]
        [::std::mem::offset_of!(TypeInfo, instance_post_init) - 40usize];
    ["Offset of field: TypeInfo::instance_finalize"]
        [::std::mem::offset_of!(TypeInfo, instance_finalize) - 48usize];
    ["Offset of field: TypeInfo::abstract_"][::std::mem::offset_of!(TypeInfo, abstract_) - 56usize];
    ["Offset of field: TypeInfo::class_size"]
        [::std::mem::offset_of!(TypeInfo, class_size) - 64usize];
    ["Offset of field: TypeInfo::class_init"]
        [::std::mem::offset_of!(TypeInfo, class_init) - 72usize];
    ["Offset of field: TypeInfo::class_base_init"]
        [::std::mem::offset_of!(TypeInfo, class_base_init) - 80usize];
    ["Offset of field: TypeInfo::class_data"]
        [::std::mem::offset_of!(TypeInfo, class_data) - 88usize];
    ["Offset of field: TypeInfo::interfaces"]
        [::std::mem::offset_of!(TypeInfo, interfaces) - 96usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InterfaceInfo {
    pub type_: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of InterfaceInfo"][::std::mem::size_of::<InterfaceInfo>() - 8usize];
    ["Alignment of InterfaceInfo"][::std::mem::align_of::<InterfaceInfo>() - 8usize];
    ["Offset of field: InterfaceInfo::type_"]
        [::std::mem::offset_of!(InterfaceInfo, type_) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InterfaceClass {
    pub parent_class: ObjectClass,
    pub interface_type: Type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of InterfaceClass"][::std::mem::size_of::<InterfaceClass>() - 104usize];
    ["Alignment of InterfaceClass"][::std::mem::align_of::<InterfaceClass>() - 8usize];
    ["Offset of field: InterfaceClass::parent_class"]
        [::std::mem::offset_of!(InterfaceClass, parent_class) - 0usize];
    ["Offset of field: InterfaceClass::interface_type"]
        [::std::mem::offset_of!(InterfaceClass, interface_type) - 96usize];
};
unsafe extern "C" {
    pub fn object_new_with_class(klass: *mut ObjectClass) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_new(typename: *const ::std::os::raw::c_char) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_new_with_props(
        typename: *const ::std::os::raw::c_char,
        parent: *mut Object,
        id: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
        ...
    ) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_new_with_propv(
        typename: *const ::std::os::raw::c_char,
        parent: *mut Object,
        id: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
        vargs: *mut __va_list_tag,
    ) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_apply_global_props(
        obj: *mut Object,
        props: *const GPtrArray,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn object_set_machine_compat_props(compat_props: *mut GPtrArray);
}
unsafe extern "C" {
    pub fn object_set_accelerator_compat_props(compat_props: *mut GPtrArray);
}
unsafe extern "C" {
    pub fn object_register_sugar_prop(
        driver: *const ::std::os::raw::c_char,
        prop: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        optional: bool,
    );
}
unsafe extern "C" {
    pub fn object_apply_compat_props(obj: *mut Object);
}
unsafe extern "C" {
    pub fn object_set_props(obj: *mut Object, errp: *mut *mut Error, ...) -> bool;
}
unsafe extern "C" {
    pub fn object_set_propv(
        obj: *mut Object,
        errp: *mut *mut Error,
        vargs: *mut __va_list_tag,
    ) -> bool;
}
unsafe extern "C" {
    pub fn object_initialize(
        obj: *mut ::std::os::raw::c_void,
        size: usize,
        typename: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn object_initialize_child_with_props(
        parentobj: *mut Object,
        propname: *const ::std::os::raw::c_char,
        childobj: *mut ::std::os::raw::c_void,
        size: usize,
        type_: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
        ...
    ) -> bool;
}
unsafe extern "C" {
    pub fn object_initialize_child_with_propsv(
        parentobj: *mut Object,
        propname: *const ::std::os::raw::c_char,
        childobj: *mut ::std::os::raw::c_void,
        size: usize,
        type_: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
        vargs: *mut __va_list_tag,
    ) -> bool;
}
unsafe extern "C" {
    pub fn object_initialize_child_internal(
        parent: *mut Object,
        propname: *const ::std::os::raw::c_char,
        child: *mut ::std::os::raw::c_void,
        size: usize,
        type_: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn object_dynamic_cast(
        obj: *mut Object,
        typename: *const ::std::os::raw::c_char,
    ) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_dynamic_cast_assert(
        obj: *mut Object,
        typename: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    ) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_get_class(obj: *mut Object) -> *mut ObjectClass;
}
unsafe extern "C" {
    pub fn object_get_typename(obj: *const Object) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn type_register_static(info: *const TypeInfo) -> Type;
}
unsafe extern "C" {
    pub fn type_register_static_array(infos: *const TypeInfo, nr_infos: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn type_print_class_properties(type_: *const ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    pub fn object_set_properties_from_keyval(
        obj: *mut Object,
        qdict: *const QDict,
        from_json: bool,
        errp: *mut *mut Error,
    );
}
unsafe extern "C" {
    pub fn object_class_dynamic_cast_assert(
        klass: *mut ObjectClass,
        typename: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    ) -> *mut ObjectClass;
}
unsafe extern "C" {
    pub fn object_class_dynamic_cast(
        klass: *mut ObjectClass,
        typename: *const ::std::os::raw::c_char,
    ) -> *mut ObjectClass;
}
unsafe extern "C" {
    pub fn object_class_get_parent(klass: *mut ObjectClass) -> *mut ObjectClass;
}
unsafe extern "C" {
    pub fn object_class_get_name(klass: *mut ObjectClass) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn object_class_is_abstract(klass: *mut ObjectClass) -> bool;
}
unsafe extern "C" {
    pub fn object_class_by_name(typename: *const ::std::os::raw::c_char) -> *mut ObjectClass;
}
unsafe extern "C" {
    pub fn module_object_class_by_name(typename: *const ::std::os::raw::c_char)
        -> *mut ObjectClass;
}
unsafe extern "C" {
    pub fn object_class_foreach(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(klass: *mut ObjectClass, opaque: *mut ::std::os::raw::c_void),
        >,
        implements_type: *const ::std::os::raw::c_char,
        include_abstract: bool,
        opaque: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn object_class_get_list(
        implements_type: *const ::std::os::raw::c_char,
        include_abstract: bool,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn object_class_get_list_sorted(
        implements_type: *const ::std::os::raw::c_char,
        include_abstract: bool,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn object_ref(obj: *mut ::std::os::raw::c_void) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_unref(obj: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn object_property_try_add(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        get: ObjectPropertyAccessor,
        set: ObjectPropertyAccessor,
        release: ObjectPropertyRelease,
        opaque: *mut ::std::os::raw::c_void,
        errp: *mut *mut Error,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_add(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        get: ObjectPropertyAccessor,
        set: ObjectPropertyAccessor,
        release: ObjectPropertyRelease,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_del(obj: *mut Object, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn object_class_property_add(
        klass: *mut ObjectClass,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        get: ObjectPropertyAccessor,
        set: ObjectPropertyAccessor,
        release: ObjectPropertyRelease,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_set_default_bool(prop: *mut ObjectProperty, value: bool);
}
unsafe extern "C" {
    pub fn object_property_set_default_str(
        prop: *mut ObjectProperty,
        value: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn object_property_set_default_list(prop: *mut ObjectProperty);
}
unsafe extern "C" {
    pub fn object_property_set_default_int(prop: *mut ObjectProperty, value: i64);
}
unsafe extern "C" {
    pub fn object_property_set_default_uint(prop: *mut ObjectProperty, value: u64);
}
unsafe extern "C" {
    pub fn object_property_find(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_find_err(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_class_property_find(
        klass: *mut ObjectClass,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_class_property_find_err(
        klass: *mut ObjectClass,
        name: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> *mut ObjectProperty;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectPropertyIterator {
    pub nextclass: *mut ObjectClass,
    pub iter: GHashTableIter,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ObjectPropertyIterator"][::std::mem::size_of::<ObjectPropertyIterator>() - 48usize];
    ["Alignment of ObjectPropertyIterator"]
        [::std::mem::align_of::<ObjectPropertyIterator>() - 8usize];
    ["Offset of field: ObjectPropertyIterator::nextclass"]
        [::std::mem::offset_of!(ObjectPropertyIterator, nextclass) - 0usize];
    ["Offset of field: ObjectPropertyIterator::iter"]
        [::std::mem::offset_of!(ObjectPropertyIterator, iter) - 8usize];
};
unsafe extern "C" {
    pub fn object_property_iter_init(iter: *mut ObjectPropertyIterator, obj: *mut Object);
}
unsafe extern "C" {
    pub fn object_class_property_iter_init(
        iter: *mut ObjectPropertyIterator,
        klass: *mut ObjectClass,
    );
}
unsafe extern "C" {
    pub fn object_property_iter_next(iter: *mut ObjectPropertyIterator) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_unparent(obj: *mut Object);
}
unsafe extern "C" {
    pub fn object_property_get(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        v: *mut Visitor,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn object_property_set_str(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn object_property_get_str(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn object_property_set_link(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        value: *mut Object,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn object_property_get_link(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_property_set_bool(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        value: bool,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn object_property_get_bool(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn object_property_set_int(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        value: i64,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn object_property_get_int(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> i64;
}
unsafe extern "C" {
    pub fn object_property_set_uint(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        value: u64,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn object_property_get_uint(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> u64;
}
unsafe extern "C" {
    pub fn object_property_get_enum(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        typename: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn object_property_set(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        v: *mut Visitor,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn object_property_parse(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        string: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn object_property_print(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        human: bool,
        errp: *mut *mut Error,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn object_property_get_type(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn object_get_root() -> *mut Object;
}
unsafe extern "C" {
    pub fn object_get_container(name: *const ::std::os::raw::c_char) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_get_objects_root() -> *mut Object;
}
unsafe extern "C" {
    pub fn object_get_internal_root() -> *mut Object;
}
unsafe extern "C" {
    pub fn object_get_canonical_path_component(obj: *const Object)
        -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn object_get_canonical_path(obj: *const Object) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn object_resolve_path(
        path: *const ::std::os::raw::c_char,
        ambiguous: *mut bool,
    ) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_resolve_path_type(
        path: *const ::std::os::raw::c_char,
        typename: *const ::std::os::raw::c_char,
        ambiguous: *mut bool,
    ) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_resolve_type_unambiguous(
        typename: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_resolve_path_at(
        parent: *mut Object,
        path: *const ::std::os::raw::c_char,
    ) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_resolve_path_component(
        parent: *mut Object,
        part: *const ::std::os::raw::c_char,
    ) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_property_try_add_child(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        child: *mut Object,
        errp: *mut *mut Error,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_add_child(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        child: *mut Object,
    ) -> *mut ObjectProperty;
}
pub const OBJ_PROP_LINK_STRONG: ObjectPropertyLinkFlags = 1;
pub const OBJ_PROP_LINK_DIRECT: ObjectPropertyLinkFlags = 2;
pub const OBJ_PROP_LINK_CLASS: ObjectPropertyLinkFlags = 4;
pub type ObjectPropertyLinkFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn object_property_allow_set_link(
        obj: *const Object,
        name: *const ::std::os::raw::c_char,
        child: *mut Object,
        errp: *mut *mut Error,
    );
}
unsafe extern "C" {
    pub fn object_property_add_link(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        targetp: *mut *mut Object,
        check: ::std::option::Option<
            unsafe extern "C" fn(
                obj: *const Object,
                name: *const ::std::os::raw::c_char,
                val: *mut Object,
                errp: *mut *mut Error,
            ),
        >,
        flags: ObjectPropertyLinkFlags,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_class_property_add_link(
        oc: *mut ObjectClass,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        offset: isize,
        check: ::std::option::Option<
            unsafe extern "C" fn(
                obj: *const Object,
                name: *const ::std::os::raw::c_char,
                val: *mut Object,
                errp: *mut *mut Error,
            ),
        >,
        flags: ObjectPropertyLinkFlags,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_add_str(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        get: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Object,
                arg2: *mut *mut Error,
            ) -> *mut ::std::os::raw::c_char,
        >,
        set: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Object,
                arg2: *const ::std::os::raw::c_char,
                arg3: *mut *mut Error,
            ),
        >,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_class_property_add_str(
        klass: *mut ObjectClass,
        name: *const ::std::os::raw::c_char,
        get: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Object,
                arg2: *mut *mut Error,
            ) -> *mut ::std::os::raw::c_char,
        >,
        set: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Object,
                arg2: *const ::std::os::raw::c_char,
                arg3: *mut *mut Error,
            ),
        >,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_add_bool(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        get: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: *mut *mut Error) -> bool,
        >,
        set: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: bool, arg3: *mut *mut Error),
        >,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_class_property_add_bool(
        klass: *mut ObjectClass,
        name: *const ::std::os::raw::c_char,
        get: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: *mut *mut Error) -> bool,
        >,
        set: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: bool, arg3: *mut *mut Error),
        >,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_add_enum(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        typename: *const ::std::os::raw::c_char,
        lookup: *const QEnumLookup,
        get: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: *mut *mut Error) -> ::std::os::raw::c_int,
        >,
        set: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Object,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut Error,
            ),
        >,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_class_property_add_enum(
        klass: *mut ObjectClass,
        name: *const ::std::os::raw::c_char,
        typename: *const ::std::os::raw::c_char,
        lookup: *const QEnumLookup,
        get: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: *mut *mut Error) -> ::std::os::raw::c_int,
        >,
        set: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Object,
                arg2: ::std::os::raw::c_int,
                arg3: *mut *mut Error,
            ),
        >,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_add_tm(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        get: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: *mut tm, arg3: *mut *mut Error),
        >,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_class_property_add_tm(
        klass: *mut ObjectClass,
        name: *const ::std::os::raw::c_char,
        get: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: *mut tm, arg3: *mut *mut Error),
        >,
    ) -> *mut ObjectProperty;
}
pub const OBJ_PROP_FLAG_READ: ObjectPropertyFlags = 1;
pub const OBJ_PROP_FLAG_WRITE: ObjectPropertyFlags = 2;
pub const OBJ_PROP_FLAG_READWRITE: ObjectPropertyFlags = 3;
pub type ObjectPropertyFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn object_property_add_uint8_ptr(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        v: *const u8,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_class_property_add_uint8_ptr(
        klass: *mut ObjectClass,
        name: *const ::std::os::raw::c_char,
        v: *const u8,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_add_uint16_ptr(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        v: *const u16,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_class_property_add_uint16_ptr(
        klass: *mut ObjectClass,
        name: *const ::std::os::raw::c_char,
        v: *const u16,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_add_uint32_ptr(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        v: *const u32,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_class_property_add_uint32_ptr(
        klass: *mut ObjectClass,
        name: *const ::std::os::raw::c_char,
        v: *const u32,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_add_uint64_ptr(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        v: *const u64,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_class_property_add_uint64_ptr(
        klass: *mut ObjectClass,
        name: *const ::std::os::raw::c_char,
        v: *const u64,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_add_alias(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        target_obj: *mut Object,
        target_name: *const ::std::os::raw::c_char,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_add_const_link(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        target: *mut Object,
    ) -> *mut ObjectProperty;
}
unsafe extern "C" {
    pub fn object_property_set_description(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn object_class_property_set_description(
        klass: *mut ObjectClass,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn object_child_foreach(
        obj: *mut Object,
        fn_: ::std::option::Option<
            unsafe extern "C" fn(
                child: *mut Object,
                opaque: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn object_child_foreach_recursive(
        obj: *mut Object,
        fn_: ::std::option::Option<
            unsafe extern "C" fn(
                child: *mut Object,
                opaque: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn object_property_add_new_container(
        obj: *mut Object,
        name: *const ::std::os::raw::c_char,
    ) -> *mut Object;
}
unsafe extern "C" {
    pub fn object_property_help(
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        defval: *mut QObject,
        description: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type Object_autoptr = *mut Object;
pub type Object_listautoptr = *mut GList;
pub type Object_slistautoptr = *mut GSList;
pub type Object_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HotplugHandler {
    _unused: [u8; 0],
}
pub type hotplug_fn = ::std::option::Option<
    unsafe extern "C" fn(
        plug_handler: *mut HotplugHandler,
        plugged_dev: *mut DeviceState,
        errp: *mut *mut Error,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HotplugHandlerClass {
    pub parent: InterfaceClass,
    pub pre_plug: hotplug_fn,
    pub plug: hotplug_fn,
    pub unplug_request: hotplug_fn,
    pub unplug: hotplug_fn,
    pub is_hotpluggable_bus: ::std::option::Option<
        unsafe extern "C" fn(plug_handler: *mut HotplugHandler, bus: *mut BusState) -> bool,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HotplugHandlerClass"][::std::mem::size_of::<HotplugHandlerClass>() - 144usize];
    ["Alignment of HotplugHandlerClass"][::std::mem::align_of::<HotplugHandlerClass>() - 8usize];
    ["Offset of field: HotplugHandlerClass::parent"]
        [::std::mem::offset_of!(HotplugHandlerClass, parent) - 0usize];
    ["Offset of field: HotplugHandlerClass::pre_plug"]
        [::std::mem::offset_of!(HotplugHandlerClass, pre_plug) - 104usize];
    ["Offset of field: HotplugHandlerClass::plug"]
        [::std::mem::offset_of!(HotplugHandlerClass, plug) - 112usize];
    ["Offset of field: HotplugHandlerClass::unplug_request"]
        [::std::mem::offset_of!(HotplugHandlerClass, unplug_request) - 120usize];
    ["Offset of field: HotplugHandlerClass::unplug"]
        [::std::mem::offset_of!(HotplugHandlerClass, unplug) - 128usize];
    ["Offset of field: HotplugHandlerClass::is_hotpluggable_bus"]
        [::std::mem::offset_of!(HotplugHandlerClass, is_hotpluggable_bus) - 136usize];
};
unsafe extern "C" {
    pub fn hotplug_handler_plug(
        plug_handler: *mut HotplugHandler,
        plugged_dev: *mut DeviceState,
        errp: *mut *mut Error,
    );
}
unsafe extern "C" {
    pub fn hotplug_handler_pre_plug(
        plug_handler: *mut HotplugHandler,
        plugged_dev: *mut DeviceState,
        errp: *mut *mut Error,
    );
}
unsafe extern "C" {
    pub fn hotplug_handler_unplug_request(
        plug_handler: *mut HotplugHandler,
        plugged_dev: *mut DeviceState,
        errp: *mut *mut Error,
    );
}
unsafe extern "C" {
    pub fn hotplug_handler_unplug(
        plug_handler: *mut HotplugHandler,
        plugged_dev: *mut DeviceState,
        errp: *mut *mut Error,
    );
}
pub const RESET_TYPE_COLD: ResetType = 0;
pub const RESET_TYPE_SNAPSHOT_LOAD: ResetType = 1;
pub const RESET_TYPE_WAKEUP: ResetType = 2;
pub const RESET_TYPE_S390_CPU_INITIAL: ResetType = 3;
pub const RESET_TYPE_S390_CPU_NORMAL: ResetType = 4;
pub type ResetType = ::std::os::raw::c_uint;
pub type ResettableEnterPhase =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut Object, type_: ResetType)>;
pub type ResettableHoldPhase =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut Object, type_: ResetType)>;
pub type ResettableExitPhase =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut Object, type_: ResetType)>;
pub type ResettableGetState =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut Object) -> *mut ResettableState>;
pub type ResettableChildCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut Object, opaque: *mut ::std::os::raw::c_void, type_: ResetType),
>;
pub type ResettableChildForeach = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut Object,
        cb: ResettableChildCallback,
        opaque: *mut ::std::os::raw::c_void,
        type_: ResetType,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResettablePhases {
    pub enter: ResettableEnterPhase,
    pub hold: ResettableHoldPhase,
    pub exit: ResettableExitPhase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ResettablePhases"][::std::mem::size_of::<ResettablePhases>() - 24usize];
    ["Alignment of ResettablePhases"][::std::mem::align_of::<ResettablePhases>() - 8usize];
    ["Offset of field: ResettablePhases::enter"]
        [::std::mem::offset_of!(ResettablePhases, enter) - 0usize];
    ["Offset of field: ResettablePhases::hold"]
        [::std::mem::offset_of!(ResettablePhases, hold) - 8usize];
    ["Offset of field: ResettablePhases::exit"]
        [::std::mem::offset_of!(ResettablePhases, exit) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResettableClass {
    pub parent_class: InterfaceClass,
    pub phases: ResettablePhases,
    pub get_state: ResettableGetState,
    pub child_foreach: ResettableChildForeach,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ResettableClass"][::std::mem::size_of::<ResettableClass>() - 144usize];
    ["Alignment of ResettableClass"][::std::mem::align_of::<ResettableClass>() - 8usize];
    ["Offset of field: ResettableClass::parent_class"]
        [::std::mem::offset_of!(ResettableClass, parent_class) - 0usize];
    ["Offset of field: ResettableClass::phases"]
        [::std::mem::offset_of!(ResettableClass, phases) - 104usize];
    ["Offset of field: ResettableClass::get_state"]
        [::std::mem::offset_of!(ResettableClass, get_state) - 128usize];
    ["Offset of field: ResettableClass::child_foreach"]
        [::std::mem::offset_of!(ResettableClass, child_foreach) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResettableState {
    pub count: ::std::os::raw::c_uint,
    pub hold_phase_pending: bool,
    pub exit_phase_in_progress: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ResettableState"][::std::mem::size_of::<ResettableState>() - 8usize];
    ["Alignment of ResettableState"][::std::mem::align_of::<ResettableState>() - 4usize];
    ["Offset of field: ResettableState::count"]
        [::std::mem::offset_of!(ResettableState, count) - 0usize];
    ["Offset of field: ResettableState::hold_phase_pending"]
        [::std::mem::offset_of!(ResettableState, hold_phase_pending) - 4usize];
    ["Offset of field: ResettableState::exit_phase_in_progress"]
        [::std::mem::offset_of!(ResettableState, exit_phase_in_progress) - 5usize];
};
unsafe extern "C" {
    pub fn resettable_reset(obj: *mut Object, type_: ResetType);
}
unsafe extern "C" {
    pub fn resettable_assert_reset(obj: *mut Object, type_: ResetType);
}
unsafe extern "C" {
    pub fn resettable_release_reset(obj: *mut Object, type_: ResetType);
}
unsafe extern "C" {
    pub fn resettable_is_in_reset(obj: *mut Object) -> bool;
}
unsafe extern "C" {
    pub fn resettable_change_parent(obj: *mut Object, newp: *mut Object, oldp: *mut Object);
}
unsafe extern "C" {
    pub fn resettable_cold_reset_fn(opaque: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn resettable_class_set_parent_phases(
        rc: *mut ResettableClass,
        enter: ResettableEnterPhase,
        hold: ResettableHoldPhase,
        exit: ResettableExitPhase,
        parent_phases: *mut ResettablePhases,
    );
}
pub const DEV_NVECTORS_UNSPECIFIED: _bindgen_ty_37 = -1;
pub type _bindgen_ty_37 = ::std::os::raw::c_int;
pub type DeviceState_autoptr = *mut DeviceState;
pub type DeviceState_listautoptr = *mut GList;
pub type DeviceState_slistautoptr = *mut GSList;
pub type DeviceState_queueautoptr = *mut GQueue;
pub const DEVICE_CATEGORY_BRIDGE: DeviceCategory = 0;
pub const DEVICE_CATEGORY_USB: DeviceCategory = 1;
pub const DEVICE_CATEGORY_STORAGE: DeviceCategory = 2;
pub const DEVICE_CATEGORY_NETWORK: DeviceCategory = 3;
pub const DEVICE_CATEGORY_INPUT: DeviceCategory = 4;
pub const DEVICE_CATEGORY_DISPLAY: DeviceCategory = 5;
pub const DEVICE_CATEGORY_SOUND: DeviceCategory = 6;
pub const DEVICE_CATEGORY_MISC: DeviceCategory = 7;
pub const DEVICE_CATEGORY_CPU: DeviceCategory = 8;
pub const DEVICE_CATEGORY_WATCHDOG: DeviceCategory = 9;
pub const DEVICE_CATEGORY_MAX: DeviceCategory = 10;
pub type DeviceCategory = ::std::os::raw::c_uint;
pub type DeviceRealize =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut DeviceState, errp: *mut *mut Error)>;
pub type DeviceUnrealize = ::std::option::Option<unsafe extern "C" fn(dev: *mut DeviceState)>;
pub type DeviceReset = ::std::option::Option<unsafe extern "C" fn(dev: *mut DeviceState)>;
pub type BusRealize =
    ::std::option::Option<unsafe extern "C" fn(bus: *mut BusState, errp: *mut *mut Error)>;
pub type BusUnrealize = ::std::option::Option<unsafe extern "C" fn(bus: *mut BusState)>;
pub type DeviceSyncConfig = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut DeviceState, errp: *mut *mut Error) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceClass {
    pub parent_class: ObjectClass,
    pub categories: [::std::os::raw::c_ulong; 1usize],
    pub fw_name: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
    pub props_: *const Property,
    pub props_count_: u16,
    pub user_creatable: bool,
    pub hotpluggable: bool,
    pub legacy_reset: DeviceReset,
    pub realize: DeviceRealize,
    pub unrealize: DeviceUnrealize,
    pub sync_config: DeviceSyncConfig,
    pub vmsd: *const VMStateDescription,
    pub bus_type: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DeviceClass"][::std::mem::size_of::<DeviceClass>() - 184usize];
    ["Alignment of DeviceClass"][::std::mem::align_of::<DeviceClass>() - 8usize];
    ["Offset of field: DeviceClass::parent_class"]
        [::std::mem::offset_of!(DeviceClass, parent_class) - 0usize];
    ["Offset of field: DeviceClass::categories"]
        [::std::mem::offset_of!(DeviceClass, categories) - 96usize];
    ["Offset of field: DeviceClass::fw_name"]
        [::std::mem::offset_of!(DeviceClass, fw_name) - 104usize];
    ["Offset of field: DeviceClass::desc"][::std::mem::offset_of!(DeviceClass, desc) - 112usize];
    ["Offset of field: DeviceClass::props_"]
        [::std::mem::offset_of!(DeviceClass, props_) - 120usize];
    ["Offset of field: DeviceClass::props_count_"]
        [::std::mem::offset_of!(DeviceClass, props_count_) - 128usize];
    ["Offset of field: DeviceClass::user_creatable"]
        [::std::mem::offset_of!(DeviceClass, user_creatable) - 130usize];
    ["Offset of field: DeviceClass::hotpluggable"]
        [::std::mem::offset_of!(DeviceClass, hotpluggable) - 131usize];
    ["Offset of field: DeviceClass::legacy_reset"]
        [::std::mem::offset_of!(DeviceClass, legacy_reset) - 136usize];
    ["Offset of field: DeviceClass::realize"]
        [::std::mem::offset_of!(DeviceClass, realize) - 144usize];
    ["Offset of field: DeviceClass::unrealize"]
        [::std::mem::offset_of!(DeviceClass, unrealize) - 152usize];
    ["Offset of field: DeviceClass::sync_config"]
        [::std::mem::offset_of!(DeviceClass, sync_config) - 160usize];
    ["Offset of field: DeviceClass::vmsd"][::std::mem::offset_of!(DeviceClass, vmsd) - 168usize];
    ["Offset of field: DeviceClass::bus_type"]
        [::std::mem::offset_of!(DeviceClass, bus_type) - 176usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedGPIOList {
    pub name: *mut ::std::os::raw::c_char,
    pub in_: *mut qemu_irq,
    pub num_in: ::std::os::raw::c_int,
    pub num_out: ::std::os::raw::c_int,
    pub node: NamedGPIOList__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedGPIOList__bindgen_ty_1 {
    pub le_next: *mut NamedGPIOList,
    pub le_prev: *mut *mut NamedGPIOList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NamedGPIOList__bindgen_ty_1"]
        [::std::mem::size_of::<NamedGPIOList__bindgen_ty_1>() - 16usize];
    ["Alignment of NamedGPIOList__bindgen_ty_1"]
        [::std::mem::align_of::<NamedGPIOList__bindgen_ty_1>() - 8usize];
    ["Offset of field: NamedGPIOList__bindgen_ty_1::le_next"]
        [::std::mem::offset_of!(NamedGPIOList__bindgen_ty_1, le_next) - 0usize];
    ["Offset of field: NamedGPIOList__bindgen_ty_1::le_prev"]
        [::std::mem::offset_of!(NamedGPIOList__bindgen_ty_1, le_prev) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NamedGPIOList"][::std::mem::size_of::<NamedGPIOList>() - 40usize];
    ["Alignment of NamedGPIOList"][::std::mem::align_of::<NamedGPIOList>() - 8usize];
    ["Offset of field: NamedGPIOList::name"][::std::mem::offset_of!(NamedGPIOList, name) - 0usize];
    ["Offset of field: NamedGPIOList::in_"][::std::mem::offset_of!(NamedGPIOList, in_) - 8usize];
    ["Offset of field: NamedGPIOList::num_in"]
        [::std::mem::offset_of!(NamedGPIOList, num_in) - 16usize];
    ["Offset of field: NamedGPIOList::num_out"]
        [::std::mem::offset_of!(NamedGPIOList, num_out) - 20usize];
    ["Offset of field: NamedGPIOList::node"][::std::mem::offset_of!(NamedGPIOList, node) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedClockList {
    pub name: *mut ::std::os::raw::c_char,
    pub clock: *mut Clock,
    pub output: bool,
    pub alias: bool,
    pub node: NamedClockList__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedClockList__bindgen_ty_1 {
    pub le_next: *mut NamedClockList,
    pub le_prev: *mut *mut NamedClockList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NamedClockList__bindgen_ty_1"]
        [::std::mem::size_of::<NamedClockList__bindgen_ty_1>() - 16usize];
    ["Alignment of NamedClockList__bindgen_ty_1"]
        [::std::mem::align_of::<NamedClockList__bindgen_ty_1>() - 8usize];
    ["Offset of field: NamedClockList__bindgen_ty_1::le_next"]
        [::std::mem::offset_of!(NamedClockList__bindgen_ty_1, le_next) - 0usize];
    ["Offset of field: NamedClockList__bindgen_ty_1::le_prev"]
        [::std::mem::offset_of!(NamedClockList__bindgen_ty_1, le_prev) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NamedClockList"][::std::mem::size_of::<NamedClockList>() - 40usize];
    ["Alignment of NamedClockList"][::std::mem::align_of::<NamedClockList>() - 8usize];
    ["Offset of field: NamedClockList::name"]
        [::std::mem::offset_of!(NamedClockList, name) - 0usize];
    ["Offset of field: NamedClockList::clock"]
        [::std::mem::offset_of!(NamedClockList, clock) - 8usize];
    ["Offset of field: NamedClockList::output"]
        [::std::mem::offset_of!(NamedClockList, output) - 16usize];
    ["Offset of field: NamedClockList::alias"]
        [::std::mem::offset_of!(NamedClockList, alias) - 17usize];
    ["Offset of field: NamedClockList::node"]
        [::std::mem::offset_of!(NamedClockList, node) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemReentrancyGuard {
    pub engaged_in_io: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemReentrancyGuard"][::std::mem::size_of::<MemReentrancyGuard>() - 1usize];
    ["Alignment of MemReentrancyGuard"][::std::mem::align_of::<MemReentrancyGuard>() - 1usize];
    ["Offset of field: MemReentrancyGuard::engaged_in_io"]
        [::std::mem::offset_of!(MemReentrancyGuard, engaged_in_io) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedGPIOListHead {
    pub lh_first: *mut NamedGPIOList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NamedGPIOListHead"][::std::mem::size_of::<NamedGPIOListHead>() - 8usize];
    ["Alignment of NamedGPIOListHead"][::std::mem::align_of::<NamedGPIOListHead>() - 8usize];
    ["Offset of field: NamedGPIOListHead::lh_first"]
        [::std::mem::offset_of!(NamedGPIOListHead, lh_first) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedClockListHead {
    pub lh_first: *mut NamedClockList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NamedClockListHead"][::std::mem::size_of::<NamedClockListHead>() - 8usize];
    ["Alignment of NamedClockListHead"][::std::mem::align_of::<NamedClockListHead>() - 8usize];
    ["Offset of field: NamedClockListHead::lh_first"]
        [::std::mem::offset_of!(NamedClockListHead, lh_first) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BusStateHead {
    pub lh_first: *mut BusState,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BusStateHead"][::std::mem::size_of::<BusStateHead>() - 8usize];
    ["Alignment of BusStateHead"][::std::mem::align_of::<BusStateHead>() - 8usize];
    ["Offset of field: BusStateHead::lh_first"]
        [::std::mem::offset_of!(BusStateHead, lh_first) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceState {
    pub parent_obj: Object,
    pub id: *mut ::std::os::raw::c_char,
    pub canonical_path: *mut ::std::os::raw::c_char,
    pub realized: bool,
    pub pending_deleted_event: bool,
    pub pending_deleted_expires_ms: i64,
    pub hotplugged: ::std::os::raw::c_int,
    pub allow_unplug_during_migration: bool,
    pub parent_bus: *mut BusState,
    pub gpios: NamedGPIOListHead,
    pub clocks: NamedClockListHead,
    pub child_bus: BusStateHead,
    pub num_child_bus: ::std::os::raw::c_int,
    pub instance_id_alias: ::std::os::raw::c_int,
    pub alias_required_for_version: ::std::os::raw::c_int,
    pub reset: ResettableState,
    pub unplug_blockers: *mut GSList,
    pub mem_reentrancy_guard: MemReentrancyGuard,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DeviceState"][::std::mem::size_of::<DeviceState>() - 152usize];
    ["Alignment of DeviceState"][::std::mem::align_of::<DeviceState>() - 8usize];
    ["Offset of field: DeviceState::parent_obj"]
        [::std::mem::offset_of!(DeviceState, parent_obj) - 0usize];
    ["Offset of field: DeviceState::id"][::std::mem::offset_of!(DeviceState, id) - 40usize];
    ["Offset of field: DeviceState::canonical_path"]
        [::std::mem::offset_of!(DeviceState, canonical_path) - 48usize];
    ["Offset of field: DeviceState::realized"]
        [::std::mem::offset_of!(DeviceState, realized) - 56usize];
    ["Offset of field: DeviceState::pending_deleted_event"]
        [::std::mem::offset_of!(DeviceState, pending_deleted_event) - 57usize];
    ["Offset of field: DeviceState::pending_deleted_expires_ms"]
        [::std::mem::offset_of!(DeviceState, pending_deleted_expires_ms) - 64usize];
    ["Offset of field: DeviceState::hotplugged"]
        [::std::mem::offset_of!(DeviceState, hotplugged) - 72usize];
    ["Offset of field: DeviceState::allow_unplug_during_migration"]
        [::std::mem::offset_of!(DeviceState, allow_unplug_during_migration) - 76usize];
    ["Offset of field: DeviceState::parent_bus"]
        [::std::mem::offset_of!(DeviceState, parent_bus) - 80usize];
    ["Offset of field: DeviceState::gpios"][::std::mem::offset_of!(DeviceState, gpios) - 88usize];
    ["Offset of field: DeviceState::clocks"][::std::mem::offset_of!(DeviceState, clocks) - 96usize];
    ["Offset of field: DeviceState::child_bus"]
        [::std::mem::offset_of!(DeviceState, child_bus) - 104usize];
    ["Offset of field: DeviceState::num_child_bus"]
        [::std::mem::offset_of!(DeviceState, num_child_bus) - 112usize];
    ["Offset of field: DeviceState::instance_id_alias"]
        [::std::mem::offset_of!(DeviceState, instance_id_alias) - 116usize];
    ["Offset of field: DeviceState::alias_required_for_version"]
        [::std::mem::offset_of!(DeviceState, alias_required_for_version) - 120usize];
    ["Offset of field: DeviceState::reset"][::std::mem::offset_of!(DeviceState, reset) - 124usize];
    ["Offset of field: DeviceState::unplug_blockers"]
        [::std::mem::offset_of!(DeviceState, unplug_blockers) - 136usize];
    ["Offset of field: DeviceState::mem_reentrancy_guard"]
        [::std::mem::offset_of!(DeviceState, mem_reentrancy_guard) - 144usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceListener {
    pub realize: ::std::option::Option<
        unsafe extern "C" fn(listener: *mut DeviceListener, dev: *mut DeviceState),
    >,
    pub unrealize: ::std::option::Option<
        unsafe extern "C" fn(listener: *mut DeviceListener, dev: *mut DeviceState),
    >,
    pub hide_device: ::std::option::Option<
        unsafe extern "C" fn(
            listener: *mut DeviceListener,
            device_opts: *const QDict,
            from_json: bool,
            errp: *mut *mut Error,
        ) -> bool,
    >,
    pub link: DeviceListener__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DeviceListener__bindgen_ty_1 {
    pub tqe_next: *mut DeviceListener,
    pub tqe_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DeviceListener__bindgen_ty_1"]
        [::std::mem::size_of::<DeviceListener__bindgen_ty_1>() - 16usize];
    ["Alignment of DeviceListener__bindgen_ty_1"]
        [::std::mem::align_of::<DeviceListener__bindgen_ty_1>() - 8usize];
    ["Offset of field: DeviceListener__bindgen_ty_1::tqe_next"]
        [::std::mem::offset_of!(DeviceListener__bindgen_ty_1, tqe_next) - 0usize];
    ["Offset of field: DeviceListener__bindgen_ty_1::tqe_circ"]
        [::std::mem::offset_of!(DeviceListener__bindgen_ty_1, tqe_circ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DeviceListener"][::std::mem::size_of::<DeviceListener>() - 40usize];
    ["Alignment of DeviceListener"][::std::mem::align_of::<DeviceListener>() - 8usize];
    ["Offset of field: DeviceListener::realize"]
        [::std::mem::offset_of!(DeviceListener, realize) - 0usize];
    ["Offset of field: DeviceListener::unrealize"]
        [::std::mem::offset_of!(DeviceListener, unrealize) - 8usize];
    ["Offset of field: DeviceListener::hide_device"]
        [::std::mem::offset_of!(DeviceListener, hide_device) - 16usize];
    ["Offset of field: DeviceListener::link"]
        [::std::mem::offset_of!(DeviceListener, link) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BusClass {
    pub parent_class: ObjectClass,
    pub print_dev: ::std::option::Option<
        unsafe extern "C" fn(
            mon: *mut Monitor,
            dev: *mut DeviceState,
            indent: ::std::os::raw::c_int,
        ),
    >,
    pub get_dev_path: ::std::option::Option<
        unsafe extern "C" fn(dev: *mut DeviceState) -> *mut ::std::os::raw::c_char,
    >,
    pub get_fw_dev_path: ::std::option::Option<
        unsafe extern "C" fn(dev: *mut DeviceState) -> *mut ::std::os::raw::c_char,
    >,
    pub check_address: ::std::option::Option<
        unsafe extern "C" fn(
            bus: *mut BusState,
            dev: *mut DeviceState,
            errp: *mut *mut Error,
        ) -> bool,
    >,
    pub realize: BusRealize,
    pub unrealize: BusUnrealize,
    pub max_dev: ::std::os::raw::c_int,
    pub automatic_ids: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BusClass"][::std::mem::size_of::<BusClass>() - 152usize];
    ["Alignment of BusClass"][::std::mem::align_of::<BusClass>() - 8usize];
    ["Offset of field: BusClass::parent_class"]
        [::std::mem::offset_of!(BusClass, parent_class) - 0usize];
    ["Offset of field: BusClass::print_dev"][::std::mem::offset_of!(BusClass, print_dev) - 96usize];
    ["Offset of field: BusClass::get_dev_path"]
        [::std::mem::offset_of!(BusClass, get_dev_path) - 104usize];
    ["Offset of field: BusClass::get_fw_dev_path"]
        [::std::mem::offset_of!(BusClass, get_fw_dev_path) - 112usize];
    ["Offset of field: BusClass::check_address"]
        [::std::mem::offset_of!(BusClass, check_address) - 120usize];
    ["Offset of field: BusClass::realize"][::std::mem::offset_of!(BusClass, realize) - 128usize];
    ["Offset of field: BusClass::unrealize"]
        [::std::mem::offset_of!(BusClass, unrealize) - 136usize];
    ["Offset of field: BusClass::max_dev"][::std::mem::offset_of!(BusClass, max_dev) - 144usize];
    ["Offset of field: BusClass::automatic_ids"]
        [::std::mem::offset_of!(BusClass, automatic_ids) - 148usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BusChild {
    pub rcu: rcu_head,
    pub child: *mut DeviceState,
    pub index: ::std::os::raw::c_int,
    pub sibling: BusChild__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BusChild__bindgen_ty_1 {
    pub tqe_next: *mut BusChild,
    pub tqe_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BusChild__bindgen_ty_1"][::std::mem::size_of::<BusChild__bindgen_ty_1>() - 16usize];
    ["Alignment of BusChild__bindgen_ty_1"]
        [::std::mem::align_of::<BusChild__bindgen_ty_1>() - 8usize];
    ["Offset of field: BusChild__bindgen_ty_1::tqe_next"]
        [::std::mem::offset_of!(BusChild__bindgen_ty_1, tqe_next) - 0usize];
    ["Offset of field: BusChild__bindgen_ty_1::tqe_circ"]
        [::std::mem::offset_of!(BusChild__bindgen_ty_1, tqe_circ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BusChild"][::std::mem::size_of::<BusChild>() - 48usize];
    ["Alignment of BusChild"][::std::mem::align_of::<BusChild>() - 8usize];
    ["Offset of field: BusChild::rcu"][::std::mem::offset_of!(BusChild, rcu) - 0usize];
    ["Offset of field: BusChild::child"][::std::mem::offset_of!(BusChild, child) - 16usize];
    ["Offset of field: BusChild::index"][::std::mem::offset_of!(BusChild, index) - 24usize];
    ["Offset of field: BusChild::sibling"][::std::mem::offset_of!(BusChild, sibling) - 32usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union BusChildHead {
    pub tqh_first: *mut BusChild,
    pub tqh_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BusChildHead"][::std::mem::size_of::<BusChildHead>() - 16usize];
    ["Alignment of BusChildHead"][::std::mem::align_of::<BusChildHead>() - 8usize];
    ["Offset of field: BusChildHead::tqh_first"]
        [::std::mem::offset_of!(BusChildHead, tqh_first) - 0usize];
    ["Offset of field: BusChildHead::tqh_circ"]
        [::std::mem::offset_of!(BusChildHead, tqh_circ) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BusStateEntry {
    pub le_next: *mut BusState,
    pub le_prev: *mut *mut BusState,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BusStateEntry"][::std::mem::size_of::<BusStateEntry>() - 16usize];
    ["Alignment of BusStateEntry"][::std::mem::align_of::<BusStateEntry>() - 8usize];
    ["Offset of field: BusStateEntry::le_next"]
        [::std::mem::offset_of!(BusStateEntry, le_next) - 0usize];
    ["Offset of field: BusStateEntry::le_prev"]
        [::std::mem::offset_of!(BusStateEntry, le_prev) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BusState {
    pub obj: Object,
    pub parent: *mut DeviceState,
    pub name: *mut ::std::os::raw::c_char,
    pub hotplug_handler: *mut HotplugHandler,
    pub max_index: ::std::os::raw::c_int,
    pub realized: bool,
    pub full: bool,
    pub num_children: ::std::os::raw::c_int,
    pub children: BusChildHead,
    pub sibling: BusStateEntry,
    pub reset: ResettableState,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BusState"][::std::mem::size_of::<BusState>() - 120usize];
    ["Alignment of BusState"][::std::mem::align_of::<BusState>() - 8usize];
    ["Offset of field: BusState::obj"][::std::mem::offset_of!(BusState, obj) - 0usize];
    ["Offset of field: BusState::parent"][::std::mem::offset_of!(BusState, parent) - 40usize];
    ["Offset of field: BusState::name"][::std::mem::offset_of!(BusState, name) - 48usize];
    ["Offset of field: BusState::hotplug_handler"]
        [::std::mem::offset_of!(BusState, hotplug_handler) - 56usize];
    ["Offset of field: BusState::max_index"][::std::mem::offset_of!(BusState, max_index) - 64usize];
    ["Offset of field: BusState::realized"][::std::mem::offset_of!(BusState, realized) - 68usize];
    ["Offset of field: BusState::full"][::std::mem::offset_of!(BusState, full) - 69usize];
    ["Offset of field: BusState::num_children"]
        [::std::mem::offset_of!(BusState, num_children) - 72usize];
    ["Offset of field: BusState::children"][::std::mem::offset_of!(BusState, children) - 80usize];
    ["Offset of field: BusState::sibling"][::std::mem::offset_of!(BusState, sibling) - 96usize];
    ["Offset of field: BusState::reset"][::std::mem::offset_of!(BusState, reset) - 112usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GlobalProperty {
    pub driver: *const ::std::os::raw::c_char,
    pub property: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
    pub used: bool,
    pub optional: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GlobalProperty"][::std::mem::size_of::<GlobalProperty>() - 32usize];
    ["Alignment of GlobalProperty"][::std::mem::align_of::<GlobalProperty>() - 8usize];
    ["Offset of field: GlobalProperty::driver"]
        [::std::mem::offset_of!(GlobalProperty, driver) - 0usize];
    ["Offset of field: GlobalProperty::property"]
        [::std::mem::offset_of!(GlobalProperty, property) - 8usize];
    ["Offset of field: GlobalProperty::value"]
        [::std::mem::offset_of!(GlobalProperty, value) - 16usize];
    ["Offset of field: GlobalProperty::used"]
        [::std::mem::offset_of!(GlobalProperty, used) - 24usize];
    ["Offset of field: GlobalProperty::optional"]
        [::std::mem::offset_of!(GlobalProperty, optional) - 25usize];
};
unsafe extern "C" {
    pub fn qdev_new(name: *const ::std::os::raw::c_char) -> *mut DeviceState;
}
unsafe extern "C" {
    pub fn qdev_try_new(name: *const ::std::os::raw::c_char) -> *mut DeviceState;
}
unsafe extern "C" {
    pub fn qdev_realize(dev: *mut DeviceState, bus: *mut BusState, errp: *mut *mut Error) -> bool;
}
unsafe extern "C" {
    pub fn qdev_realize_and_unref(
        dev: *mut DeviceState,
        bus: *mut BusState,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn qdev_unrealize(dev: *mut DeviceState);
}
unsafe extern "C" {
    pub fn qdev_set_legacy_instance_id(
        dev: *mut DeviceState,
        alias_id: ::std::os::raw::c_int,
        required_for_version: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn qdev_get_bus_hotplug_handler(dev: *mut DeviceState) -> *mut HotplugHandler;
}
unsafe extern "C" {
    pub fn qdev_get_machine_hotplug_handler(dev: *mut DeviceState) -> *mut HotplugHandler;
}
unsafe extern "C" {
    pub fn qdev_hotplug_allowed(
        dev: *mut DeviceState,
        bus: *mut BusState,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn qdev_hotunplug_allowed(dev: *mut DeviceState, errp: *mut *mut Error) -> bool;
}
unsafe extern "C" {
    pub fn qdev_get_hotplug_handler(dev: *mut DeviceState) -> *mut HotplugHandler;
}
unsafe extern "C" {
    pub fn qdev_unplug(dev: *mut DeviceState, errp: *mut *mut Error);
}
unsafe extern "C" {
    pub fn qdev_sync_config(dev: *mut DeviceState, errp: *mut *mut Error) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qdev_simple_device_unplug_cb(
        hotplug_dev: *mut HotplugHandler,
        dev: *mut DeviceState,
        errp: *mut *mut Error,
    );
}
unsafe extern "C" {
    pub fn qdev_machine_creation_done();
}
unsafe extern "C" {
    pub fn qdev_machine_modified() -> bool;
}
unsafe extern "C" {
    pub fn qdev_add_unplug_blocker(dev: *mut DeviceState, reason: *mut Error);
}
unsafe extern "C" {
    pub fn qdev_del_unplug_blocker(dev: *mut DeviceState, reason: *mut Error);
}
unsafe extern "C" {
    pub fn qdev_unplug_blocked(dev: *mut DeviceState, errp: *mut *mut Error) -> bool;
}
pub const GPIO_POLARITY_ACTIVE_LOW: GpioPolarity = 0;
pub const GPIO_POLARITY_ACTIVE_HIGH: GpioPolarity = 1;
pub type GpioPolarity = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn qdev_get_gpio_in(dev: *mut DeviceState, n: ::std::os::raw::c_int) -> qemu_irq;
}
unsafe extern "C" {
    pub fn qdev_get_gpio_in_named(
        dev: *mut DeviceState,
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    ) -> qemu_irq;
}
unsafe extern "C" {
    pub fn qdev_connect_gpio_out(dev: *mut DeviceState, n: ::std::os::raw::c_int, pin: qemu_irq);
}
unsafe extern "C" {
    pub fn qdev_connect_gpio_out_named(
        dev: *mut DeviceState,
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        input_pin: qemu_irq,
    );
}
unsafe extern "C" {
    pub fn qdev_get_gpio_out_connector(
        dev: *mut DeviceState,
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    ) -> qemu_irq;
}
unsafe extern "C" {
    pub fn qdev_intercept_gpio_out(
        dev: *mut DeviceState,
        icpt: qemu_irq,
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    ) -> qemu_irq;
}
unsafe extern "C" {
    pub fn qdev_get_child_bus(
        dev: *mut DeviceState,
        name: *const ::std::os::raw::c_char,
    ) -> *mut BusState;
}
unsafe extern "C" {
    pub fn qdev_init_gpio_in(
        dev: *mut DeviceState,
        handler: qemu_irq_handler,
        n: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn qdev_init_gpio_out(dev: *mut DeviceState, pins: *mut qemu_irq, n: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn qdev_init_gpio_out_named(
        dev: *mut DeviceState,
        pins: *mut qemu_irq,
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn qdev_init_gpio_in_named_with_opaque(
        dev: *mut DeviceState,
        handler: qemu_irq_handler,
        opaque: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn qdev_pass_gpios(
        dev: *mut DeviceState,
        container: *mut DeviceState,
        name: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn qdev_get_parent_bus(dev: *const DeviceState) -> *mut BusState;
}
unsafe extern "C" {
    pub fn qdev_find_recursive(
        bus: *mut BusState,
        id: *const ::std::os::raw::c_char,
    ) -> *mut DeviceState;
}
pub type qbus_walkerfn = ::std::option::Option<
    unsafe extern "C" fn(
        bus: *mut BusState,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type qdev_walkerfn = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut DeviceState,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn qbus_init(
        bus: *mut ::std::os::raw::c_void,
        size: usize,
        typename: *const ::std::os::raw::c_char,
        parent: *mut DeviceState,
        name: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn qbus_new(
        typename: *const ::std::os::raw::c_char,
        parent: *mut DeviceState,
        name: *const ::std::os::raw::c_char,
    ) -> *mut BusState;
}
unsafe extern "C" {
    pub fn qbus_realize(bus: *mut BusState, errp: *mut *mut Error) -> bool;
}
unsafe extern "C" {
    pub fn qbus_unrealize(bus: *mut BusState);
}
unsafe extern "C" {
    pub fn qbus_walk_children(
        bus: *mut BusState,
        pre_devfn: qdev_walkerfn,
        pre_busfn: qbus_walkerfn,
        post_devfn: qdev_walkerfn,
        post_busfn: qbus_walkerfn,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qdev_walk_children(
        dev: *mut DeviceState,
        pre_devfn: qdev_walkerfn,
        pre_busfn: qbus_walkerfn,
        post_devfn: qdev_walkerfn,
        post_busfn: qbus_walkerfn,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn device_cold_reset(dev: *mut DeviceState);
}
unsafe extern "C" {
    pub fn bus_cold_reset(bus: *mut BusState);
}
unsafe extern "C" {
    pub fn device_is_in_reset(dev: *mut DeviceState) -> bool;
}
unsafe extern "C" {
    pub fn bus_is_in_reset(bus: *mut BusState) -> bool;
}
unsafe extern "C" {
    pub fn sysbus_get_default() -> *mut BusState;
}
unsafe extern "C" {
    pub fn qdev_get_fw_dev_path(dev: *mut DeviceState) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qdev_get_own_fw_dev_path_from_handler(
        bus: *mut BusState,
        dev: *mut DeviceState,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn device_class_set_props_n(dc: *mut DeviceClass, props: *const Property, n: usize);
}
unsafe extern "C" {
    pub fn device_class_set_parent_realize(
        dc: *mut DeviceClass,
        dev_realize: DeviceRealize,
        parent_realize: *mut DeviceRealize,
    );
}
unsafe extern "C" {
    pub fn device_class_set_legacy_reset(dc: *mut DeviceClass, dev_reset: DeviceReset);
}
unsafe extern "C" {
    pub fn device_class_set_parent_unrealize(
        dc: *mut DeviceClass,
        dev_unrealize: DeviceUnrealize,
        parent_unrealize: *mut DeviceUnrealize,
    );
}
unsafe extern "C" {
    pub fn qdev_get_vmsd(dev: *mut DeviceState) -> *const VMStateDescription;
}
unsafe extern "C" {
    pub fn qdev_fw_name(dev: *mut DeviceState) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qdev_assert_realized_properly();
}
unsafe extern "C" {
    pub fn qdev_get_machine() -> *mut Object;
}
unsafe extern "C" {
    pub fn qdev_create_fake_machine();
}
unsafe extern "C" {
    pub fn machine_get_container(name: *const ::std::os::raw::c_char) -> *mut Object;
}
unsafe extern "C" {
    pub fn qdev_get_human_name(dev: *mut DeviceState) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qdev_set_parent_bus(
        dev: *mut DeviceState,
        bus: *mut BusState,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub static mut qdev_hot_removed: bool;
}
unsafe extern "C" {
    pub fn qdev_get_dev_path(dev: *mut DeviceState) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qbus_set_hotplug_handler(bus: *mut BusState, handler: *mut Object);
}
unsafe extern "C" {
    pub fn qbus_set_bus_hotplug_handler(bus: *mut BusState);
}
unsafe extern "C" {
    pub fn device_listener_register(listener: *mut DeviceListener);
}
unsafe extern "C" {
    pub fn device_listener_unregister(listener: *mut DeviceListener);
}
unsafe extern "C" {
    pub fn qdev_should_hide_device(
        opts: *const QDict,
        from_json: bool,
        errp: *mut *mut Error,
    ) -> bool;
}
pub const PHASE_NO_MACHINE: MachineInitPhase = 0;
pub const PHASE_MACHINE_CREATED: MachineInitPhase = 1;
pub const PHASE_ACCEL_CREATED: MachineInitPhase = 2;
pub const PHASE_LATE_BACKENDS_CREATED: MachineInitPhase = 3;
pub const PHASE_MACHINE_INITIALIZED: MachineInitPhase = 4;
pub const PHASE_MACHINE_READY: MachineInitPhase = 5;
pub type MachineInitPhase = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn phase_check(phase: MachineInitPhase) -> bool;
}
unsafe extern "C" {
    pub fn phase_advance(phase: MachineInitPhase);
}
pub type PTR = *mut ::std::os::raw::c_void;
pub type bfd_vma = u64;
pub type bfd_signed_vma = i64;
pub type bfd_byte = u8;
pub const bfd_target_unknown_flavour: bfd_flavour = 0;
pub const bfd_target_aout_flavour: bfd_flavour = 1;
pub const bfd_target_coff_flavour: bfd_flavour = 2;
pub const bfd_target_ecoff_flavour: bfd_flavour = 3;
pub const bfd_target_elf_flavour: bfd_flavour = 4;
pub const bfd_target_ieee_flavour: bfd_flavour = 5;
pub const bfd_target_nlm_flavour: bfd_flavour = 6;
pub const bfd_target_oasys_flavour: bfd_flavour = 7;
pub const bfd_target_tekhex_flavour: bfd_flavour = 8;
pub const bfd_target_srec_flavour: bfd_flavour = 9;
pub const bfd_target_ihex_flavour: bfd_flavour = 10;
pub const bfd_target_som_flavour: bfd_flavour = 11;
pub const bfd_target_os9k_flavour: bfd_flavour = 12;
pub const bfd_target_versados_flavour: bfd_flavour = 13;
pub const bfd_target_msdos_flavour: bfd_flavour = 14;
pub const bfd_target_evax_flavour: bfd_flavour = 15;
pub type bfd_flavour = ::std::os::raw::c_uint;
pub const BFD_ENDIAN_BIG: bfd_endian = 0;
pub const BFD_ENDIAN_LITTLE: bfd_endian = 1;
pub const BFD_ENDIAN_UNKNOWN: bfd_endian = 2;
pub type bfd_endian = ::std::os::raw::c_uint;
pub const bfd_arch_unknown: bfd_architecture = 0;
pub const bfd_arch_obscure: bfd_architecture = 1;
pub const bfd_arch_m68k: bfd_architecture = 2;
pub const bfd_arch_vax: bfd_architecture = 3;
pub const bfd_arch_i960: bfd_architecture = 4;
pub const bfd_arch_a29k: bfd_architecture = 5;
pub const bfd_arch_sparc: bfd_architecture = 6;
pub const bfd_arch_mips: bfd_architecture = 7;
pub const bfd_arch_i386: bfd_architecture = 8;
pub const bfd_arch_we32k: bfd_architecture = 9;
pub const bfd_arch_tahoe: bfd_architecture = 10;
pub const bfd_arch_i860: bfd_architecture = 11;
pub const bfd_arch_romp: bfd_architecture = 12;
pub const bfd_arch_alliant: bfd_architecture = 13;
pub const bfd_arch_convex: bfd_architecture = 14;
pub const bfd_arch_m88k: bfd_architecture = 15;
pub const bfd_arch_pyramid: bfd_architecture = 16;
pub const bfd_arch_h8300: bfd_architecture = 17;
pub const bfd_arch_powerpc: bfd_architecture = 18;
pub const bfd_arch_rs6000: bfd_architecture = 19;
pub const bfd_arch_hppa: bfd_architecture = 20;
pub const bfd_arch_d10v: bfd_architecture = 21;
pub const bfd_arch_z8k: bfd_architecture = 22;
pub const bfd_arch_h8500: bfd_architecture = 23;
pub const bfd_arch_sh: bfd_architecture = 24;
pub const bfd_arch_alpha: bfd_architecture = 25;
pub const bfd_arch_arm: bfd_architecture = 26;
pub const bfd_arch_ns32k: bfd_architecture = 27;
pub const bfd_arch_w65: bfd_architecture = 28;
pub const bfd_arch_tic30: bfd_architecture = 29;
pub const bfd_arch_v850: bfd_architecture = 30;
pub const bfd_arch_arc: bfd_architecture = 31;
pub const bfd_arch_m32r: bfd_architecture = 32;
pub const bfd_arch_mn10200: bfd_architecture = 33;
pub const bfd_arch_mn10300: bfd_architecture = 34;
pub const bfd_arch_avr: bfd_architecture = 35;
pub const bfd_arch_microblaze: bfd_architecture = 36;
pub const bfd_arch_moxie: bfd_architecture = 37;
pub const bfd_arch_ia64: bfd_architecture = 38;
pub const bfd_arch_rx: bfd_architecture = 39;
pub const bfd_arch_loongarch: bfd_architecture = 40;
pub const bfd_arch_last: bfd_architecture = 41;
pub type bfd_architecture = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct symbol_cache_entry {
    pub name: *const ::std::os::raw::c_char,
    pub udata: symbol_cache_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union symbol_cache_entry__bindgen_ty_1 {
    pub p: PTR,
    pub i: bfd_vma,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of symbol_cache_entry__bindgen_ty_1"]
        [::std::mem::size_of::<symbol_cache_entry__bindgen_ty_1>() - 8usize];
    ["Alignment of symbol_cache_entry__bindgen_ty_1"]
        [::std::mem::align_of::<symbol_cache_entry__bindgen_ty_1>() - 8usize];
    ["Offset of field: symbol_cache_entry__bindgen_ty_1::p"]
        [::std::mem::offset_of!(symbol_cache_entry__bindgen_ty_1, p) - 0usize];
    ["Offset of field: symbol_cache_entry__bindgen_ty_1::i"]
        [::std::mem::offset_of!(symbol_cache_entry__bindgen_ty_1, i) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of symbol_cache_entry"][::std::mem::size_of::<symbol_cache_entry>() - 16usize];
    ["Alignment of symbol_cache_entry"][::std::mem::align_of::<symbol_cache_entry>() - 8usize];
    ["Offset of field: symbol_cache_entry::name"]
        [::std::mem::offset_of!(symbol_cache_entry, name) - 0usize];
    ["Offset of field: symbol_cache_entry::udata"]
        [::std::mem::offset_of!(symbol_cache_entry, udata) - 8usize];
};
pub type asymbol = symbol_cache_entry;
pub type fprintf_function = ::std::option::Option<
    unsafe extern "C" fn(
        f: *mut FILE,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int,
>;
pub const dis_noninsn: dis_insn_type = 0;
pub const dis_nonbranch: dis_insn_type = 1;
pub const dis_branch: dis_insn_type = 2;
pub const dis_condbranch: dis_insn_type = 3;
pub const dis_jsr: dis_insn_type = 4;
pub const dis_condjsr: dis_insn_type = 5;
pub const dis_dref: dis_insn_type = 6;
pub const dis_dref2: dis_insn_type = 7;
pub type dis_insn_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct disassemble_info {
    pub fprintf_func: fprintf_function,
    pub stream: *mut FILE,
    pub application_data: PTR,
    pub flavour: bfd_flavour,
    pub arch: bfd_architecture,
    pub mach: ::std::os::raw::c_ulong,
    pub endian: bfd_endian,
    pub symbols: *mut *mut asymbol,
    pub num_symbols: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_ulong,
    pub private_data: PTR,
    pub read_memory_func: ::std::option::Option<
        unsafe extern "C" fn(
            memaddr: bfd_vma,
            myaddr: *mut bfd_byte,
            length: ::std::os::raw::c_int,
            info: *mut disassemble_info,
        ) -> ::std::os::raw::c_int,
    >,
    pub memory_error_func: ::std::option::Option<
        unsafe extern "C" fn(
            status: ::std::os::raw::c_int,
            memaddr: bfd_vma,
            info: *mut disassemble_info,
        ),
    >,
    pub print_address_func:
        ::std::option::Option<unsafe extern "C" fn(addr: bfd_vma, info: *mut disassemble_info)>,
    pub print_insn: ::std::option::Option<
        unsafe extern "C" fn(addr: bfd_vma, info: *mut disassemble_info) -> ::std::os::raw::c_int,
    >,
    pub symbol_at_address_func: ::std::option::Option<
        unsafe extern "C" fn(addr: bfd_vma, info: *mut disassemble_info) -> ::std::os::raw::c_int,
    >,
    pub buffer: *const bfd_byte,
    pub buffer_vma: bfd_vma,
    pub buffer_length: ::std::os::raw::c_int,
    pub bytes_per_line: ::std::os::raw::c_int,
    pub bytes_per_chunk: ::std::os::raw::c_int,
    pub display_endian: bfd_endian,
    pub insn_info_valid: ::std::os::raw::c_char,
    pub branch_delay_insns: ::std::os::raw::c_char,
    pub data_size: ::std::os::raw::c_char,
    pub insn_type: dis_insn_type,
    pub target: bfd_vma,
    pub target2: bfd_vma,
    pub disassembler_options: *mut ::std::os::raw::c_char,
    pub show_opcodes: bool,
    pub target_info: *mut ::std::os::raw::c_void,
    pub cap_arch: ::std::os::raw::c_int,
    pub cap_mode: ::std::os::raw::c_int,
    pub cap_insn_unit: ::std::os::raw::c_int,
    pub cap_insn_split: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of disassemble_info"][::std::mem::size_of::<disassemble_info>() - 216usize];
    ["Alignment of disassemble_info"][::std::mem::align_of::<disassemble_info>() - 8usize];
    ["Offset of field: disassemble_info::fprintf_func"]
        [::std::mem::offset_of!(disassemble_info, fprintf_func) - 0usize];
    ["Offset of field: disassemble_info::stream"]
        [::std::mem::offset_of!(disassemble_info, stream) - 8usize];
    ["Offset of field: disassemble_info::application_data"]
        [::std::mem::offset_of!(disassemble_info, application_data) - 16usize];
    ["Offset of field: disassemble_info::flavour"]
        [::std::mem::offset_of!(disassemble_info, flavour) - 24usize];
    ["Offset of field: disassemble_info::arch"]
        [::std::mem::offset_of!(disassemble_info, arch) - 28usize];
    ["Offset of field: disassemble_info::mach"]
        [::std::mem::offset_of!(disassemble_info, mach) - 32usize];
    ["Offset of field: disassemble_info::endian"]
        [::std::mem::offset_of!(disassemble_info, endian) - 40usize];
    ["Offset of field: disassemble_info::symbols"]
        [::std::mem::offset_of!(disassemble_info, symbols) - 48usize];
    ["Offset of field: disassemble_info::num_symbols"]
        [::std::mem::offset_of!(disassemble_info, num_symbols) - 56usize];
    ["Offset of field: disassemble_info::flags"]
        [::std::mem::offset_of!(disassemble_info, flags) - 64usize];
    ["Offset of field: disassemble_info::private_data"]
        [::std::mem::offset_of!(disassemble_info, private_data) - 72usize];
    ["Offset of field: disassemble_info::read_memory_func"]
        [::std::mem::offset_of!(disassemble_info, read_memory_func) - 80usize];
    ["Offset of field: disassemble_info::memory_error_func"]
        [::std::mem::offset_of!(disassemble_info, memory_error_func) - 88usize];
    ["Offset of field: disassemble_info::print_address_func"]
        [::std::mem::offset_of!(disassemble_info, print_address_func) - 96usize];
    ["Offset of field: disassemble_info::print_insn"]
        [::std::mem::offset_of!(disassemble_info, print_insn) - 104usize];
    ["Offset of field: disassemble_info::symbol_at_address_func"]
        [::std::mem::offset_of!(disassemble_info, symbol_at_address_func) - 112usize];
    ["Offset of field: disassemble_info::buffer"]
        [::std::mem::offset_of!(disassemble_info, buffer) - 120usize];
    ["Offset of field: disassemble_info::buffer_vma"]
        [::std::mem::offset_of!(disassemble_info, buffer_vma) - 128usize];
    ["Offset of field: disassemble_info::buffer_length"]
        [::std::mem::offset_of!(disassemble_info, buffer_length) - 136usize];
    ["Offset of field: disassemble_info::bytes_per_line"]
        [::std::mem::offset_of!(disassemble_info, bytes_per_line) - 140usize];
    ["Offset of field: disassemble_info::bytes_per_chunk"]
        [::std::mem::offset_of!(disassemble_info, bytes_per_chunk) - 144usize];
    ["Offset of field: disassemble_info::display_endian"]
        [::std::mem::offset_of!(disassemble_info, display_endian) - 148usize];
    ["Offset of field: disassemble_info::insn_info_valid"]
        [::std::mem::offset_of!(disassemble_info, insn_info_valid) - 152usize];
    ["Offset of field: disassemble_info::branch_delay_insns"]
        [::std::mem::offset_of!(disassemble_info, branch_delay_insns) - 153usize];
    ["Offset of field: disassemble_info::data_size"]
        [::std::mem::offset_of!(disassemble_info, data_size) - 154usize];
    ["Offset of field: disassemble_info::insn_type"]
        [::std::mem::offset_of!(disassemble_info, insn_type) - 156usize];
    ["Offset of field: disassemble_info::target"]
        [::std::mem::offset_of!(disassemble_info, target) - 160usize];
    ["Offset of field: disassemble_info::target2"]
        [::std::mem::offset_of!(disassemble_info, target2) - 168usize];
    ["Offset of field: disassemble_info::disassembler_options"]
        [::std::mem::offset_of!(disassemble_info, disassembler_options) - 176usize];
    ["Offset of field: disassemble_info::show_opcodes"]
        [::std::mem::offset_of!(disassemble_info, show_opcodes) - 184usize];
    ["Offset of field: disassemble_info::target_info"]
        [::std::mem::offset_of!(disassemble_info, target_info) - 192usize];
    ["Offset of field: disassemble_info::cap_arch"]
        [::std::mem::offset_of!(disassemble_info, cap_arch) - 200usize];
    ["Offset of field: disassemble_info::cap_mode"]
        [::std::mem::offset_of!(disassemble_info, cap_mode) - 204usize];
    ["Offset of field: disassemble_info::cap_insn_unit"]
        [::std::mem::offset_of!(disassemble_info, cap_insn_unit) - 208usize];
    ["Offset of field: disassemble_info::cap_insn_split"]
        [::std::mem::offset_of!(disassemble_info, cap_insn_split) - 212usize];
};
pub type disassembler_ftype = ::std::option::Option<
    unsafe extern "C" fn(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn print_insn_tci(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_big_mips(arg1: bfd_vma, arg2: *mut disassemble_info)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_little_mips(
        arg1: bfd_vma,
        arg2: *mut disassemble_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_nanomips(arg1: bfd_vma, arg2: *mut disassemble_info)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_m68k(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_z8001(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_z8002(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_h8300(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_h8300h(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_h8300s(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_h8500(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_arm_a64(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_alpha(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc_get_disassembler(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> disassembler_ftype;
}
unsafe extern "C" {
    pub fn print_insn_sparc(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_big_a29k(arg1: bfd_vma, arg2: *mut disassemble_info)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_little_a29k(
        arg1: bfd_vma,
        arg2: *mut disassemble_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_i960(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_sh(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_shl(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_hppa(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_m32r(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_m88k(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_mn10200(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_mn10300(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_ns32k(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_big_powerpc(
        arg1: bfd_vma,
        arg2: *mut disassemble_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_little_powerpc(
        arg1: bfd_vma,
        arg2: *mut disassemble_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_rs6000(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_w65(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_d10v(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_v850(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_tic30(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_microblaze(
        arg1: bfd_vma,
        arg2: *mut disassemble_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_ia64(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_xtensa(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_riscv32(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_riscv64(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_riscv128(arg1: bfd_vma, arg2: *mut disassemble_info)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_rx(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_hexagon(arg1: bfd_vma, arg2: *mut disassemble_info) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn print_insn_loongarch(
        arg1: bfd_vma,
        arg2: *mut disassemble_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cap_disas_target(info: *mut disassemble_info, pc: u64, size: usize) -> bool;
}
unsafe extern "C" {
    pub fn cap_disas_host(
        info: *mut disassemble_info,
        code: *const ::std::os::raw::c_void,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn cap_disas_monitor(
        info: *mut disassemble_info,
        pc: u64,
        count: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    pub fn cap_disas_plugin(info: *mut disassemble_info, pc: u64, size: usize) -> bool;
}
pub type bfd_boolean = bool;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct MemTxAttrs {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub unspecified: bool,
    pub _reserved1: u8,
    pub _reserved2: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemTxAttrs"][::std::mem::size_of::<MemTxAttrs>() - 8usize];
    ["Alignment of MemTxAttrs"][::std::mem::align_of::<MemTxAttrs>() - 4usize];
    ["Offset of field: MemTxAttrs::unspecified"]
        [::std::mem::offset_of!(MemTxAttrs, unspecified) - 4usize];
    ["Offset of field: MemTxAttrs::_reserved1"]
        [::std::mem::offset_of!(MemTxAttrs, _reserved1) - 5usize];
    ["Offset of field: MemTxAttrs::_reserved2"]
        [::std::mem::offset_of!(MemTxAttrs, _reserved2) - 6usize];
};
impl MemTxAttrs {
    #[inline]
    pub fn secure(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_secure(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn secure_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_secure_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn space(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_space(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn space_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_space_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn user(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_user(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn user_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_user_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn memory(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memory(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn memory_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_memory_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn requester_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_requester_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requester_id_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_requester_id_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pid(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pid(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pid_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pid_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        secure: ::std::os::raw::c_uint,
        space: ::std::os::raw::c_uint,
        user: ::std::os::raw::c_uint,
        memory: ::std::os::raw::c_uint,
        requester_id: ::std::os::raw::c_uint,
        pid: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let secure: u32 = unsafe { ::std::mem::transmute(secure) };
            secure as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let space: u32 = unsafe { ::std::mem::transmute(space) };
            space as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let user: u32 = unsafe { ::std::mem::transmute(user) };
            user as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let memory: u32 = unsafe { ::std::mem::transmute(memory) };
            memory as u64
        });
        __bindgen_bitfield_unit.set(5usize, 16u8, {
            let requester_id: u32 = unsafe { ::std::mem::transmute(requester_id) };
            requester_id as u64
        });
        __bindgen_bitfield_unit.set(21usize, 8u8, {
            let pid: u32 = unsafe { ::std::mem::transmute(pid) };
            pid as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type MemTxResult = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CPUBreakpoint {
    pub pc: vaddr,
    pub flags: ::std::os::raw::c_int,
    pub entry: CPUBreakpoint__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUBreakpoint__bindgen_ty_1 {
    pub tqe_next: *mut CPUBreakpoint,
    pub tqe_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUBreakpoint__bindgen_ty_1"]
        [::std::mem::size_of::<CPUBreakpoint__bindgen_ty_1>() - 16usize];
    ["Alignment of CPUBreakpoint__bindgen_ty_1"]
        [::std::mem::align_of::<CPUBreakpoint__bindgen_ty_1>() - 8usize];
    ["Offset of field: CPUBreakpoint__bindgen_ty_1::tqe_next"]
        [::std::mem::offset_of!(CPUBreakpoint__bindgen_ty_1, tqe_next) - 0usize];
    ["Offset of field: CPUBreakpoint__bindgen_ty_1::tqe_circ"]
        [::std::mem::offset_of!(CPUBreakpoint__bindgen_ty_1, tqe_circ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUBreakpoint"][::std::mem::size_of::<CPUBreakpoint>() - 32usize];
    ["Alignment of CPUBreakpoint"][::std::mem::align_of::<CPUBreakpoint>() - 8usize];
    ["Offset of field: CPUBreakpoint::pc"][::std::mem::offset_of!(CPUBreakpoint, pc) - 0usize];
    ["Offset of field: CPUBreakpoint::flags"]
        [::std::mem::offset_of!(CPUBreakpoint, flags) - 8usize];
    ["Offset of field: CPUBreakpoint::entry"]
        [::std::mem::offset_of!(CPUBreakpoint, entry) - 16usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CPUWatchpoint {
    pub vaddr: vaddr,
    pub len: vaddr,
    pub hitaddr: vaddr,
    pub hitattrs: MemTxAttrs,
    pub flags: ::std::os::raw::c_int,
    pub entry: CPUWatchpoint__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUWatchpoint__bindgen_ty_1 {
    pub tqe_next: *mut CPUWatchpoint,
    pub tqe_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUWatchpoint__bindgen_ty_1"]
        [::std::mem::size_of::<CPUWatchpoint__bindgen_ty_1>() - 16usize];
    ["Alignment of CPUWatchpoint__bindgen_ty_1"]
        [::std::mem::align_of::<CPUWatchpoint__bindgen_ty_1>() - 8usize];
    ["Offset of field: CPUWatchpoint__bindgen_ty_1::tqe_next"]
        [::std::mem::offset_of!(CPUWatchpoint__bindgen_ty_1, tqe_next) - 0usize];
    ["Offset of field: CPUWatchpoint__bindgen_ty_1::tqe_circ"]
        [::std::mem::offset_of!(CPUWatchpoint__bindgen_ty_1, tqe_circ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUWatchpoint"][::std::mem::size_of::<CPUWatchpoint>() - 56usize];
    ["Alignment of CPUWatchpoint"][::std::mem::align_of::<CPUWatchpoint>() - 8usize];
    ["Offset of field: CPUWatchpoint::vaddr"]
        [::std::mem::offset_of!(CPUWatchpoint, vaddr) - 0usize];
    ["Offset of field: CPUWatchpoint::len"][::std::mem::offset_of!(CPUWatchpoint, len) - 8usize];
    ["Offset of field: CPUWatchpoint::hitaddr"]
        [::std::mem::offset_of!(CPUWatchpoint, hitaddr) - 16usize];
    ["Offset of field: CPUWatchpoint::hitattrs"]
        [::std::mem::offset_of!(CPUWatchpoint, hitattrs) - 24usize];
    ["Offset of field: CPUWatchpoint::flags"]
        [::std::mem::offset_of!(CPUWatchpoint, flags) - 32usize];
    ["Offset of field: CPUWatchpoint::entry"]
        [::std::mem::offset_of!(CPUWatchpoint, entry) - 40usize];
};
pub const MMU_DATA_LOAD: MMUAccessType = 0;
pub const MMU_DATA_STORE: MMUAccessType = 1;
pub const MMU_INST_FETCH: MMUAccessType = 2;
pub type MMUAccessType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUTLBEntry {
    pub __bindgen_anon_1: CPUTLBEntry__bindgen_ty_1,
    pub addr_idx: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUTLBEntry__bindgen_ty_1 {
    pub addr_read: u64,
    pub addr_write: u64,
    pub addr_code: u64,
    pub addend: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUTLBEntry__bindgen_ty_1"]
        [::std::mem::size_of::<CPUTLBEntry__bindgen_ty_1>() - 32usize];
    ["Alignment of CPUTLBEntry__bindgen_ty_1"]
        [::std::mem::align_of::<CPUTLBEntry__bindgen_ty_1>() - 8usize];
    ["Offset of field: CPUTLBEntry__bindgen_ty_1::addr_read"]
        [::std::mem::offset_of!(CPUTLBEntry__bindgen_ty_1, addr_read) - 0usize];
    ["Offset of field: CPUTLBEntry__bindgen_ty_1::addr_write"]
        [::std::mem::offset_of!(CPUTLBEntry__bindgen_ty_1, addr_write) - 8usize];
    ["Offset of field: CPUTLBEntry__bindgen_ty_1::addr_code"]
        [::std::mem::offset_of!(CPUTLBEntry__bindgen_ty_1, addr_code) - 16usize];
    ["Offset of field: CPUTLBEntry__bindgen_ty_1::addend"]
        [::std::mem::offset_of!(CPUTLBEntry__bindgen_ty_1, addend) - 24usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUTLBEntry"][::std::mem::size_of::<CPUTLBEntry>() - 32usize];
    ["Alignment of CPUTLBEntry"][::std::mem::align_of::<CPUTLBEntry>() - 8usize];
    ["Offset of field: CPUTLBEntry::addr_idx"]
        [::std::mem::offset_of!(CPUTLBEntry, addr_idx) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUTLBDescFast {
    pub mask: usize,
    pub table: *mut CPUTLBEntry,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUTLBDescFast"][::std::mem::size_of::<CPUTLBDescFast>() - 16usize];
    ["Alignment of CPUTLBDescFast"][::std::mem::align_of::<CPUTLBDescFast>() - 8usize];
    ["Offset of field: CPUTLBDescFast::mask"]
        [::std::mem::offset_of!(CPUTLBDescFast, mask) - 0usize];
    ["Offset of field: CPUTLBDescFast::table"]
        [::std::mem::offset_of!(CPUTLBDescFast, table) - 8usize];
};
pub const IO_OPERATION_TYPE_READ: IoOperationType = 0;
pub const IO_OPERATION_TYPE_WRITE: IoOperationType = 1;
pub const IO_OPERATION_TYPE__MAX: IoOperationType = 2;
pub type IoOperationType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static IoOperationType_lookup: QEnumLookup;
}
pub const ON_OFF_AUTO_AUTO: OnOffAuto = 0;
pub const ON_OFF_AUTO_ON: OnOffAuto = 1;
pub const ON_OFF_AUTO_OFF: OnOffAuto = 2;
pub const ON_OFF_AUTO__MAX: OnOffAuto = 3;
pub type OnOffAuto = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static OnOffAuto_lookup: QEnumLookup;
}
pub const ON_OFF_SPLIT_ON: OnOffSplit = 0;
pub const ON_OFF_SPLIT_OFF: OnOffSplit = 1;
pub const ON_OFF_SPLIT_SPLIT: OnOffSplit = 2;
pub const ON_OFF_SPLIT__MAX: OnOffSplit = 3;
pub type OnOffSplit = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static OnOffSplit_lookup: QEnumLookup;
}
pub const OFF_AUTO_PCIBAR_OFF: OffAutoPCIBAR = 0;
pub const OFF_AUTO_PCIBAR_AUTO: OffAutoPCIBAR = 1;
pub const OFF_AUTO_PCIBAR_BAR0: OffAutoPCIBAR = 2;
pub const OFF_AUTO_PCIBAR_BAR1: OffAutoPCIBAR = 3;
pub const OFF_AUTO_PCIBAR_BAR2: OffAutoPCIBAR = 4;
pub const OFF_AUTO_PCIBAR_BAR3: OffAutoPCIBAR = 5;
pub const OFF_AUTO_PCIBAR_BAR4: OffAutoPCIBAR = 6;
pub const OFF_AUTO_PCIBAR_BAR5: OffAutoPCIBAR = 7;
pub const OFF_AUTO_PCIBAR__MAX: OffAutoPCIBAR = 8;
pub type OffAutoPCIBAR = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static OffAutoPCIBAR_lookup: QEnumLookup;
}
pub const PCIE_LINK_SPEED_2_5: PCIELinkSpeed = 0;
pub const PCIE_LINK_SPEED_5: PCIELinkSpeed = 1;
pub const PCIE_LINK_SPEED_8: PCIELinkSpeed = 2;
pub const PCIE_LINK_SPEED_16: PCIELinkSpeed = 3;
pub const PCIE_LINK_SPEED_32: PCIELinkSpeed = 4;
pub const PCIE_LINK_SPEED_64: PCIELinkSpeed = 5;
pub const PCIE_LINK_SPEED__MAX: PCIELinkSpeed = 6;
pub type PCIELinkSpeed = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static PCIELinkSpeed_lookup: QEnumLookup;
}
pub const PCIE_LINK_WIDTH_1: PCIELinkWidth = 0;
pub const PCIE_LINK_WIDTH_2: PCIELinkWidth = 1;
pub const PCIE_LINK_WIDTH_4: PCIELinkWidth = 2;
pub const PCIE_LINK_WIDTH_8: PCIELinkWidth = 3;
pub const PCIE_LINK_WIDTH_12: PCIELinkWidth = 4;
pub const PCIE_LINK_WIDTH_16: PCIELinkWidth = 5;
pub const PCIE_LINK_WIDTH_32: PCIELinkWidth = 6;
pub const PCIE_LINK_WIDTH__MAX: PCIELinkWidth = 7;
pub type PCIELinkWidth = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static PCIELinkWidth_lookup: QEnumLookup;
}
pub const HOST_MEM_POLICY_DEFAULT: HostMemPolicy = 0;
pub const HOST_MEM_POLICY_PREFERRED: HostMemPolicy = 1;
pub const HOST_MEM_POLICY_BIND: HostMemPolicy = 2;
pub const HOST_MEM_POLICY_INTERLEAVE: HostMemPolicy = 3;
pub const HOST_MEM_POLICY__MAX: HostMemPolicy = 4;
pub type HostMemPolicy = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static HostMemPolicy_lookup: QEnumLookup;
}
pub const NET_FILTER_DIRECTION_ALL: NetFilterDirection = 0;
pub const NET_FILTER_DIRECTION_RX: NetFilterDirection = 1;
pub const NET_FILTER_DIRECTION_TX: NetFilterDirection = 2;
pub const NET_FILTER_DIRECTION__MAX: NetFilterDirection = 3;
pub type NetFilterDirection = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static NetFilterDirection_lookup: QEnumLookup;
}
pub const GRAB_TOGGLE_KEYS_CTRL_CTRL: GrabToggleKeys = 0;
pub const GRAB_TOGGLE_KEYS_ALT_ALT: GrabToggleKeys = 1;
pub const GRAB_TOGGLE_KEYS_SHIFT_SHIFT: GrabToggleKeys = 2;
pub const GRAB_TOGGLE_KEYS_META_META: GrabToggleKeys = 3;
pub const GRAB_TOGGLE_KEYS_SCROLLLOCK: GrabToggleKeys = 4;
pub const GRAB_TOGGLE_KEYS_CTRL_SCROLLLOCK: GrabToggleKeys = 5;
pub const GRAB_TOGGLE_KEYS__MAX: GrabToggleKeys = 6;
pub type GrabToggleKeys = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static GrabToggleKeys_lookup: QEnumLookup;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct StrOrNull {
    pub type_: QType,
    pub u: StrOrNull__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union StrOrNull__bindgen_ty_1 {
    pub s: *mut ::std::os::raw::c_char,
    pub n: *mut QNull,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of StrOrNull__bindgen_ty_1"][::std::mem::size_of::<StrOrNull__bindgen_ty_1>() - 8usize];
    ["Alignment of StrOrNull__bindgen_ty_1"]
        [::std::mem::align_of::<StrOrNull__bindgen_ty_1>() - 8usize];
    ["Offset of field: StrOrNull__bindgen_ty_1::s"]
        [::std::mem::offset_of!(StrOrNull__bindgen_ty_1, s) - 0usize];
    ["Offset of field: StrOrNull__bindgen_ty_1::n"]
        [::std::mem::offset_of!(StrOrNull__bindgen_ty_1, n) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of StrOrNull"][::std::mem::size_of::<StrOrNull>() - 16usize];
    ["Alignment of StrOrNull"][::std::mem::align_of::<StrOrNull>() - 8usize];
    ["Offset of field: StrOrNull::type_"][::std::mem::offset_of!(StrOrNull, type_) - 0usize];
    ["Offset of field: StrOrNull::u"][::std::mem::offset_of!(StrOrNull, u) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_StrOrNull(obj: *mut StrOrNull);
}
pub type StrOrNull_autoptr = *mut StrOrNull;
pub type StrOrNull_listautoptr = *mut GList;
pub type StrOrNull_slistautoptr = *mut GSList;
pub type StrOrNull_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HumanReadableText {
    pub human_readable_text: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HumanReadableText"][::std::mem::size_of::<HumanReadableText>() - 8usize];
    ["Alignment of HumanReadableText"][::std::mem::align_of::<HumanReadableText>() - 8usize];
    ["Offset of field: HumanReadableText::human_readable_text"]
        [::std::mem::offset_of!(HumanReadableText, human_readable_text) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_HumanReadableText(obj: *mut HumanReadableText);
}
pub type HumanReadableText_autoptr = *mut HumanReadableText;
pub type HumanReadableText_listautoptr = *mut GList;
pub type HumanReadableText_slistautoptr = *mut GSList;
pub type HumanReadableText_queueautoptr = *mut GQueue;
pub const S390_CPU_ENTITLEMENT_AUTO: S390CpuEntitlement = 0;
pub const S390_CPU_ENTITLEMENT_LOW: S390CpuEntitlement = 1;
pub const S390_CPU_ENTITLEMENT_MEDIUM: S390CpuEntitlement = 2;
pub const S390_CPU_ENTITLEMENT_HIGH: S390CpuEntitlement = 3;
pub const S390_CPU_ENTITLEMENT__MAX: S390CpuEntitlement = 4;
pub type S390CpuEntitlement = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static S390CpuEntitlement_lookup: QEnumLookup;
}
pub const CPU_TOPOLOGY_LEVEL_THREAD: CpuTopologyLevel = 0;
pub const CPU_TOPOLOGY_LEVEL_CORE: CpuTopologyLevel = 1;
pub const CPU_TOPOLOGY_LEVEL_MODULE: CpuTopologyLevel = 2;
pub const CPU_TOPOLOGY_LEVEL_CLUSTER: CpuTopologyLevel = 3;
pub const CPU_TOPOLOGY_LEVEL_DIE: CpuTopologyLevel = 4;
pub const CPU_TOPOLOGY_LEVEL_SOCKET: CpuTopologyLevel = 5;
pub const CPU_TOPOLOGY_LEVEL_BOOK: CpuTopologyLevel = 6;
pub const CPU_TOPOLOGY_LEVEL_DRAWER: CpuTopologyLevel = 7;
pub const CPU_TOPOLOGY_LEVEL_DEFAULT: CpuTopologyLevel = 8;
pub const CPU_TOPOLOGY_LEVEL__MAX: CpuTopologyLevel = 9;
pub type CpuTopologyLevel = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static CpuTopologyLevel_lookup: QEnumLookup;
}
pub const CACHE_LEVEL_AND_TYPE_L1D: CacheLevelAndType = 0;
pub const CACHE_LEVEL_AND_TYPE_L1I: CacheLevelAndType = 1;
pub const CACHE_LEVEL_AND_TYPE_L2: CacheLevelAndType = 2;
pub const CACHE_LEVEL_AND_TYPE_L3: CacheLevelAndType = 3;
pub const CACHE_LEVEL_AND_TYPE__MAX: CacheLevelAndType = 4;
pub type CacheLevelAndType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static CacheLevelAndType_lookup: QEnumLookup;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmpCacheProperties {
    pub cache: CacheLevelAndType,
    pub topology: CpuTopologyLevel,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SmpCacheProperties"][::std::mem::size_of::<SmpCacheProperties>() - 8usize];
    ["Alignment of SmpCacheProperties"][::std::mem::align_of::<SmpCacheProperties>() - 4usize];
    ["Offset of field: SmpCacheProperties::cache"]
        [::std::mem::offset_of!(SmpCacheProperties, cache) - 0usize];
    ["Offset of field: SmpCacheProperties::topology"]
        [::std::mem::offset_of!(SmpCacheProperties, topology) - 4usize];
};
unsafe extern "C" {
    pub fn qapi_free_SmpCacheProperties(obj: *mut SmpCacheProperties);
}
pub type SmpCacheProperties_autoptr = *mut SmpCacheProperties;
pub type SmpCacheProperties_listautoptr = *mut GList;
pub type SmpCacheProperties_slistautoptr = *mut GSList;
pub type SmpCacheProperties_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmpCachePropertiesList {
    pub next: *mut SmpCachePropertiesList,
    pub value: *mut SmpCacheProperties,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SmpCachePropertiesList"][::std::mem::size_of::<SmpCachePropertiesList>() - 16usize];
    ["Alignment of SmpCachePropertiesList"]
        [::std::mem::align_of::<SmpCachePropertiesList>() - 8usize];
    ["Offset of field: SmpCachePropertiesList::next"]
        [::std::mem::offset_of!(SmpCachePropertiesList, next) - 0usize];
    ["Offset of field: SmpCachePropertiesList::value"]
        [::std::mem::offset_of!(SmpCachePropertiesList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_SmpCachePropertiesList(obj: *mut SmpCachePropertiesList);
}
pub type SmpCachePropertiesList_autoptr = *mut SmpCachePropertiesList;
pub type SmpCachePropertiesList_listautoptr = *mut GList;
pub type SmpCachePropertiesList_slistautoptr = *mut GSList;
pub type SmpCachePropertiesList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmpCachePropertiesWrapper {
    pub caches: *mut SmpCachePropertiesList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SmpCachePropertiesWrapper"]
        [::std::mem::size_of::<SmpCachePropertiesWrapper>() - 8usize];
    ["Alignment of SmpCachePropertiesWrapper"]
        [::std::mem::align_of::<SmpCachePropertiesWrapper>() - 8usize];
    ["Offset of field: SmpCachePropertiesWrapper::caches"]
        [::std::mem::offset_of!(SmpCachePropertiesWrapper, caches) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_SmpCachePropertiesWrapper(obj: *mut SmpCachePropertiesWrapper);
}
pub type SmpCachePropertiesWrapper_autoptr = *mut SmpCachePropertiesWrapper;
pub type SmpCachePropertiesWrapper_listautoptr = *mut GList;
pub type SmpCachePropertiesWrapper_slistautoptr = *mut GSList;
pub type SmpCachePropertiesWrapper_queueautoptr = *mut GQueue;
pub const SYS_EMU_TARGET_AARCH64: SysEmuTarget = 0;
pub const SYS_EMU_TARGET_ALPHA: SysEmuTarget = 1;
pub const SYS_EMU_TARGET_ARM: SysEmuTarget = 2;
pub const SYS_EMU_TARGET_AVR: SysEmuTarget = 3;
pub const SYS_EMU_TARGET_HPPA: SysEmuTarget = 4;
pub const SYS_EMU_TARGET_I386: SysEmuTarget = 5;
pub const SYS_EMU_TARGET_LOONGARCH64: SysEmuTarget = 6;
pub const SYS_EMU_TARGET_M68K: SysEmuTarget = 7;
pub const SYS_EMU_TARGET_MICROBLAZE: SysEmuTarget = 8;
pub const SYS_EMU_TARGET_MICROBLAZEEL: SysEmuTarget = 9;
pub const SYS_EMU_TARGET_MIPS: SysEmuTarget = 10;
pub const SYS_EMU_TARGET_MIPS64: SysEmuTarget = 11;
pub const SYS_EMU_TARGET_MIPS64EL: SysEmuTarget = 12;
pub const SYS_EMU_TARGET_MIPSEL: SysEmuTarget = 13;
pub const SYS_EMU_TARGET_OR1K: SysEmuTarget = 14;
pub const SYS_EMU_TARGET_PPC: SysEmuTarget = 15;
pub const SYS_EMU_TARGET_PPC64: SysEmuTarget = 16;
pub const SYS_EMU_TARGET_RISCV32: SysEmuTarget = 17;
pub const SYS_EMU_TARGET_RISCV64: SysEmuTarget = 18;
pub const SYS_EMU_TARGET_RX: SysEmuTarget = 19;
pub const SYS_EMU_TARGET_S390X: SysEmuTarget = 20;
pub const SYS_EMU_TARGET_SH4: SysEmuTarget = 21;
pub const SYS_EMU_TARGET_SH4EB: SysEmuTarget = 22;
pub const SYS_EMU_TARGET_SPARC: SysEmuTarget = 23;
pub const SYS_EMU_TARGET_SPARC64: SysEmuTarget = 24;
pub const SYS_EMU_TARGET_TRICORE: SysEmuTarget = 25;
pub const SYS_EMU_TARGET_X86_64: SysEmuTarget = 26;
pub const SYS_EMU_TARGET_XTENSA: SysEmuTarget = 27;
pub const SYS_EMU_TARGET_XTENSAEB: SysEmuTarget = 28;
pub const SYS_EMU_TARGET__MAX: SysEmuTarget = 29;
pub type SysEmuTarget = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static SysEmuTarget_lookup: QEnumLookup;
}
pub const S390_CPU_STATE_UNINITIALIZED: S390CpuState = 0;
pub const S390_CPU_STATE_STOPPED: S390CpuState = 1;
pub const S390_CPU_STATE_CHECK_STOP: S390CpuState = 2;
pub const S390_CPU_STATE_OPERATING: S390CpuState = 3;
pub const S390_CPU_STATE_LOAD: S390CpuState = 4;
pub const S390_CPU_STATE__MAX: S390CpuState = 5;
pub type S390CpuState = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static S390CpuState_lookup: QEnumLookup;
}
pub const LOST_TICK_POLICY_DISCARD: LostTickPolicy = 0;
pub const LOST_TICK_POLICY_DELAY: LostTickPolicy = 1;
pub const LOST_TICK_POLICY_SLEW: LostTickPolicy = 2;
pub const LOST_TICK_POLICY__MAX: LostTickPolicy = 3;
pub type LostTickPolicy = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static LostTickPolicy_lookup: QEnumLookup;
}
pub const NUMA_OPTIONS_TYPE_NODE: NumaOptionsType = 0;
pub const NUMA_OPTIONS_TYPE_DIST: NumaOptionsType = 1;
pub const NUMA_OPTIONS_TYPE_CPU: NumaOptionsType = 2;
pub const NUMA_OPTIONS_TYPE_HMAT_LB: NumaOptionsType = 3;
pub const NUMA_OPTIONS_TYPE_HMAT_CACHE: NumaOptionsType = 4;
pub const NUMA_OPTIONS_TYPE__MAX: NumaOptionsType = 5;
pub type NumaOptionsType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static NumaOptionsType_lookup: QEnumLookup;
}
pub const X86_CPU_REGISTER32_EAX: X86CPURegister32 = 0;
pub const X86_CPU_REGISTER32_EBX: X86CPURegister32 = 1;
pub const X86_CPU_REGISTER32_ECX: X86CPURegister32 = 2;
pub const X86_CPU_REGISTER32_EDX: X86CPURegister32 = 3;
pub const X86_CPU_REGISTER32_ESP: X86CPURegister32 = 4;
pub const X86_CPU_REGISTER32_EBP: X86CPURegister32 = 5;
pub const X86_CPU_REGISTER32_ESI: X86CPURegister32 = 6;
pub const X86_CPU_REGISTER32_EDI: X86CPURegister32 = 7;
pub const X86_CPU_REGISTER32__MAX: X86CPURegister32 = 8;
pub type X86CPURegister32 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static X86CPURegister32_lookup: QEnumLookup;
}
pub const HMAT_LB_MEMORY_HIERARCHY_MEMORY: HmatLBMemoryHierarchy = 0;
pub const HMAT_LB_MEMORY_HIERARCHY_FIRST_LEVEL: HmatLBMemoryHierarchy = 1;
pub const HMAT_LB_MEMORY_HIERARCHY_SECOND_LEVEL: HmatLBMemoryHierarchy = 2;
pub const HMAT_LB_MEMORY_HIERARCHY_THIRD_LEVEL: HmatLBMemoryHierarchy = 3;
pub const HMAT_LB_MEMORY_HIERARCHY__MAX: HmatLBMemoryHierarchy = 4;
pub type HmatLBMemoryHierarchy = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static HmatLBMemoryHierarchy_lookup: QEnumLookup;
}
pub const HMAT_LB_DATA_TYPE_ACCESS_LATENCY: HmatLBDataType = 0;
pub const HMAT_LB_DATA_TYPE_READ_LATENCY: HmatLBDataType = 1;
pub const HMAT_LB_DATA_TYPE_WRITE_LATENCY: HmatLBDataType = 2;
pub const HMAT_LB_DATA_TYPE_ACCESS_BANDWIDTH: HmatLBDataType = 3;
pub const HMAT_LB_DATA_TYPE_READ_BANDWIDTH: HmatLBDataType = 4;
pub const HMAT_LB_DATA_TYPE_WRITE_BANDWIDTH: HmatLBDataType = 5;
pub const HMAT_LB_DATA_TYPE__MAX: HmatLBDataType = 6;
pub type HmatLBDataType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static HmatLBDataType_lookup: QEnumLookup;
}
pub const HMAT_CACHE_ASSOCIATIVITY_NONE: HmatCacheAssociativity = 0;
pub const HMAT_CACHE_ASSOCIATIVITY_DIRECT: HmatCacheAssociativity = 1;
pub const HMAT_CACHE_ASSOCIATIVITY_COMPLEX: HmatCacheAssociativity = 2;
pub const HMAT_CACHE_ASSOCIATIVITY__MAX: HmatCacheAssociativity = 3;
pub type HmatCacheAssociativity = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static HmatCacheAssociativity_lookup: QEnumLookup;
}
pub const HMAT_CACHE_WRITE_POLICY_NONE: HmatCacheWritePolicy = 0;
pub const HMAT_CACHE_WRITE_POLICY_WRITE_BACK: HmatCacheWritePolicy = 1;
pub const HMAT_CACHE_WRITE_POLICY_WRITE_THROUGH: HmatCacheWritePolicy = 2;
pub const HMAT_CACHE_WRITE_POLICY__MAX: HmatCacheWritePolicy = 3;
pub type HmatCacheWritePolicy = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static HmatCacheWritePolicy_lookup: QEnumLookup;
}
pub const MEMORY_DEVICE_INFO_KIND_DIMM: MemoryDeviceInfoKind = 0;
pub const MEMORY_DEVICE_INFO_KIND_NVDIMM: MemoryDeviceInfoKind = 1;
pub const MEMORY_DEVICE_INFO_KIND_VIRTIO_PMEM: MemoryDeviceInfoKind = 2;
pub const MEMORY_DEVICE_INFO_KIND_VIRTIO_MEM: MemoryDeviceInfoKind = 3;
pub const MEMORY_DEVICE_INFO_KIND_SGX_EPC: MemoryDeviceInfoKind = 4;
pub const MEMORY_DEVICE_INFO_KIND_HV_BALLOON: MemoryDeviceInfoKind = 5;
pub const MEMORY_DEVICE_INFO_KIND__MAX: MemoryDeviceInfoKind = 6;
pub type MemoryDeviceInfoKind = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static MemoryDeviceInfoKind_lookup: QEnumLookup;
}
pub const SMBIOS_ENTRY_POINT_TYPE_32: SmbiosEntryPointType = 0;
pub const SMBIOS_ENTRY_POINT_TYPE_64: SmbiosEntryPointType = 1;
pub const SMBIOS_ENTRY_POINT_TYPE_AUTO: SmbiosEntryPointType = 2;
pub const SMBIOS_ENTRY_POINT_TYPE__MAX: SmbiosEntryPointType = 3;
pub type SmbiosEntryPointType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static SmbiosEntryPointType_lookup: QEnumLookup;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CpuInfoS390 {
    pub cpu_state: S390CpuState,
    pub has_dedicated: bool,
    pub dedicated: bool,
    pub has_entitlement: bool,
    pub entitlement: S390CpuEntitlement,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CpuInfoS390"][::std::mem::size_of::<CpuInfoS390>() - 12usize];
    ["Alignment of CpuInfoS390"][::std::mem::align_of::<CpuInfoS390>() - 4usize];
    ["Offset of field: CpuInfoS390::cpu_state"]
        [::std::mem::offset_of!(CpuInfoS390, cpu_state) - 0usize];
    ["Offset of field: CpuInfoS390::has_dedicated"]
        [::std::mem::offset_of!(CpuInfoS390, has_dedicated) - 4usize];
    ["Offset of field: CpuInfoS390::dedicated"]
        [::std::mem::offset_of!(CpuInfoS390, dedicated) - 5usize];
    ["Offset of field: CpuInfoS390::has_entitlement"]
        [::std::mem::offset_of!(CpuInfoS390, has_entitlement) - 6usize];
    ["Offset of field: CpuInfoS390::entitlement"]
        [::std::mem::offset_of!(CpuInfoS390, entitlement) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_CpuInfoS390(obj: *mut CpuInfoS390);
}
pub type CpuInfoS390_autoptr = *mut CpuInfoS390;
pub type CpuInfoS390_listautoptr = *mut GList;
pub type CpuInfoS390_slistautoptr = *mut GSList;
pub type CpuInfoS390_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_CpuInfoFast_base {
    pub cpu_index: i64,
    pub qom_path: *mut ::std::os::raw::c_char,
    pub thread_id: i64,
    pub props: *mut CpuInstanceProperties,
    pub target: SysEmuTarget,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_CpuInfoFast_base"][::std::mem::size_of::<q_obj_CpuInfoFast_base>() - 40usize];
    ["Alignment of q_obj_CpuInfoFast_base"]
        [::std::mem::align_of::<q_obj_CpuInfoFast_base>() - 8usize];
    ["Offset of field: q_obj_CpuInfoFast_base::cpu_index"]
        [::std::mem::offset_of!(q_obj_CpuInfoFast_base, cpu_index) - 0usize];
    ["Offset of field: q_obj_CpuInfoFast_base::qom_path"]
        [::std::mem::offset_of!(q_obj_CpuInfoFast_base, qom_path) - 8usize];
    ["Offset of field: q_obj_CpuInfoFast_base::thread_id"]
        [::std::mem::offset_of!(q_obj_CpuInfoFast_base, thread_id) - 16usize];
    ["Offset of field: q_obj_CpuInfoFast_base::props"]
        [::std::mem::offset_of!(q_obj_CpuInfoFast_base, props) - 24usize];
    ["Offset of field: q_obj_CpuInfoFast_base::target"]
        [::std::mem::offset_of!(q_obj_CpuInfoFast_base, target) - 32usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CpuInfoFast {
    pub cpu_index: i64,
    pub qom_path: *mut ::std::os::raw::c_char,
    pub thread_id: i64,
    pub props: *mut CpuInstanceProperties,
    pub target: SysEmuTarget,
    pub u: CpuInfoFast__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CpuInfoFast__bindgen_ty_1 {
    pub s390x: CpuInfoS390,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CpuInfoFast__bindgen_ty_1"]
        [::std::mem::size_of::<CpuInfoFast__bindgen_ty_1>() - 12usize];
    ["Alignment of CpuInfoFast__bindgen_ty_1"]
        [::std::mem::align_of::<CpuInfoFast__bindgen_ty_1>() - 4usize];
    ["Offset of field: CpuInfoFast__bindgen_ty_1::s390x"]
        [::std::mem::offset_of!(CpuInfoFast__bindgen_ty_1, s390x) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CpuInfoFast"][::std::mem::size_of::<CpuInfoFast>() - 48usize];
    ["Alignment of CpuInfoFast"][::std::mem::align_of::<CpuInfoFast>() - 8usize];
    ["Offset of field: CpuInfoFast::cpu_index"]
        [::std::mem::offset_of!(CpuInfoFast, cpu_index) - 0usize];
    ["Offset of field: CpuInfoFast::qom_path"]
        [::std::mem::offset_of!(CpuInfoFast, qom_path) - 8usize];
    ["Offset of field: CpuInfoFast::thread_id"]
        [::std::mem::offset_of!(CpuInfoFast, thread_id) - 16usize];
    ["Offset of field: CpuInfoFast::props"][::std::mem::offset_of!(CpuInfoFast, props) - 24usize];
    ["Offset of field: CpuInfoFast::target"][::std::mem::offset_of!(CpuInfoFast, target) - 32usize];
    ["Offset of field: CpuInfoFast::u"][::std::mem::offset_of!(CpuInfoFast, u) - 36usize];
};
unsafe extern "C" {
    pub fn qapi_free_CpuInfoFast(obj: *mut CpuInfoFast);
}
pub type CpuInfoFast_autoptr = *mut CpuInfoFast;
pub type CpuInfoFast_listautoptr = *mut GList;
pub type CpuInfoFast_slistautoptr = *mut GSList;
pub type CpuInfoFast_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CpuInfoFastList {
    pub next: *mut CpuInfoFastList,
    pub value: *mut CpuInfoFast,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CpuInfoFastList"][::std::mem::size_of::<CpuInfoFastList>() - 16usize];
    ["Alignment of CpuInfoFastList"][::std::mem::align_of::<CpuInfoFastList>() - 8usize];
    ["Offset of field: CpuInfoFastList::next"]
        [::std::mem::offset_of!(CpuInfoFastList, next) - 0usize];
    ["Offset of field: CpuInfoFastList::value"]
        [::std::mem::offset_of!(CpuInfoFastList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_CpuInfoFastList(obj: *mut CpuInfoFastList);
}
pub type CpuInfoFastList_autoptr = *mut CpuInfoFastList;
pub type CpuInfoFastList_listautoptr = *mut GList;
pub type CpuInfoFastList_slistautoptr = *mut GSList;
pub type CpuInfoFastList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompatProperty {
    pub qom_type: *mut ::std::os::raw::c_char,
    pub property: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CompatProperty"][::std::mem::size_of::<CompatProperty>() - 24usize];
    ["Alignment of CompatProperty"][::std::mem::align_of::<CompatProperty>() - 8usize];
    ["Offset of field: CompatProperty::qom_type"]
        [::std::mem::offset_of!(CompatProperty, qom_type) - 0usize];
    ["Offset of field: CompatProperty::property"]
        [::std::mem::offset_of!(CompatProperty, property) - 8usize];
    ["Offset of field: CompatProperty::value"]
        [::std::mem::offset_of!(CompatProperty, value) - 16usize];
};
unsafe extern "C" {
    pub fn qapi_free_CompatProperty(obj: *mut CompatProperty);
}
pub type CompatProperty_autoptr = *mut CompatProperty;
pub type CompatProperty_listautoptr = *mut GList;
pub type CompatProperty_slistautoptr = *mut GSList;
pub type CompatProperty_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompatPropertyList {
    pub next: *mut CompatPropertyList,
    pub value: *mut CompatProperty,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CompatPropertyList"][::std::mem::size_of::<CompatPropertyList>() - 16usize];
    ["Alignment of CompatPropertyList"][::std::mem::align_of::<CompatPropertyList>() - 8usize];
    ["Offset of field: CompatPropertyList::next"]
        [::std::mem::offset_of!(CompatPropertyList, next) - 0usize];
    ["Offset of field: CompatPropertyList::value"]
        [::std::mem::offset_of!(CompatPropertyList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_CompatPropertyList(obj: *mut CompatPropertyList);
}
pub type CompatPropertyList_autoptr = *mut CompatPropertyList;
pub type CompatPropertyList_listautoptr = *mut GList;
pub type CompatPropertyList_slistautoptr = *mut GSList;
pub type CompatPropertyList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MachineInfo {
    pub name: *mut ::std::os::raw::c_char,
    pub alias: *mut ::std::os::raw::c_char,
    pub has_is_default: bool,
    pub is_default: bool,
    pub cpu_max: i64,
    pub hotpluggable_cpus: bool,
    pub numa_mem_supported: bool,
    pub deprecated: bool,
    pub default_cpu_type: *mut ::std::os::raw::c_char,
    pub default_ram_id: *mut ::std::os::raw::c_char,
    pub acpi: bool,
    pub has_compat_props: bool,
    pub compat_props: *mut CompatPropertyList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MachineInfo"][::std::mem::size_of::<MachineInfo>() - 72usize];
    ["Alignment of MachineInfo"][::std::mem::align_of::<MachineInfo>() - 8usize];
    ["Offset of field: MachineInfo::name"][::std::mem::offset_of!(MachineInfo, name) - 0usize];
    ["Offset of field: MachineInfo::alias"][::std::mem::offset_of!(MachineInfo, alias) - 8usize];
    ["Offset of field: MachineInfo::has_is_default"]
        [::std::mem::offset_of!(MachineInfo, has_is_default) - 16usize];
    ["Offset of field: MachineInfo::is_default"]
        [::std::mem::offset_of!(MachineInfo, is_default) - 17usize];
    ["Offset of field: MachineInfo::cpu_max"]
        [::std::mem::offset_of!(MachineInfo, cpu_max) - 24usize];
    ["Offset of field: MachineInfo::hotpluggable_cpus"]
        [::std::mem::offset_of!(MachineInfo, hotpluggable_cpus) - 32usize];
    ["Offset of field: MachineInfo::numa_mem_supported"]
        [::std::mem::offset_of!(MachineInfo, numa_mem_supported) - 33usize];
    ["Offset of field: MachineInfo::deprecated"]
        [::std::mem::offset_of!(MachineInfo, deprecated) - 34usize];
    ["Offset of field: MachineInfo::default_cpu_type"]
        [::std::mem::offset_of!(MachineInfo, default_cpu_type) - 40usize];
    ["Offset of field: MachineInfo::default_ram_id"]
        [::std::mem::offset_of!(MachineInfo, default_ram_id) - 48usize];
    ["Offset of field: MachineInfo::acpi"][::std::mem::offset_of!(MachineInfo, acpi) - 56usize];
    ["Offset of field: MachineInfo::has_compat_props"]
        [::std::mem::offset_of!(MachineInfo, has_compat_props) - 57usize];
    ["Offset of field: MachineInfo::compat_props"]
        [::std::mem::offset_of!(MachineInfo, compat_props) - 64usize];
};
unsafe extern "C" {
    pub fn qapi_free_MachineInfo(obj: *mut MachineInfo);
}
pub type MachineInfo_autoptr = *mut MachineInfo;
pub type MachineInfo_listautoptr = *mut GList;
pub type MachineInfo_slistautoptr = *mut GSList;
pub type MachineInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_query_machines_arg {
    pub has_compat_props: bool,
    pub compat_props: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_query_machines_arg"]
        [::std::mem::size_of::<q_obj_query_machines_arg>() - 2usize];
    ["Alignment of q_obj_query_machines_arg"]
        [::std::mem::align_of::<q_obj_query_machines_arg>() - 1usize];
    ["Offset of field: q_obj_query_machines_arg::has_compat_props"]
        [::std::mem::offset_of!(q_obj_query_machines_arg, has_compat_props) - 0usize];
    ["Offset of field: q_obj_query_machines_arg::compat_props"]
        [::std::mem::offset_of!(q_obj_query_machines_arg, compat_props) - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MachineInfoList {
    pub next: *mut MachineInfoList,
    pub value: *mut MachineInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MachineInfoList"][::std::mem::size_of::<MachineInfoList>() - 16usize];
    ["Alignment of MachineInfoList"][::std::mem::align_of::<MachineInfoList>() - 8usize];
    ["Offset of field: MachineInfoList::next"]
        [::std::mem::offset_of!(MachineInfoList, next) - 0usize];
    ["Offset of field: MachineInfoList::value"]
        [::std::mem::offset_of!(MachineInfoList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_MachineInfoList(obj: *mut MachineInfoList);
}
pub type MachineInfoList_autoptr = *mut MachineInfoList;
pub type MachineInfoList_listautoptr = *mut GList;
pub type MachineInfoList_slistautoptr = *mut GSList;
pub type MachineInfoList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CurrentMachineParams {
    pub wakeup_suspend_support: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CurrentMachineParams"][::std::mem::size_of::<CurrentMachineParams>() - 1usize];
    ["Alignment of CurrentMachineParams"][::std::mem::align_of::<CurrentMachineParams>() - 1usize];
    ["Offset of field: CurrentMachineParams::wakeup_suspend_support"]
        [::std::mem::offset_of!(CurrentMachineParams, wakeup_suspend_support) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_CurrentMachineParams(obj: *mut CurrentMachineParams);
}
pub type CurrentMachineParams_autoptr = *mut CurrentMachineParams;
pub type CurrentMachineParams_listautoptr = *mut GList;
pub type CurrentMachineParams_slistautoptr = *mut GSList;
pub type CurrentMachineParams_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TargetInfo {
    pub arch: SysEmuTarget,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TargetInfo"][::std::mem::size_of::<TargetInfo>() - 4usize];
    ["Alignment of TargetInfo"][::std::mem::align_of::<TargetInfo>() - 4usize];
    ["Offset of field: TargetInfo::arch"][::std::mem::offset_of!(TargetInfo, arch) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_TargetInfo(obj: *mut TargetInfo);
}
pub type TargetInfo_autoptr = *mut TargetInfo;
pub type TargetInfo_listautoptr = *mut GList;
pub type TargetInfo_slistautoptr = *mut GSList;
pub type TargetInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UuidInfo {
    pub UUID: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of UuidInfo"][::std::mem::size_of::<UuidInfo>() - 8usize];
    ["Alignment of UuidInfo"][::std::mem::align_of::<UuidInfo>() - 8usize];
    ["Offset of field: UuidInfo::UUID"][::std::mem::offset_of!(UuidInfo, UUID) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_UuidInfo(obj: *mut UuidInfo);
}
pub type UuidInfo_autoptr = *mut UuidInfo;
pub type UuidInfo_listautoptr = *mut GList;
pub type UuidInfo_slistautoptr = *mut GSList;
pub type UuidInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GuidInfo {
    pub guid: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GuidInfo"][::std::mem::size_of::<GuidInfo>() - 8usize];
    ["Alignment of GuidInfo"][::std::mem::align_of::<GuidInfo>() - 8usize];
    ["Offset of field: GuidInfo::guid"][::std::mem::offset_of!(GuidInfo, guid) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_GuidInfo(obj: *mut GuidInfo);
}
pub type GuidInfo_autoptr = *mut GuidInfo;
pub type GuidInfo_listautoptr = *mut GList;
pub type GuidInfo_slistautoptr = *mut GSList;
pub type GuidInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KvmInfo {
    pub enabled: bool,
    pub present: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of KvmInfo"][::std::mem::size_of::<KvmInfo>() - 2usize];
    ["Alignment of KvmInfo"][::std::mem::align_of::<KvmInfo>() - 1usize];
    ["Offset of field: KvmInfo::enabled"][::std::mem::offset_of!(KvmInfo, enabled) - 0usize];
    ["Offset of field: KvmInfo::present"][::std::mem::offset_of!(KvmInfo, present) - 1usize];
};
unsafe extern "C" {
    pub fn qapi_free_KvmInfo(obj: *mut KvmInfo);
}
pub type KvmInfo_autoptr = *mut KvmInfo;
pub type KvmInfo_listautoptr = *mut GList;
pub type KvmInfo_slistautoptr = *mut GSList;
pub type KvmInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_NumaOptions_base {
    pub type_: NumaOptionsType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_NumaOptions_base"][::std::mem::size_of::<q_obj_NumaOptions_base>() - 4usize];
    ["Alignment of q_obj_NumaOptions_base"]
        [::std::mem::align_of::<q_obj_NumaOptions_base>() - 4usize];
    ["Offset of field: q_obj_NumaOptions_base::type_"]
        [::std::mem::offset_of!(q_obj_NumaOptions_base, type_) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumaNodeOptions {
    pub has_nodeid: bool,
    pub nodeid: u16,
    pub has_cpus: bool,
    pub cpus: *mut uint16List,
    pub has_mem: bool,
    pub mem: u64,
    pub memdev: *mut ::std::os::raw::c_char,
    pub has_initiator: bool,
    pub initiator: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NumaNodeOptions"][::std::mem::size_of::<NumaNodeOptions>() - 48usize];
    ["Alignment of NumaNodeOptions"][::std::mem::align_of::<NumaNodeOptions>() - 8usize];
    ["Offset of field: NumaNodeOptions::has_nodeid"]
        [::std::mem::offset_of!(NumaNodeOptions, has_nodeid) - 0usize];
    ["Offset of field: NumaNodeOptions::nodeid"]
        [::std::mem::offset_of!(NumaNodeOptions, nodeid) - 2usize];
    ["Offset of field: NumaNodeOptions::has_cpus"]
        [::std::mem::offset_of!(NumaNodeOptions, has_cpus) - 4usize];
    ["Offset of field: NumaNodeOptions::cpus"]
        [::std::mem::offset_of!(NumaNodeOptions, cpus) - 8usize];
    ["Offset of field: NumaNodeOptions::has_mem"]
        [::std::mem::offset_of!(NumaNodeOptions, has_mem) - 16usize];
    ["Offset of field: NumaNodeOptions::mem"]
        [::std::mem::offset_of!(NumaNodeOptions, mem) - 24usize];
    ["Offset of field: NumaNodeOptions::memdev"]
        [::std::mem::offset_of!(NumaNodeOptions, memdev) - 32usize];
    ["Offset of field: NumaNodeOptions::has_initiator"]
        [::std::mem::offset_of!(NumaNodeOptions, has_initiator) - 40usize];
    ["Offset of field: NumaNodeOptions::initiator"]
        [::std::mem::offset_of!(NumaNodeOptions, initiator) - 42usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumaDistOptions {
    pub src: u16,
    pub dst: u16,
    pub val: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NumaDistOptions"][::std::mem::size_of::<NumaDistOptions>() - 6usize];
    ["Alignment of NumaDistOptions"][::std::mem::align_of::<NumaDistOptions>() - 2usize];
    ["Offset of field: NumaDistOptions::src"]
        [::std::mem::offset_of!(NumaDistOptions, src) - 0usize];
    ["Offset of field: NumaDistOptions::dst"]
        [::std::mem::offset_of!(NumaDistOptions, dst) - 2usize];
    ["Offset of field: NumaDistOptions::val"]
        [::std::mem::offset_of!(NumaDistOptions, val) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumaCpuOptions {
    pub has_node_id: bool,
    pub node_id: i64,
    pub has_drawer_id: bool,
    pub drawer_id: i64,
    pub has_book_id: bool,
    pub book_id: i64,
    pub has_socket_id: bool,
    pub socket_id: i64,
    pub has_die_id: bool,
    pub die_id: i64,
    pub has_cluster_id: bool,
    pub cluster_id: i64,
    pub has_module_id: bool,
    pub module_id: i64,
    pub has_core_id: bool,
    pub core_id: i64,
    pub has_thread_id: bool,
    pub thread_id: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NumaCpuOptions"][::std::mem::size_of::<NumaCpuOptions>() - 144usize];
    ["Alignment of NumaCpuOptions"][::std::mem::align_of::<NumaCpuOptions>() - 8usize];
    ["Offset of field: NumaCpuOptions::has_node_id"]
        [::std::mem::offset_of!(NumaCpuOptions, has_node_id) - 0usize];
    ["Offset of field: NumaCpuOptions::node_id"]
        [::std::mem::offset_of!(NumaCpuOptions, node_id) - 8usize];
    ["Offset of field: NumaCpuOptions::has_drawer_id"]
        [::std::mem::offset_of!(NumaCpuOptions, has_drawer_id) - 16usize];
    ["Offset of field: NumaCpuOptions::drawer_id"]
        [::std::mem::offset_of!(NumaCpuOptions, drawer_id) - 24usize];
    ["Offset of field: NumaCpuOptions::has_book_id"]
        [::std::mem::offset_of!(NumaCpuOptions, has_book_id) - 32usize];
    ["Offset of field: NumaCpuOptions::book_id"]
        [::std::mem::offset_of!(NumaCpuOptions, book_id) - 40usize];
    ["Offset of field: NumaCpuOptions::has_socket_id"]
        [::std::mem::offset_of!(NumaCpuOptions, has_socket_id) - 48usize];
    ["Offset of field: NumaCpuOptions::socket_id"]
        [::std::mem::offset_of!(NumaCpuOptions, socket_id) - 56usize];
    ["Offset of field: NumaCpuOptions::has_die_id"]
        [::std::mem::offset_of!(NumaCpuOptions, has_die_id) - 64usize];
    ["Offset of field: NumaCpuOptions::die_id"]
        [::std::mem::offset_of!(NumaCpuOptions, die_id) - 72usize];
    ["Offset of field: NumaCpuOptions::has_cluster_id"]
        [::std::mem::offset_of!(NumaCpuOptions, has_cluster_id) - 80usize];
    ["Offset of field: NumaCpuOptions::cluster_id"]
        [::std::mem::offset_of!(NumaCpuOptions, cluster_id) - 88usize];
    ["Offset of field: NumaCpuOptions::has_module_id"]
        [::std::mem::offset_of!(NumaCpuOptions, has_module_id) - 96usize];
    ["Offset of field: NumaCpuOptions::module_id"]
        [::std::mem::offset_of!(NumaCpuOptions, module_id) - 104usize];
    ["Offset of field: NumaCpuOptions::has_core_id"]
        [::std::mem::offset_of!(NumaCpuOptions, has_core_id) - 112usize];
    ["Offset of field: NumaCpuOptions::core_id"]
        [::std::mem::offset_of!(NumaCpuOptions, core_id) - 120usize];
    ["Offset of field: NumaCpuOptions::has_thread_id"]
        [::std::mem::offset_of!(NumaCpuOptions, has_thread_id) - 128usize];
    ["Offset of field: NumaCpuOptions::thread_id"]
        [::std::mem::offset_of!(NumaCpuOptions, thread_id) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumaHmatLBOptions {
    pub initiator: u16,
    pub target: u16,
    pub hierarchy: HmatLBMemoryHierarchy,
    pub data_type: HmatLBDataType,
    pub has_latency: bool,
    pub latency: u64,
    pub has_bandwidth: bool,
    pub bandwidth: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NumaHmatLBOptions"][::std::mem::size_of::<NumaHmatLBOptions>() - 40usize];
    ["Alignment of NumaHmatLBOptions"][::std::mem::align_of::<NumaHmatLBOptions>() - 8usize];
    ["Offset of field: NumaHmatLBOptions::initiator"]
        [::std::mem::offset_of!(NumaHmatLBOptions, initiator) - 0usize];
    ["Offset of field: NumaHmatLBOptions::target"]
        [::std::mem::offset_of!(NumaHmatLBOptions, target) - 2usize];
    ["Offset of field: NumaHmatLBOptions::hierarchy"]
        [::std::mem::offset_of!(NumaHmatLBOptions, hierarchy) - 4usize];
    ["Offset of field: NumaHmatLBOptions::data_type"]
        [::std::mem::offset_of!(NumaHmatLBOptions, data_type) - 8usize];
    ["Offset of field: NumaHmatLBOptions::has_latency"]
        [::std::mem::offset_of!(NumaHmatLBOptions, has_latency) - 12usize];
    ["Offset of field: NumaHmatLBOptions::latency"]
        [::std::mem::offset_of!(NumaHmatLBOptions, latency) - 16usize];
    ["Offset of field: NumaHmatLBOptions::has_bandwidth"]
        [::std::mem::offset_of!(NumaHmatLBOptions, has_bandwidth) - 24usize];
    ["Offset of field: NumaHmatLBOptions::bandwidth"]
        [::std::mem::offset_of!(NumaHmatLBOptions, bandwidth) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumaHmatCacheOptions {
    pub node_id: u32,
    pub size: u64,
    pub level: u8,
    pub associativity: HmatCacheAssociativity,
    pub policy: HmatCacheWritePolicy,
    pub line: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NumaHmatCacheOptions"][::std::mem::size_of::<NumaHmatCacheOptions>() - 32usize];
    ["Alignment of NumaHmatCacheOptions"][::std::mem::align_of::<NumaHmatCacheOptions>() - 8usize];
    ["Offset of field: NumaHmatCacheOptions::node_id"]
        [::std::mem::offset_of!(NumaHmatCacheOptions, node_id) - 0usize];
    ["Offset of field: NumaHmatCacheOptions::size"]
        [::std::mem::offset_of!(NumaHmatCacheOptions, size) - 8usize];
    ["Offset of field: NumaHmatCacheOptions::level"]
        [::std::mem::offset_of!(NumaHmatCacheOptions, level) - 16usize];
    ["Offset of field: NumaHmatCacheOptions::associativity"]
        [::std::mem::offset_of!(NumaHmatCacheOptions, associativity) - 20usize];
    ["Offset of field: NumaHmatCacheOptions::policy"]
        [::std::mem::offset_of!(NumaHmatCacheOptions, policy) - 24usize];
    ["Offset of field: NumaHmatCacheOptions::line"]
        [::std::mem::offset_of!(NumaHmatCacheOptions, line) - 28usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NumaOptions {
    pub type_: NumaOptionsType,
    pub u: NumaOptions__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NumaOptions__bindgen_ty_1 {
    pub node: NumaNodeOptions,
    pub dist: NumaDistOptions,
    pub cpu: NumaCpuOptions,
    pub hmat_lb: NumaHmatLBOptions,
    pub hmat_cache: NumaHmatCacheOptions,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NumaOptions__bindgen_ty_1"]
        [::std::mem::size_of::<NumaOptions__bindgen_ty_1>() - 144usize];
    ["Alignment of NumaOptions__bindgen_ty_1"]
        [::std::mem::align_of::<NumaOptions__bindgen_ty_1>() - 8usize];
    ["Offset of field: NumaOptions__bindgen_ty_1::node"]
        [::std::mem::offset_of!(NumaOptions__bindgen_ty_1, node) - 0usize];
    ["Offset of field: NumaOptions__bindgen_ty_1::dist"]
        [::std::mem::offset_of!(NumaOptions__bindgen_ty_1, dist) - 0usize];
    ["Offset of field: NumaOptions__bindgen_ty_1::cpu"]
        [::std::mem::offset_of!(NumaOptions__bindgen_ty_1, cpu) - 0usize];
    ["Offset of field: NumaOptions__bindgen_ty_1::hmat_lb"]
        [::std::mem::offset_of!(NumaOptions__bindgen_ty_1, hmat_lb) - 0usize];
    ["Offset of field: NumaOptions__bindgen_ty_1::hmat_cache"]
        [::std::mem::offset_of!(NumaOptions__bindgen_ty_1, hmat_cache) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NumaOptions"][::std::mem::size_of::<NumaOptions>() - 152usize];
    ["Alignment of NumaOptions"][::std::mem::align_of::<NumaOptions>() - 8usize];
    ["Offset of field: NumaOptions::type_"][::std::mem::offset_of!(NumaOptions, type_) - 0usize];
    ["Offset of field: NumaOptions::u"][::std::mem::offset_of!(NumaOptions, u) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_NumaOptions(obj: *mut NumaOptions);
}
pub type NumaOptions_autoptr = *mut NumaOptions;
pub type NumaOptions_listautoptr = *mut GList;
pub type NumaOptions_slistautoptr = *mut GSList;
pub type NumaOptions_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn qapi_free_NumaNodeOptions(obj: *mut NumaNodeOptions);
}
pub type NumaNodeOptions_autoptr = *mut NumaNodeOptions;
pub type NumaNodeOptions_listautoptr = *mut GList;
pub type NumaNodeOptions_slistautoptr = *mut GSList;
pub type NumaNodeOptions_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn qapi_free_NumaDistOptions(obj: *mut NumaDistOptions);
}
pub type NumaDistOptions_autoptr = *mut NumaDistOptions;
pub type NumaDistOptions_listautoptr = *mut GList;
pub type NumaDistOptions_slistautoptr = *mut GSList;
pub type NumaDistOptions_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXLFixedMemoryWindowOptions {
    pub size: u64,
    pub has_interleave_granularity: bool,
    pub interleave_granularity: u64,
    pub targets: *mut strList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CXLFixedMemoryWindowOptions"]
        [::std::mem::size_of::<CXLFixedMemoryWindowOptions>() - 32usize];
    ["Alignment of CXLFixedMemoryWindowOptions"]
        [::std::mem::align_of::<CXLFixedMemoryWindowOptions>() - 8usize];
    ["Offset of field: CXLFixedMemoryWindowOptions::size"]
        [::std::mem::offset_of!(CXLFixedMemoryWindowOptions, size) - 0usize];
    ["Offset of field: CXLFixedMemoryWindowOptions::has_interleave_granularity"]
        [::std::mem::offset_of!(CXLFixedMemoryWindowOptions, has_interleave_granularity) - 8usize];
    ["Offset of field: CXLFixedMemoryWindowOptions::interleave_granularity"]
        [::std::mem::offset_of!(CXLFixedMemoryWindowOptions, interleave_granularity) - 16usize];
    ["Offset of field: CXLFixedMemoryWindowOptions::targets"]
        [::std::mem::offset_of!(CXLFixedMemoryWindowOptions, targets) - 24usize];
};
unsafe extern "C" {
    pub fn qapi_free_CXLFixedMemoryWindowOptions(obj: *mut CXLFixedMemoryWindowOptions);
}
pub type CXLFixedMemoryWindowOptions_autoptr = *mut CXLFixedMemoryWindowOptions;
pub type CXLFixedMemoryWindowOptions_listautoptr = *mut GList;
pub type CXLFixedMemoryWindowOptions_slistautoptr = *mut GSList;
pub type CXLFixedMemoryWindowOptions_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXLFixedMemoryWindowOptionsList {
    pub next: *mut CXLFixedMemoryWindowOptionsList,
    pub value: *mut CXLFixedMemoryWindowOptions,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CXLFixedMemoryWindowOptionsList"]
        [::std::mem::size_of::<CXLFixedMemoryWindowOptionsList>() - 16usize];
    ["Alignment of CXLFixedMemoryWindowOptionsList"]
        [::std::mem::align_of::<CXLFixedMemoryWindowOptionsList>() - 8usize];
    ["Offset of field: CXLFixedMemoryWindowOptionsList::next"]
        [::std::mem::offset_of!(CXLFixedMemoryWindowOptionsList, next) - 0usize];
    ["Offset of field: CXLFixedMemoryWindowOptionsList::value"]
        [::std::mem::offset_of!(CXLFixedMemoryWindowOptionsList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_CXLFixedMemoryWindowOptionsList(obj: *mut CXLFixedMemoryWindowOptionsList);
}
pub type CXLFixedMemoryWindowOptionsList_autoptr = *mut CXLFixedMemoryWindowOptionsList;
pub type CXLFixedMemoryWindowOptionsList_listautoptr = *mut GList;
pub type CXLFixedMemoryWindowOptionsList_slistautoptr = *mut GSList;
pub type CXLFixedMemoryWindowOptionsList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXLFMWProperties {
    pub cxl_fmw: *mut CXLFixedMemoryWindowOptionsList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CXLFMWProperties"][::std::mem::size_of::<CXLFMWProperties>() - 8usize];
    ["Alignment of CXLFMWProperties"][::std::mem::align_of::<CXLFMWProperties>() - 8usize];
    ["Offset of field: CXLFMWProperties::cxl_fmw"]
        [::std::mem::offset_of!(CXLFMWProperties, cxl_fmw) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_CXLFMWProperties(obj: *mut CXLFMWProperties);
}
pub type CXLFMWProperties_autoptr = *mut CXLFMWProperties;
pub type CXLFMWProperties_listautoptr = *mut GList;
pub type CXLFMWProperties_slistautoptr = *mut GSList;
pub type CXLFMWProperties_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X86CPUFeatureWordInfo {
    pub cpuid_input_eax: i64,
    pub has_cpuid_input_ecx: bool,
    pub cpuid_input_ecx: i64,
    pub cpuid_register: X86CPURegister32,
    pub features: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of X86CPUFeatureWordInfo"][::std::mem::size_of::<X86CPUFeatureWordInfo>() - 40usize];
    ["Alignment of X86CPUFeatureWordInfo"]
        [::std::mem::align_of::<X86CPUFeatureWordInfo>() - 8usize];
    ["Offset of field: X86CPUFeatureWordInfo::cpuid_input_eax"]
        [::std::mem::offset_of!(X86CPUFeatureWordInfo, cpuid_input_eax) - 0usize];
    ["Offset of field: X86CPUFeatureWordInfo::has_cpuid_input_ecx"]
        [::std::mem::offset_of!(X86CPUFeatureWordInfo, has_cpuid_input_ecx) - 8usize];
    ["Offset of field: X86CPUFeatureWordInfo::cpuid_input_ecx"]
        [::std::mem::offset_of!(X86CPUFeatureWordInfo, cpuid_input_ecx) - 16usize];
    ["Offset of field: X86CPUFeatureWordInfo::cpuid_register"]
        [::std::mem::offset_of!(X86CPUFeatureWordInfo, cpuid_register) - 24usize];
    ["Offset of field: X86CPUFeatureWordInfo::features"]
        [::std::mem::offset_of!(X86CPUFeatureWordInfo, features) - 32usize];
};
unsafe extern "C" {
    pub fn qapi_free_X86CPUFeatureWordInfo(obj: *mut X86CPUFeatureWordInfo);
}
pub type X86CPUFeatureWordInfo_autoptr = *mut X86CPUFeatureWordInfo;
pub type X86CPUFeatureWordInfo_listautoptr = *mut GList;
pub type X86CPUFeatureWordInfo_slistautoptr = *mut GSList;
pub type X86CPUFeatureWordInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X86CPUFeatureWordInfoList {
    pub next: *mut X86CPUFeatureWordInfoList,
    pub value: *mut X86CPUFeatureWordInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of X86CPUFeatureWordInfoList"]
        [::std::mem::size_of::<X86CPUFeatureWordInfoList>() - 16usize];
    ["Alignment of X86CPUFeatureWordInfoList"]
        [::std::mem::align_of::<X86CPUFeatureWordInfoList>() - 8usize];
    ["Offset of field: X86CPUFeatureWordInfoList::next"]
        [::std::mem::offset_of!(X86CPUFeatureWordInfoList, next) - 0usize];
    ["Offset of field: X86CPUFeatureWordInfoList::value"]
        [::std::mem::offset_of!(X86CPUFeatureWordInfoList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_X86CPUFeatureWordInfoList(obj: *mut X86CPUFeatureWordInfoList);
}
pub type X86CPUFeatureWordInfoList_autoptr = *mut X86CPUFeatureWordInfoList;
pub type X86CPUFeatureWordInfoList_listautoptr = *mut GList;
pub type X86CPUFeatureWordInfoList_slistautoptr = *mut GSList;
pub type X86CPUFeatureWordInfoList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DummyForceArrays {
    pub unused: *mut X86CPUFeatureWordInfoList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DummyForceArrays"][::std::mem::size_of::<DummyForceArrays>() - 8usize];
    ["Alignment of DummyForceArrays"][::std::mem::align_of::<DummyForceArrays>() - 8usize];
    ["Offset of field: DummyForceArrays::unused"]
        [::std::mem::offset_of!(DummyForceArrays, unused) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_DummyForceArrays(obj: *mut DummyForceArrays);
}
pub type DummyForceArrays_autoptr = *mut DummyForceArrays;
pub type DummyForceArrays_listautoptr = *mut GList;
pub type DummyForceArrays_slistautoptr = *mut GSList;
pub type DummyForceArrays_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn qapi_free_NumaCpuOptions(obj: *mut NumaCpuOptions);
}
pub type NumaCpuOptions_autoptr = *mut NumaCpuOptions;
pub type NumaCpuOptions_listautoptr = *mut GList;
pub type NumaCpuOptions_slistautoptr = *mut GSList;
pub type NumaCpuOptions_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn qapi_free_NumaHmatLBOptions(obj: *mut NumaHmatLBOptions);
}
pub type NumaHmatLBOptions_autoptr = *mut NumaHmatLBOptions;
pub type NumaHmatLBOptions_listautoptr = *mut GList;
pub type NumaHmatLBOptions_slistautoptr = *mut GSList;
pub type NumaHmatLBOptions_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn qapi_free_NumaHmatCacheOptions(obj: *mut NumaHmatCacheOptions);
}
pub type NumaHmatCacheOptions_autoptr = *mut NumaHmatCacheOptions;
pub type NumaHmatCacheOptions_listautoptr = *mut GList;
pub type NumaHmatCacheOptions_slistautoptr = *mut GSList;
pub type NumaHmatCacheOptions_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_memsave_arg {
    pub val: u64,
    pub size: u64,
    pub filename: *mut ::std::os::raw::c_char,
    pub has_cpu_index: bool,
    pub cpu_index: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_memsave_arg"][::std::mem::size_of::<q_obj_memsave_arg>() - 40usize];
    ["Alignment of q_obj_memsave_arg"][::std::mem::align_of::<q_obj_memsave_arg>() - 8usize];
    ["Offset of field: q_obj_memsave_arg::val"]
        [::std::mem::offset_of!(q_obj_memsave_arg, val) - 0usize];
    ["Offset of field: q_obj_memsave_arg::size"]
        [::std::mem::offset_of!(q_obj_memsave_arg, size) - 8usize];
    ["Offset of field: q_obj_memsave_arg::filename"]
        [::std::mem::offset_of!(q_obj_memsave_arg, filename) - 16usize];
    ["Offset of field: q_obj_memsave_arg::has_cpu_index"]
        [::std::mem::offset_of!(q_obj_memsave_arg, has_cpu_index) - 24usize];
    ["Offset of field: q_obj_memsave_arg::cpu_index"]
        [::std::mem::offset_of!(q_obj_memsave_arg, cpu_index) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_pmemsave_arg {
    pub val: u64,
    pub size: u64,
    pub filename: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_pmemsave_arg"][::std::mem::size_of::<q_obj_pmemsave_arg>() - 24usize];
    ["Alignment of q_obj_pmemsave_arg"][::std::mem::align_of::<q_obj_pmemsave_arg>() - 8usize];
    ["Offset of field: q_obj_pmemsave_arg::val"]
        [::std::mem::offset_of!(q_obj_pmemsave_arg, val) - 0usize];
    ["Offset of field: q_obj_pmemsave_arg::size"]
        [::std::mem::offset_of!(q_obj_pmemsave_arg, size) - 8usize];
    ["Offset of field: q_obj_pmemsave_arg::filename"]
        [::std::mem::offset_of!(q_obj_pmemsave_arg, filename) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Memdev {
    pub id: *mut ::std::os::raw::c_char,
    pub size: u64,
    pub merge: bool,
    pub dump: bool,
    pub prealloc: bool,
    pub share: bool,
    pub has_reserve: bool,
    pub reserve: bool,
    pub host_nodes: *mut uint16List,
    pub policy: HostMemPolicy,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Memdev"][::std::mem::size_of::<Memdev>() - 40usize];
    ["Alignment of Memdev"][::std::mem::align_of::<Memdev>() - 8usize];
    ["Offset of field: Memdev::id"][::std::mem::offset_of!(Memdev, id) - 0usize];
    ["Offset of field: Memdev::size"][::std::mem::offset_of!(Memdev, size) - 8usize];
    ["Offset of field: Memdev::merge"][::std::mem::offset_of!(Memdev, merge) - 16usize];
    ["Offset of field: Memdev::dump"][::std::mem::offset_of!(Memdev, dump) - 17usize];
    ["Offset of field: Memdev::prealloc"][::std::mem::offset_of!(Memdev, prealloc) - 18usize];
    ["Offset of field: Memdev::share"][::std::mem::offset_of!(Memdev, share) - 19usize];
    ["Offset of field: Memdev::has_reserve"][::std::mem::offset_of!(Memdev, has_reserve) - 20usize];
    ["Offset of field: Memdev::reserve"][::std::mem::offset_of!(Memdev, reserve) - 21usize];
    ["Offset of field: Memdev::host_nodes"][::std::mem::offset_of!(Memdev, host_nodes) - 24usize];
    ["Offset of field: Memdev::policy"][::std::mem::offset_of!(Memdev, policy) - 32usize];
};
unsafe extern "C" {
    pub fn qapi_free_Memdev(obj: *mut Memdev);
}
pub type Memdev_autoptr = *mut Memdev;
pub type Memdev_listautoptr = *mut GList;
pub type Memdev_slistautoptr = *mut GSList;
pub type Memdev_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemdevList {
    pub next: *mut MemdevList,
    pub value: *mut Memdev,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemdevList"][::std::mem::size_of::<MemdevList>() - 16usize];
    ["Alignment of MemdevList"][::std::mem::align_of::<MemdevList>() - 8usize];
    ["Offset of field: MemdevList::next"][::std::mem::offset_of!(MemdevList, next) - 0usize];
    ["Offset of field: MemdevList::value"][::std::mem::offset_of!(MemdevList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_MemdevList(obj: *mut MemdevList);
}
pub type MemdevList_autoptr = *mut MemdevList;
pub type MemdevList_listautoptr = *mut GList;
pub type MemdevList_slistautoptr = *mut GSList;
pub type MemdevList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CpuInstanceProperties {
    pub has_node_id: bool,
    pub node_id: i64,
    pub has_drawer_id: bool,
    pub drawer_id: i64,
    pub has_book_id: bool,
    pub book_id: i64,
    pub has_socket_id: bool,
    pub socket_id: i64,
    pub has_die_id: bool,
    pub die_id: i64,
    pub has_cluster_id: bool,
    pub cluster_id: i64,
    pub has_module_id: bool,
    pub module_id: i64,
    pub has_core_id: bool,
    pub core_id: i64,
    pub has_thread_id: bool,
    pub thread_id: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CpuInstanceProperties"][::std::mem::size_of::<CpuInstanceProperties>() - 144usize];
    ["Alignment of CpuInstanceProperties"]
        [::std::mem::align_of::<CpuInstanceProperties>() - 8usize];
    ["Offset of field: CpuInstanceProperties::has_node_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, has_node_id) - 0usize];
    ["Offset of field: CpuInstanceProperties::node_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, node_id) - 8usize];
    ["Offset of field: CpuInstanceProperties::has_drawer_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, has_drawer_id) - 16usize];
    ["Offset of field: CpuInstanceProperties::drawer_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, drawer_id) - 24usize];
    ["Offset of field: CpuInstanceProperties::has_book_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, has_book_id) - 32usize];
    ["Offset of field: CpuInstanceProperties::book_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, book_id) - 40usize];
    ["Offset of field: CpuInstanceProperties::has_socket_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, has_socket_id) - 48usize];
    ["Offset of field: CpuInstanceProperties::socket_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, socket_id) - 56usize];
    ["Offset of field: CpuInstanceProperties::has_die_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, has_die_id) - 64usize];
    ["Offset of field: CpuInstanceProperties::die_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, die_id) - 72usize];
    ["Offset of field: CpuInstanceProperties::has_cluster_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, has_cluster_id) - 80usize];
    ["Offset of field: CpuInstanceProperties::cluster_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, cluster_id) - 88usize];
    ["Offset of field: CpuInstanceProperties::has_module_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, has_module_id) - 96usize];
    ["Offset of field: CpuInstanceProperties::module_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, module_id) - 104usize];
    ["Offset of field: CpuInstanceProperties::has_core_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, has_core_id) - 112usize];
    ["Offset of field: CpuInstanceProperties::core_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, core_id) - 120usize];
    ["Offset of field: CpuInstanceProperties::has_thread_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, has_thread_id) - 128usize];
    ["Offset of field: CpuInstanceProperties::thread_id"]
        [::std::mem::offset_of!(CpuInstanceProperties, thread_id) - 136usize];
};
unsafe extern "C" {
    pub fn qapi_free_CpuInstanceProperties(obj: *mut CpuInstanceProperties);
}
pub type CpuInstanceProperties_autoptr = *mut CpuInstanceProperties;
pub type CpuInstanceProperties_listautoptr = *mut GList;
pub type CpuInstanceProperties_slistautoptr = *mut GSList;
pub type CpuInstanceProperties_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HotpluggableCPU {
    pub type_: *mut ::std::os::raw::c_char,
    pub vcpus_count: i64,
    pub props: *mut CpuInstanceProperties,
    pub qom_path: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HotpluggableCPU"][::std::mem::size_of::<HotpluggableCPU>() - 32usize];
    ["Alignment of HotpluggableCPU"][::std::mem::align_of::<HotpluggableCPU>() - 8usize];
    ["Offset of field: HotpluggableCPU::type_"]
        [::std::mem::offset_of!(HotpluggableCPU, type_) - 0usize];
    ["Offset of field: HotpluggableCPU::vcpus_count"]
        [::std::mem::offset_of!(HotpluggableCPU, vcpus_count) - 8usize];
    ["Offset of field: HotpluggableCPU::props"]
        [::std::mem::offset_of!(HotpluggableCPU, props) - 16usize];
    ["Offset of field: HotpluggableCPU::qom_path"]
        [::std::mem::offset_of!(HotpluggableCPU, qom_path) - 24usize];
};
unsafe extern "C" {
    pub fn qapi_free_HotpluggableCPU(obj: *mut HotpluggableCPU);
}
pub type HotpluggableCPU_autoptr = *mut HotpluggableCPU;
pub type HotpluggableCPU_listautoptr = *mut GList;
pub type HotpluggableCPU_slistautoptr = *mut GSList;
pub type HotpluggableCPU_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HotpluggableCPUList {
    pub next: *mut HotpluggableCPUList,
    pub value: *mut HotpluggableCPU,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HotpluggableCPUList"][::std::mem::size_of::<HotpluggableCPUList>() - 16usize];
    ["Alignment of HotpluggableCPUList"][::std::mem::align_of::<HotpluggableCPUList>() - 8usize];
    ["Offset of field: HotpluggableCPUList::next"]
        [::std::mem::offset_of!(HotpluggableCPUList, next) - 0usize];
    ["Offset of field: HotpluggableCPUList::value"]
        [::std::mem::offset_of!(HotpluggableCPUList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_HotpluggableCPUList(obj: *mut HotpluggableCPUList);
}
pub type HotpluggableCPUList_autoptr = *mut HotpluggableCPUList;
pub type HotpluggableCPUList_listautoptr = *mut GList;
pub type HotpluggableCPUList_slistautoptr = *mut GSList;
pub type HotpluggableCPUList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_balloon_arg {
    pub value: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_balloon_arg"][::std::mem::size_of::<q_obj_balloon_arg>() - 8usize];
    ["Alignment of q_obj_balloon_arg"][::std::mem::align_of::<q_obj_balloon_arg>() - 8usize];
    ["Offset of field: q_obj_balloon_arg::value"]
        [::std::mem::offset_of!(q_obj_balloon_arg, value) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BalloonInfo {
    pub actual: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BalloonInfo"][::std::mem::size_of::<BalloonInfo>() - 8usize];
    ["Alignment of BalloonInfo"][::std::mem::align_of::<BalloonInfo>() - 8usize];
    ["Offset of field: BalloonInfo::actual"][::std::mem::offset_of!(BalloonInfo, actual) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_BalloonInfo(obj: *mut BalloonInfo);
}
pub type BalloonInfo_autoptr = *mut BalloonInfo;
pub type BalloonInfo_listautoptr = *mut GList;
pub type BalloonInfo_slistautoptr = *mut GSList;
pub type BalloonInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_BALLOON_CHANGE_arg {
    pub actual: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_BALLOON_CHANGE_arg"]
        [::std::mem::size_of::<q_obj_BALLOON_CHANGE_arg>() - 8usize];
    ["Alignment of q_obj_BALLOON_CHANGE_arg"]
        [::std::mem::align_of::<q_obj_BALLOON_CHANGE_arg>() - 8usize];
    ["Offset of field: q_obj_BALLOON_CHANGE_arg::actual"]
        [::std::mem::offset_of!(q_obj_BALLOON_CHANGE_arg, actual) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HvBalloonInfo {
    pub committed: u64,
    pub available: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HvBalloonInfo"][::std::mem::size_of::<HvBalloonInfo>() - 16usize];
    ["Alignment of HvBalloonInfo"][::std::mem::align_of::<HvBalloonInfo>() - 8usize];
    ["Offset of field: HvBalloonInfo::committed"]
        [::std::mem::offset_of!(HvBalloonInfo, committed) - 0usize];
    ["Offset of field: HvBalloonInfo::available"]
        [::std::mem::offset_of!(HvBalloonInfo, available) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_HvBalloonInfo(obj: *mut HvBalloonInfo);
}
pub type HvBalloonInfo_autoptr = *mut HvBalloonInfo;
pub type HvBalloonInfo_listautoptr = *mut GList;
pub type HvBalloonInfo_slistautoptr = *mut GSList;
pub type HvBalloonInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryInfo {
    pub base_memory: u64,
    pub has_plugged_memory: bool,
    pub plugged_memory: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryInfo"][::std::mem::size_of::<MemoryInfo>() - 24usize];
    ["Alignment of MemoryInfo"][::std::mem::align_of::<MemoryInfo>() - 8usize];
    ["Offset of field: MemoryInfo::base_memory"]
        [::std::mem::offset_of!(MemoryInfo, base_memory) - 0usize];
    ["Offset of field: MemoryInfo::has_plugged_memory"]
        [::std::mem::offset_of!(MemoryInfo, has_plugged_memory) - 8usize];
    ["Offset of field: MemoryInfo::plugged_memory"]
        [::std::mem::offset_of!(MemoryInfo, plugged_memory) - 16usize];
};
unsafe extern "C" {
    pub fn qapi_free_MemoryInfo(obj: *mut MemoryInfo);
}
pub type MemoryInfo_autoptr = *mut MemoryInfo;
pub type MemoryInfo_listautoptr = *mut GList;
pub type MemoryInfo_slistautoptr = *mut GSList;
pub type MemoryInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCDIMMDeviceInfo {
    pub id: *mut ::std::os::raw::c_char,
    pub addr: i64,
    pub size: i64,
    pub slot: i64,
    pub node: i64,
    pub memdev: *mut ::std::os::raw::c_char,
    pub hotplugged: bool,
    pub hotpluggable: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PCDIMMDeviceInfo"][::std::mem::size_of::<PCDIMMDeviceInfo>() - 56usize];
    ["Alignment of PCDIMMDeviceInfo"][::std::mem::align_of::<PCDIMMDeviceInfo>() - 8usize];
    ["Offset of field: PCDIMMDeviceInfo::id"]
        [::std::mem::offset_of!(PCDIMMDeviceInfo, id) - 0usize];
    ["Offset of field: PCDIMMDeviceInfo::addr"]
        [::std::mem::offset_of!(PCDIMMDeviceInfo, addr) - 8usize];
    ["Offset of field: PCDIMMDeviceInfo::size"]
        [::std::mem::offset_of!(PCDIMMDeviceInfo, size) - 16usize];
    ["Offset of field: PCDIMMDeviceInfo::slot"]
        [::std::mem::offset_of!(PCDIMMDeviceInfo, slot) - 24usize];
    ["Offset of field: PCDIMMDeviceInfo::node"]
        [::std::mem::offset_of!(PCDIMMDeviceInfo, node) - 32usize];
    ["Offset of field: PCDIMMDeviceInfo::memdev"]
        [::std::mem::offset_of!(PCDIMMDeviceInfo, memdev) - 40usize];
    ["Offset of field: PCDIMMDeviceInfo::hotplugged"]
        [::std::mem::offset_of!(PCDIMMDeviceInfo, hotplugged) - 48usize];
    ["Offset of field: PCDIMMDeviceInfo::hotpluggable"]
        [::std::mem::offset_of!(PCDIMMDeviceInfo, hotpluggable) - 49usize];
};
unsafe extern "C" {
    pub fn qapi_free_PCDIMMDeviceInfo(obj: *mut PCDIMMDeviceInfo);
}
pub type PCDIMMDeviceInfo_autoptr = *mut PCDIMMDeviceInfo;
pub type PCDIMMDeviceInfo_listautoptr = *mut GList;
pub type PCDIMMDeviceInfo_slistautoptr = *mut GSList;
pub type PCDIMMDeviceInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtioPMEMDeviceInfo {
    pub id: *mut ::std::os::raw::c_char,
    pub memaddr: u64,
    pub size: u64,
    pub memdev: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of VirtioPMEMDeviceInfo"][::std::mem::size_of::<VirtioPMEMDeviceInfo>() - 32usize];
    ["Alignment of VirtioPMEMDeviceInfo"][::std::mem::align_of::<VirtioPMEMDeviceInfo>() - 8usize];
    ["Offset of field: VirtioPMEMDeviceInfo::id"]
        [::std::mem::offset_of!(VirtioPMEMDeviceInfo, id) - 0usize];
    ["Offset of field: VirtioPMEMDeviceInfo::memaddr"]
        [::std::mem::offset_of!(VirtioPMEMDeviceInfo, memaddr) - 8usize];
    ["Offset of field: VirtioPMEMDeviceInfo::size"]
        [::std::mem::offset_of!(VirtioPMEMDeviceInfo, size) - 16usize];
    ["Offset of field: VirtioPMEMDeviceInfo::memdev"]
        [::std::mem::offset_of!(VirtioPMEMDeviceInfo, memdev) - 24usize];
};
unsafe extern "C" {
    pub fn qapi_free_VirtioPMEMDeviceInfo(obj: *mut VirtioPMEMDeviceInfo);
}
pub type VirtioPMEMDeviceInfo_autoptr = *mut VirtioPMEMDeviceInfo;
pub type VirtioPMEMDeviceInfo_listautoptr = *mut GList;
pub type VirtioPMEMDeviceInfo_slistautoptr = *mut GSList;
pub type VirtioPMEMDeviceInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtioMEMDeviceInfo {
    pub id: *mut ::std::os::raw::c_char,
    pub memaddr: u64,
    pub requested_size: u64,
    pub size: u64,
    pub max_size: u64,
    pub block_size: u64,
    pub node: i64,
    pub memdev: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of VirtioMEMDeviceInfo"][::std::mem::size_of::<VirtioMEMDeviceInfo>() - 64usize];
    ["Alignment of VirtioMEMDeviceInfo"][::std::mem::align_of::<VirtioMEMDeviceInfo>() - 8usize];
    ["Offset of field: VirtioMEMDeviceInfo::id"]
        [::std::mem::offset_of!(VirtioMEMDeviceInfo, id) - 0usize];
    ["Offset of field: VirtioMEMDeviceInfo::memaddr"]
        [::std::mem::offset_of!(VirtioMEMDeviceInfo, memaddr) - 8usize];
    ["Offset of field: VirtioMEMDeviceInfo::requested_size"]
        [::std::mem::offset_of!(VirtioMEMDeviceInfo, requested_size) - 16usize];
    ["Offset of field: VirtioMEMDeviceInfo::size"]
        [::std::mem::offset_of!(VirtioMEMDeviceInfo, size) - 24usize];
    ["Offset of field: VirtioMEMDeviceInfo::max_size"]
        [::std::mem::offset_of!(VirtioMEMDeviceInfo, max_size) - 32usize];
    ["Offset of field: VirtioMEMDeviceInfo::block_size"]
        [::std::mem::offset_of!(VirtioMEMDeviceInfo, block_size) - 40usize];
    ["Offset of field: VirtioMEMDeviceInfo::node"]
        [::std::mem::offset_of!(VirtioMEMDeviceInfo, node) - 48usize];
    ["Offset of field: VirtioMEMDeviceInfo::memdev"]
        [::std::mem::offset_of!(VirtioMEMDeviceInfo, memdev) - 56usize];
};
unsafe extern "C" {
    pub fn qapi_free_VirtioMEMDeviceInfo(obj: *mut VirtioMEMDeviceInfo);
}
pub type VirtioMEMDeviceInfo_autoptr = *mut VirtioMEMDeviceInfo;
pub type VirtioMEMDeviceInfo_listautoptr = *mut GList;
pub type VirtioMEMDeviceInfo_slistautoptr = *mut GSList;
pub type VirtioMEMDeviceInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SgxEPCDeviceInfo {
    pub id: *mut ::std::os::raw::c_char,
    pub memaddr: u64,
    pub size: u64,
    pub node: i64,
    pub memdev: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SgxEPCDeviceInfo"][::std::mem::size_of::<SgxEPCDeviceInfo>() - 40usize];
    ["Alignment of SgxEPCDeviceInfo"][::std::mem::align_of::<SgxEPCDeviceInfo>() - 8usize];
    ["Offset of field: SgxEPCDeviceInfo::id"]
        [::std::mem::offset_of!(SgxEPCDeviceInfo, id) - 0usize];
    ["Offset of field: SgxEPCDeviceInfo::memaddr"]
        [::std::mem::offset_of!(SgxEPCDeviceInfo, memaddr) - 8usize];
    ["Offset of field: SgxEPCDeviceInfo::size"]
        [::std::mem::offset_of!(SgxEPCDeviceInfo, size) - 16usize];
    ["Offset of field: SgxEPCDeviceInfo::node"]
        [::std::mem::offset_of!(SgxEPCDeviceInfo, node) - 24usize];
    ["Offset of field: SgxEPCDeviceInfo::memdev"]
        [::std::mem::offset_of!(SgxEPCDeviceInfo, memdev) - 32usize];
};
unsafe extern "C" {
    pub fn qapi_free_SgxEPCDeviceInfo(obj: *mut SgxEPCDeviceInfo);
}
pub type SgxEPCDeviceInfo_autoptr = *mut SgxEPCDeviceInfo;
pub type SgxEPCDeviceInfo_listautoptr = *mut GList;
pub type SgxEPCDeviceInfo_slistautoptr = *mut GSList;
pub type SgxEPCDeviceInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HvBalloonDeviceInfo {
    pub id: *mut ::std::os::raw::c_char,
    pub has_memaddr: bool,
    pub memaddr: u64,
    pub max_size: u64,
    pub memdev: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HvBalloonDeviceInfo"][::std::mem::size_of::<HvBalloonDeviceInfo>() - 40usize];
    ["Alignment of HvBalloonDeviceInfo"][::std::mem::align_of::<HvBalloonDeviceInfo>() - 8usize];
    ["Offset of field: HvBalloonDeviceInfo::id"]
        [::std::mem::offset_of!(HvBalloonDeviceInfo, id) - 0usize];
    ["Offset of field: HvBalloonDeviceInfo::has_memaddr"]
        [::std::mem::offset_of!(HvBalloonDeviceInfo, has_memaddr) - 8usize];
    ["Offset of field: HvBalloonDeviceInfo::memaddr"]
        [::std::mem::offset_of!(HvBalloonDeviceInfo, memaddr) - 16usize];
    ["Offset of field: HvBalloonDeviceInfo::max_size"]
        [::std::mem::offset_of!(HvBalloonDeviceInfo, max_size) - 24usize];
    ["Offset of field: HvBalloonDeviceInfo::memdev"]
        [::std::mem::offset_of!(HvBalloonDeviceInfo, memdev) - 32usize];
};
unsafe extern "C" {
    pub fn qapi_free_HvBalloonDeviceInfo(obj: *mut HvBalloonDeviceInfo);
}
pub type HvBalloonDeviceInfo_autoptr = *mut HvBalloonDeviceInfo;
pub type HvBalloonDeviceInfo_listautoptr = *mut GList;
pub type HvBalloonDeviceInfo_slistautoptr = *mut GSList;
pub type HvBalloonDeviceInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCDIMMDeviceInfoWrapper {
    pub data: *mut PCDIMMDeviceInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PCDIMMDeviceInfoWrapper"][::std::mem::size_of::<PCDIMMDeviceInfoWrapper>() - 8usize];
    ["Alignment of PCDIMMDeviceInfoWrapper"]
        [::std::mem::align_of::<PCDIMMDeviceInfoWrapper>() - 8usize];
    ["Offset of field: PCDIMMDeviceInfoWrapper::data"]
        [::std::mem::offset_of!(PCDIMMDeviceInfoWrapper, data) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_PCDIMMDeviceInfoWrapper(obj: *mut PCDIMMDeviceInfoWrapper);
}
pub type PCDIMMDeviceInfoWrapper_autoptr = *mut PCDIMMDeviceInfoWrapper;
pub type PCDIMMDeviceInfoWrapper_listautoptr = *mut GList;
pub type PCDIMMDeviceInfoWrapper_slistautoptr = *mut GSList;
pub type PCDIMMDeviceInfoWrapper_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtioPMEMDeviceInfoWrapper {
    pub data: *mut VirtioPMEMDeviceInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of VirtioPMEMDeviceInfoWrapper"]
        [::std::mem::size_of::<VirtioPMEMDeviceInfoWrapper>() - 8usize];
    ["Alignment of VirtioPMEMDeviceInfoWrapper"]
        [::std::mem::align_of::<VirtioPMEMDeviceInfoWrapper>() - 8usize];
    ["Offset of field: VirtioPMEMDeviceInfoWrapper::data"]
        [::std::mem::offset_of!(VirtioPMEMDeviceInfoWrapper, data) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_VirtioPMEMDeviceInfoWrapper(obj: *mut VirtioPMEMDeviceInfoWrapper);
}
pub type VirtioPMEMDeviceInfoWrapper_autoptr = *mut VirtioPMEMDeviceInfoWrapper;
pub type VirtioPMEMDeviceInfoWrapper_listautoptr = *mut GList;
pub type VirtioPMEMDeviceInfoWrapper_slistautoptr = *mut GSList;
pub type VirtioPMEMDeviceInfoWrapper_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtioMEMDeviceInfoWrapper {
    pub data: *mut VirtioMEMDeviceInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of VirtioMEMDeviceInfoWrapper"]
        [::std::mem::size_of::<VirtioMEMDeviceInfoWrapper>() - 8usize];
    ["Alignment of VirtioMEMDeviceInfoWrapper"]
        [::std::mem::align_of::<VirtioMEMDeviceInfoWrapper>() - 8usize];
    ["Offset of field: VirtioMEMDeviceInfoWrapper::data"]
        [::std::mem::offset_of!(VirtioMEMDeviceInfoWrapper, data) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_VirtioMEMDeviceInfoWrapper(obj: *mut VirtioMEMDeviceInfoWrapper);
}
pub type VirtioMEMDeviceInfoWrapper_autoptr = *mut VirtioMEMDeviceInfoWrapper;
pub type VirtioMEMDeviceInfoWrapper_listautoptr = *mut GList;
pub type VirtioMEMDeviceInfoWrapper_slistautoptr = *mut GSList;
pub type VirtioMEMDeviceInfoWrapper_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SgxEPCDeviceInfoWrapper {
    pub data: *mut SgxEPCDeviceInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SgxEPCDeviceInfoWrapper"][::std::mem::size_of::<SgxEPCDeviceInfoWrapper>() - 8usize];
    ["Alignment of SgxEPCDeviceInfoWrapper"]
        [::std::mem::align_of::<SgxEPCDeviceInfoWrapper>() - 8usize];
    ["Offset of field: SgxEPCDeviceInfoWrapper::data"]
        [::std::mem::offset_of!(SgxEPCDeviceInfoWrapper, data) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_SgxEPCDeviceInfoWrapper(obj: *mut SgxEPCDeviceInfoWrapper);
}
pub type SgxEPCDeviceInfoWrapper_autoptr = *mut SgxEPCDeviceInfoWrapper;
pub type SgxEPCDeviceInfoWrapper_listautoptr = *mut GList;
pub type SgxEPCDeviceInfoWrapper_slistautoptr = *mut GSList;
pub type SgxEPCDeviceInfoWrapper_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HvBalloonDeviceInfoWrapper {
    pub data: *mut HvBalloonDeviceInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HvBalloonDeviceInfoWrapper"]
        [::std::mem::size_of::<HvBalloonDeviceInfoWrapper>() - 8usize];
    ["Alignment of HvBalloonDeviceInfoWrapper"]
        [::std::mem::align_of::<HvBalloonDeviceInfoWrapper>() - 8usize];
    ["Offset of field: HvBalloonDeviceInfoWrapper::data"]
        [::std::mem::offset_of!(HvBalloonDeviceInfoWrapper, data) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_HvBalloonDeviceInfoWrapper(obj: *mut HvBalloonDeviceInfoWrapper);
}
pub type HvBalloonDeviceInfoWrapper_autoptr = *mut HvBalloonDeviceInfoWrapper;
pub type HvBalloonDeviceInfoWrapper_listautoptr = *mut GList;
pub type HvBalloonDeviceInfoWrapper_slistautoptr = *mut GSList;
pub type HvBalloonDeviceInfoWrapper_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_MemoryDeviceInfo_base {
    pub type_: MemoryDeviceInfoKind,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_MemoryDeviceInfo_base"]
        [::std::mem::size_of::<q_obj_MemoryDeviceInfo_base>() - 4usize];
    ["Alignment of q_obj_MemoryDeviceInfo_base"]
        [::std::mem::align_of::<q_obj_MemoryDeviceInfo_base>() - 4usize];
    ["Offset of field: q_obj_MemoryDeviceInfo_base::type_"]
        [::std::mem::offset_of!(q_obj_MemoryDeviceInfo_base, type_) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryDeviceInfo {
    pub type_: MemoryDeviceInfoKind,
    pub u: MemoryDeviceInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MemoryDeviceInfo__bindgen_ty_1 {
    pub dimm: PCDIMMDeviceInfoWrapper,
    pub nvdimm: PCDIMMDeviceInfoWrapper,
    pub virtio_pmem: VirtioPMEMDeviceInfoWrapper,
    pub virtio_mem: VirtioMEMDeviceInfoWrapper,
    pub sgx_epc: SgxEPCDeviceInfoWrapper,
    pub hv_balloon: HvBalloonDeviceInfoWrapper,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryDeviceInfo__bindgen_ty_1"]
        [::std::mem::size_of::<MemoryDeviceInfo__bindgen_ty_1>() - 8usize];
    ["Alignment of MemoryDeviceInfo__bindgen_ty_1"]
        [::std::mem::align_of::<MemoryDeviceInfo__bindgen_ty_1>() - 8usize];
    ["Offset of field: MemoryDeviceInfo__bindgen_ty_1::dimm"]
        [::std::mem::offset_of!(MemoryDeviceInfo__bindgen_ty_1, dimm) - 0usize];
    ["Offset of field: MemoryDeviceInfo__bindgen_ty_1::nvdimm"]
        [::std::mem::offset_of!(MemoryDeviceInfo__bindgen_ty_1, nvdimm) - 0usize];
    ["Offset of field: MemoryDeviceInfo__bindgen_ty_1::virtio_pmem"]
        [::std::mem::offset_of!(MemoryDeviceInfo__bindgen_ty_1, virtio_pmem) - 0usize];
    ["Offset of field: MemoryDeviceInfo__bindgen_ty_1::virtio_mem"]
        [::std::mem::offset_of!(MemoryDeviceInfo__bindgen_ty_1, virtio_mem) - 0usize];
    ["Offset of field: MemoryDeviceInfo__bindgen_ty_1::sgx_epc"]
        [::std::mem::offset_of!(MemoryDeviceInfo__bindgen_ty_1, sgx_epc) - 0usize];
    ["Offset of field: MemoryDeviceInfo__bindgen_ty_1::hv_balloon"]
        [::std::mem::offset_of!(MemoryDeviceInfo__bindgen_ty_1, hv_balloon) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryDeviceInfo"][::std::mem::size_of::<MemoryDeviceInfo>() - 16usize];
    ["Alignment of MemoryDeviceInfo"][::std::mem::align_of::<MemoryDeviceInfo>() - 8usize];
    ["Offset of field: MemoryDeviceInfo::type_"]
        [::std::mem::offset_of!(MemoryDeviceInfo, type_) - 0usize];
    ["Offset of field: MemoryDeviceInfo::u"][::std::mem::offset_of!(MemoryDeviceInfo, u) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_MemoryDeviceInfo(obj: *mut MemoryDeviceInfo);
}
pub type MemoryDeviceInfo_autoptr = *mut MemoryDeviceInfo;
pub type MemoryDeviceInfo_listautoptr = *mut GList;
pub type MemoryDeviceInfo_slistautoptr = *mut GSList;
pub type MemoryDeviceInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SgxEPC {
    pub memdev: *mut ::std::os::raw::c_char,
    pub node: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SgxEPC"][::std::mem::size_of::<SgxEPC>() - 16usize];
    ["Alignment of SgxEPC"][::std::mem::align_of::<SgxEPC>() - 8usize];
    ["Offset of field: SgxEPC::memdev"][::std::mem::offset_of!(SgxEPC, memdev) - 0usize];
    ["Offset of field: SgxEPC::node"][::std::mem::offset_of!(SgxEPC, node) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_SgxEPC(obj: *mut SgxEPC);
}
pub type SgxEPC_autoptr = *mut SgxEPC;
pub type SgxEPC_listautoptr = *mut GList;
pub type SgxEPC_slistautoptr = *mut GSList;
pub type SgxEPC_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SgxEPCList {
    pub next: *mut SgxEPCList,
    pub value: *mut SgxEPC,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SgxEPCList"][::std::mem::size_of::<SgxEPCList>() - 16usize];
    ["Alignment of SgxEPCList"][::std::mem::align_of::<SgxEPCList>() - 8usize];
    ["Offset of field: SgxEPCList::next"][::std::mem::offset_of!(SgxEPCList, next) - 0usize];
    ["Offset of field: SgxEPCList::value"][::std::mem::offset_of!(SgxEPCList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_SgxEPCList(obj: *mut SgxEPCList);
}
pub type SgxEPCList_autoptr = *mut SgxEPCList;
pub type SgxEPCList_listautoptr = *mut GList;
pub type SgxEPCList_slistautoptr = *mut GSList;
pub type SgxEPCList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SgxEPCProperties {
    pub sgx_epc: *mut SgxEPCList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SgxEPCProperties"][::std::mem::size_of::<SgxEPCProperties>() - 8usize];
    ["Alignment of SgxEPCProperties"][::std::mem::align_of::<SgxEPCProperties>() - 8usize];
    ["Offset of field: SgxEPCProperties::sgx_epc"]
        [::std::mem::offset_of!(SgxEPCProperties, sgx_epc) - 0usize];
};
unsafe extern "C" {
    pub fn qapi_free_SgxEPCProperties(obj: *mut SgxEPCProperties);
}
pub type SgxEPCProperties_autoptr = *mut SgxEPCProperties;
pub type SgxEPCProperties_listautoptr = *mut GList;
pub type SgxEPCProperties_slistautoptr = *mut GSList;
pub type SgxEPCProperties_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryDeviceInfoList {
    pub next: *mut MemoryDeviceInfoList,
    pub value: *mut MemoryDeviceInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryDeviceInfoList"][::std::mem::size_of::<MemoryDeviceInfoList>() - 16usize];
    ["Alignment of MemoryDeviceInfoList"][::std::mem::align_of::<MemoryDeviceInfoList>() - 8usize];
    ["Offset of field: MemoryDeviceInfoList::next"]
        [::std::mem::offset_of!(MemoryDeviceInfoList, next) - 0usize];
    ["Offset of field: MemoryDeviceInfoList::value"]
        [::std::mem::offset_of!(MemoryDeviceInfoList, value) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_MemoryDeviceInfoList(obj: *mut MemoryDeviceInfoList);
}
pub type MemoryDeviceInfoList_autoptr = *mut MemoryDeviceInfoList;
pub type MemoryDeviceInfoList_listautoptr = *mut GList;
pub type MemoryDeviceInfoList_slistautoptr = *mut GSList;
pub type MemoryDeviceInfoList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg {
    pub id: *mut ::std::os::raw::c_char,
    pub size: u64,
    pub qom_path: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg"]
        [::std::mem::size_of::<q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg>() - 24usize];
    ["Alignment of q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg"]
        [::std::mem::align_of::<q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg>() - 8usize];
    ["Offset of field: q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg::id"]
        [::std::mem::offset_of!(q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg, id) - 0usize];
    ["Offset of field: q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg::size"]
        [::std::mem::offset_of!(q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg, size) - 8usize];
    ["Offset of field: q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg::qom_path"]
        [::std::mem::offset_of!(q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg, qom_path) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BootConfiguration {
    pub order: *mut ::std::os::raw::c_char,
    pub once: *mut ::std::os::raw::c_char,
    pub has_menu: bool,
    pub menu: bool,
    pub splash: *mut ::std::os::raw::c_char,
    pub has_splash_time: bool,
    pub splash_time: i64,
    pub has_reboot_timeout: bool,
    pub reboot_timeout: i64,
    pub has_strict: bool,
    pub strict: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BootConfiguration"][::std::mem::size_of::<BootConfiguration>() - 72usize];
    ["Alignment of BootConfiguration"][::std::mem::align_of::<BootConfiguration>() - 8usize];
    ["Offset of field: BootConfiguration::order"]
        [::std::mem::offset_of!(BootConfiguration, order) - 0usize];
    ["Offset of field: BootConfiguration::once"]
        [::std::mem::offset_of!(BootConfiguration, once) - 8usize];
    ["Offset of field: BootConfiguration::has_menu"]
        [::std::mem::offset_of!(BootConfiguration, has_menu) - 16usize];
    ["Offset of field: BootConfiguration::menu"]
        [::std::mem::offset_of!(BootConfiguration, menu) - 17usize];
    ["Offset of field: BootConfiguration::splash"]
        [::std::mem::offset_of!(BootConfiguration, splash) - 24usize];
    ["Offset of field: BootConfiguration::has_splash_time"]
        [::std::mem::offset_of!(BootConfiguration, has_splash_time) - 32usize];
    ["Offset of field: BootConfiguration::splash_time"]
        [::std::mem::offset_of!(BootConfiguration, splash_time) - 40usize];
    ["Offset of field: BootConfiguration::has_reboot_timeout"]
        [::std::mem::offset_of!(BootConfiguration, has_reboot_timeout) - 48usize];
    ["Offset of field: BootConfiguration::reboot_timeout"]
        [::std::mem::offset_of!(BootConfiguration, reboot_timeout) - 56usize];
    ["Offset of field: BootConfiguration::has_strict"]
        [::std::mem::offset_of!(BootConfiguration, has_strict) - 64usize];
    ["Offset of field: BootConfiguration::strict"]
        [::std::mem::offset_of!(BootConfiguration, strict) - 65usize];
};
unsafe extern "C" {
    pub fn qapi_free_BootConfiguration(obj: *mut BootConfiguration);
}
pub type BootConfiguration_autoptr = *mut BootConfiguration;
pub type BootConfiguration_listautoptr = *mut GList;
pub type BootConfiguration_slistautoptr = *mut GSList;
pub type BootConfiguration_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMPConfiguration {
    pub has_cpus: bool,
    pub cpus: i64,
    pub has_drawers: bool,
    pub drawers: i64,
    pub has_books: bool,
    pub books: i64,
    pub has_sockets: bool,
    pub sockets: i64,
    pub has_dies: bool,
    pub dies: i64,
    pub has_clusters: bool,
    pub clusters: i64,
    pub has_modules: bool,
    pub modules: i64,
    pub has_cores: bool,
    pub cores: i64,
    pub has_threads: bool,
    pub threads: i64,
    pub has_maxcpus: bool,
    pub maxcpus: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SMPConfiguration"][::std::mem::size_of::<SMPConfiguration>() - 160usize];
    ["Alignment of SMPConfiguration"][::std::mem::align_of::<SMPConfiguration>() - 8usize];
    ["Offset of field: SMPConfiguration::has_cpus"]
        [::std::mem::offset_of!(SMPConfiguration, has_cpus) - 0usize];
    ["Offset of field: SMPConfiguration::cpus"]
        [::std::mem::offset_of!(SMPConfiguration, cpus) - 8usize];
    ["Offset of field: SMPConfiguration::has_drawers"]
        [::std::mem::offset_of!(SMPConfiguration, has_drawers) - 16usize];
    ["Offset of field: SMPConfiguration::drawers"]
        [::std::mem::offset_of!(SMPConfiguration, drawers) - 24usize];
    ["Offset of field: SMPConfiguration::has_books"]
        [::std::mem::offset_of!(SMPConfiguration, has_books) - 32usize];
    ["Offset of field: SMPConfiguration::books"]
        [::std::mem::offset_of!(SMPConfiguration, books) - 40usize];
    ["Offset of field: SMPConfiguration::has_sockets"]
        [::std::mem::offset_of!(SMPConfiguration, has_sockets) - 48usize];
    ["Offset of field: SMPConfiguration::sockets"]
        [::std::mem::offset_of!(SMPConfiguration, sockets) - 56usize];
    ["Offset of field: SMPConfiguration::has_dies"]
        [::std::mem::offset_of!(SMPConfiguration, has_dies) - 64usize];
    ["Offset of field: SMPConfiguration::dies"]
        [::std::mem::offset_of!(SMPConfiguration, dies) - 72usize];
    ["Offset of field: SMPConfiguration::has_clusters"]
        [::std::mem::offset_of!(SMPConfiguration, has_clusters) - 80usize];
    ["Offset of field: SMPConfiguration::clusters"]
        [::std::mem::offset_of!(SMPConfiguration, clusters) - 88usize];
    ["Offset of field: SMPConfiguration::has_modules"]
        [::std::mem::offset_of!(SMPConfiguration, has_modules) - 96usize];
    ["Offset of field: SMPConfiguration::modules"]
        [::std::mem::offset_of!(SMPConfiguration, modules) - 104usize];
    ["Offset of field: SMPConfiguration::has_cores"]
        [::std::mem::offset_of!(SMPConfiguration, has_cores) - 112usize];
    ["Offset of field: SMPConfiguration::cores"]
        [::std::mem::offset_of!(SMPConfiguration, cores) - 120usize];
    ["Offset of field: SMPConfiguration::has_threads"]
        [::std::mem::offset_of!(SMPConfiguration, has_threads) - 128usize];
    ["Offset of field: SMPConfiguration::threads"]
        [::std::mem::offset_of!(SMPConfiguration, threads) - 136usize];
    ["Offset of field: SMPConfiguration::has_maxcpus"]
        [::std::mem::offset_of!(SMPConfiguration, has_maxcpus) - 144usize];
    ["Offset of field: SMPConfiguration::maxcpus"]
        [::std::mem::offset_of!(SMPConfiguration, maxcpus) - 152usize];
};
unsafe extern "C" {
    pub fn qapi_free_SMPConfiguration(obj: *mut SMPConfiguration);
}
pub type SMPConfiguration_autoptr = *mut SMPConfiguration;
pub type SMPConfiguration_listautoptr = *mut GList;
pub type SMPConfiguration_slistautoptr = *mut GSList;
pub type SMPConfiguration_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemorySizeConfiguration {
    pub has_size: bool,
    pub size: u64,
    pub has_max_size: bool,
    pub max_size: u64,
    pub has_slots: bool,
    pub slots: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemorySizeConfiguration"][::std::mem::size_of::<MemorySizeConfiguration>() - 48usize];
    ["Alignment of MemorySizeConfiguration"]
        [::std::mem::align_of::<MemorySizeConfiguration>() - 8usize];
    ["Offset of field: MemorySizeConfiguration::has_size"]
        [::std::mem::offset_of!(MemorySizeConfiguration, has_size) - 0usize];
    ["Offset of field: MemorySizeConfiguration::size"]
        [::std::mem::offset_of!(MemorySizeConfiguration, size) - 8usize];
    ["Offset of field: MemorySizeConfiguration::has_max_size"]
        [::std::mem::offset_of!(MemorySizeConfiguration, has_max_size) - 16usize];
    ["Offset of field: MemorySizeConfiguration::max_size"]
        [::std::mem::offset_of!(MemorySizeConfiguration, max_size) - 24usize];
    ["Offset of field: MemorySizeConfiguration::has_slots"]
        [::std::mem::offset_of!(MemorySizeConfiguration, has_slots) - 32usize];
    ["Offset of field: MemorySizeConfiguration::slots"]
        [::std::mem::offset_of!(MemorySizeConfiguration, slots) - 40usize];
};
unsafe extern "C" {
    pub fn qapi_free_MemorySizeConfiguration(obj: *mut MemorySizeConfiguration);
}
pub type MemorySizeConfiguration_autoptr = *mut MemorySizeConfiguration;
pub type MemorySizeConfiguration_listautoptr = *mut GList;
pub type MemorySizeConfiguration_slistautoptr = *mut GSList;
pub type MemorySizeConfiguration_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_dumpdtb_arg {
    pub filename: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_dumpdtb_arg"][::std::mem::size_of::<q_obj_dumpdtb_arg>() - 8usize];
    ["Alignment of q_obj_dumpdtb_arg"][::std::mem::align_of::<q_obj_dumpdtb_arg>() - 8usize];
    ["Offset of field: q_obj_dumpdtb_arg::filename"]
        [::std::mem::offset_of!(q_obj_dumpdtb_arg, filename) - 0usize];
};
pub const RUN_STATE_DEBUG: RunState = 0;
pub const RUN_STATE_INMIGRATE: RunState = 1;
pub const RUN_STATE_INTERNAL_ERROR: RunState = 2;
pub const RUN_STATE_IO_ERROR: RunState = 3;
pub const RUN_STATE_PAUSED: RunState = 4;
pub const RUN_STATE_POSTMIGRATE: RunState = 5;
pub const RUN_STATE_PRELAUNCH: RunState = 6;
pub const RUN_STATE_FINISH_MIGRATE: RunState = 7;
pub const RUN_STATE_RESTORE_VM: RunState = 8;
pub const RUN_STATE_RUNNING: RunState = 9;
pub const RUN_STATE_SAVE_VM: RunState = 10;
pub const RUN_STATE_SHUTDOWN: RunState = 11;
pub const RUN_STATE_SUSPENDED: RunState = 12;
pub const RUN_STATE_WATCHDOG: RunState = 13;
pub const RUN_STATE_GUEST_PANICKED: RunState = 14;
pub const RUN_STATE_COLO: RunState = 15;
pub const RUN_STATE__MAX: RunState = 16;
pub type RunState = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static RunState_lookup: QEnumLookup;
}
pub const SHUTDOWN_CAUSE_NONE: ShutdownCause = 0;
pub const SHUTDOWN_CAUSE_HOST_ERROR: ShutdownCause = 1;
pub const SHUTDOWN_CAUSE_HOST_QMP_QUIT: ShutdownCause = 2;
pub const SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET: ShutdownCause = 3;
pub const SHUTDOWN_CAUSE_HOST_SIGNAL: ShutdownCause = 4;
pub const SHUTDOWN_CAUSE_HOST_UI: ShutdownCause = 5;
pub const SHUTDOWN_CAUSE_GUEST_SHUTDOWN: ShutdownCause = 6;
pub const SHUTDOWN_CAUSE_GUEST_RESET: ShutdownCause = 7;
pub const SHUTDOWN_CAUSE_GUEST_PANIC: ShutdownCause = 8;
pub const SHUTDOWN_CAUSE_SUBSYSTEM_RESET: ShutdownCause = 9;
pub const SHUTDOWN_CAUSE_SNAPSHOT_LOAD: ShutdownCause = 10;
pub const SHUTDOWN_CAUSE__MAX: ShutdownCause = 11;
pub type ShutdownCause = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static ShutdownCause_lookup: QEnumLookup;
}
pub const WATCHDOG_ACTION_RESET: WatchdogAction = 0;
pub const WATCHDOG_ACTION_SHUTDOWN: WatchdogAction = 1;
pub const WATCHDOG_ACTION_POWEROFF: WatchdogAction = 2;
pub const WATCHDOG_ACTION_PAUSE: WatchdogAction = 3;
pub const WATCHDOG_ACTION_DEBUG: WatchdogAction = 4;
pub const WATCHDOG_ACTION_NONE: WatchdogAction = 5;
pub const WATCHDOG_ACTION_INJECT_NMI: WatchdogAction = 6;
pub const WATCHDOG_ACTION__MAX: WatchdogAction = 7;
pub type WatchdogAction = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static WatchdogAction_lookup: QEnumLookup;
}
pub const REBOOT_ACTION_RESET: RebootAction = 0;
pub const REBOOT_ACTION_SHUTDOWN: RebootAction = 1;
pub const REBOOT_ACTION__MAX: RebootAction = 2;
pub type RebootAction = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static RebootAction_lookup: QEnumLookup;
}
pub const SHUTDOWN_ACTION_POWEROFF: ShutdownAction = 0;
pub const SHUTDOWN_ACTION_PAUSE: ShutdownAction = 1;
pub const SHUTDOWN_ACTION__MAX: ShutdownAction = 2;
pub type ShutdownAction = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static ShutdownAction_lookup: QEnumLookup;
}
pub const PANIC_ACTION_PAUSE: PanicAction = 0;
pub const PANIC_ACTION_SHUTDOWN: PanicAction = 1;
pub const PANIC_ACTION_EXIT_FAILURE: PanicAction = 2;
pub const PANIC_ACTION_NONE: PanicAction = 3;
pub const PANIC_ACTION__MAX: PanicAction = 4;
pub type PanicAction = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static PanicAction_lookup: QEnumLookup;
}
pub const GUEST_PANIC_ACTION_PAUSE: GuestPanicAction = 0;
pub const GUEST_PANIC_ACTION_POWEROFF: GuestPanicAction = 1;
pub const GUEST_PANIC_ACTION_RUN: GuestPanicAction = 2;
pub const GUEST_PANIC_ACTION__MAX: GuestPanicAction = 3;
pub type GuestPanicAction = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static GuestPanicAction_lookup: QEnumLookup;
}
pub const GUEST_PANIC_INFORMATION_TYPE_HYPER_V: GuestPanicInformationType = 0;
pub const GUEST_PANIC_INFORMATION_TYPE_S390: GuestPanicInformationType = 1;
pub const GUEST_PANIC_INFORMATION_TYPE__MAX: GuestPanicInformationType = 2;
pub type GuestPanicInformationType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static GuestPanicInformationType_lookup: QEnumLookup;
}
pub const S390_CRASH_REASON_UNKNOWN: S390CrashReason = 0;
pub const S390_CRASH_REASON_DISABLED_WAIT: S390CrashReason = 1;
pub const S390_CRASH_REASON_EXTINT_LOOP: S390CrashReason = 2;
pub const S390_CRASH_REASON_PGMINT_LOOP: S390CrashReason = 3;
pub const S390_CRASH_REASON_OPINT_LOOP: S390CrashReason = 4;
pub const S390_CRASH_REASON__MAX: S390CrashReason = 5;
pub type S390CrashReason = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static S390CrashReason_lookup: QEnumLookup;
}
pub const MEMORY_FAILURE_RECIPIENT_HYPERVISOR: MemoryFailureRecipient = 0;
pub const MEMORY_FAILURE_RECIPIENT_GUEST: MemoryFailureRecipient = 1;
pub const MEMORY_FAILURE_RECIPIENT__MAX: MemoryFailureRecipient = 2;
pub type MemoryFailureRecipient = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static MemoryFailureRecipient_lookup: QEnumLookup;
}
pub const MEMORY_FAILURE_ACTION_IGNORE: MemoryFailureAction = 0;
pub const MEMORY_FAILURE_ACTION_INJECT: MemoryFailureAction = 1;
pub const MEMORY_FAILURE_ACTION_FATAL: MemoryFailureAction = 2;
pub const MEMORY_FAILURE_ACTION_RESET: MemoryFailureAction = 3;
pub const MEMORY_FAILURE_ACTION__MAX: MemoryFailureAction = 4;
pub type MemoryFailureAction = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static MemoryFailureAction_lookup: QEnumLookup;
}
pub const NOTIFY_VMEXIT_OPTION_RUN: NotifyVmexitOption = 0;
pub const NOTIFY_VMEXIT_OPTION_INTERNAL_ERROR: NotifyVmexitOption = 1;
pub const NOTIFY_VMEXIT_OPTION_DISABLE: NotifyVmexitOption = 2;
pub const NOTIFY_VMEXIT_OPTION__MAX: NotifyVmexitOption = 3;
pub type NotifyVmexitOption = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static NotifyVmexitOption_lookup: QEnumLookup;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StatusInfo {
    pub running: bool,
    pub status: RunState,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of StatusInfo"][::std::mem::size_of::<StatusInfo>() - 8usize];
    ["Alignment of StatusInfo"][::std::mem::align_of::<StatusInfo>() - 4usize];
    ["Offset of field: StatusInfo::running"][::std::mem::offset_of!(StatusInfo, running) - 0usize];
    ["Offset of field: StatusInfo::status"][::std::mem::offset_of!(StatusInfo, status) - 4usize];
};
unsafe extern "C" {
    pub fn qapi_free_StatusInfo(obj: *mut StatusInfo);
}
pub type StatusInfo_autoptr = *mut StatusInfo;
pub type StatusInfo_listautoptr = *mut GList;
pub type StatusInfo_slistautoptr = *mut GSList;
pub type StatusInfo_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_SHUTDOWN_arg {
    pub guest: bool,
    pub reason: ShutdownCause,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_SHUTDOWN_arg"][::std::mem::size_of::<q_obj_SHUTDOWN_arg>() - 8usize];
    ["Alignment of q_obj_SHUTDOWN_arg"][::std::mem::align_of::<q_obj_SHUTDOWN_arg>() - 4usize];
    ["Offset of field: q_obj_SHUTDOWN_arg::guest"]
        [::std::mem::offset_of!(q_obj_SHUTDOWN_arg, guest) - 0usize];
    ["Offset of field: q_obj_SHUTDOWN_arg::reason"]
        [::std::mem::offset_of!(q_obj_SHUTDOWN_arg, reason) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_RESET_arg {
    pub guest: bool,
    pub reason: ShutdownCause,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_RESET_arg"][::std::mem::size_of::<q_obj_RESET_arg>() - 8usize];
    ["Alignment of q_obj_RESET_arg"][::std::mem::align_of::<q_obj_RESET_arg>() - 4usize];
    ["Offset of field: q_obj_RESET_arg::guest"]
        [::std::mem::offset_of!(q_obj_RESET_arg, guest) - 0usize];
    ["Offset of field: q_obj_RESET_arg::reason"]
        [::std::mem::offset_of!(q_obj_RESET_arg, reason) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_WATCHDOG_arg {
    pub action: WatchdogAction,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_WATCHDOG_arg"][::std::mem::size_of::<q_obj_WATCHDOG_arg>() - 4usize];
    ["Alignment of q_obj_WATCHDOG_arg"][::std::mem::align_of::<q_obj_WATCHDOG_arg>() - 4usize];
    ["Offset of field: q_obj_WATCHDOG_arg::action"]
        [::std::mem::offset_of!(q_obj_WATCHDOG_arg, action) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_watchdog_set_action_arg {
    pub action: WatchdogAction,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_watchdog_set_action_arg"]
        [::std::mem::size_of::<q_obj_watchdog_set_action_arg>() - 4usize];
    ["Alignment of q_obj_watchdog_set_action_arg"]
        [::std::mem::align_of::<q_obj_watchdog_set_action_arg>() - 4usize];
    ["Offset of field: q_obj_watchdog_set_action_arg::action"]
        [::std::mem::offset_of!(q_obj_watchdog_set_action_arg, action) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_set_action_arg {
    pub has_reboot: bool,
    pub reboot: RebootAction,
    pub has_shutdown: bool,
    pub shutdown: ShutdownAction,
    pub has_panic: bool,
    pub panic: PanicAction,
    pub has_watchdog: bool,
    pub watchdog: WatchdogAction,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_set_action_arg"][::std::mem::size_of::<q_obj_set_action_arg>() - 32usize];
    ["Alignment of q_obj_set_action_arg"][::std::mem::align_of::<q_obj_set_action_arg>() - 4usize];
    ["Offset of field: q_obj_set_action_arg::has_reboot"]
        [::std::mem::offset_of!(q_obj_set_action_arg, has_reboot) - 0usize];
    ["Offset of field: q_obj_set_action_arg::reboot"]
        [::std::mem::offset_of!(q_obj_set_action_arg, reboot) - 4usize];
    ["Offset of field: q_obj_set_action_arg::has_shutdown"]
        [::std::mem::offset_of!(q_obj_set_action_arg, has_shutdown) - 8usize];
    ["Offset of field: q_obj_set_action_arg::shutdown"]
        [::std::mem::offset_of!(q_obj_set_action_arg, shutdown) - 12usize];
    ["Offset of field: q_obj_set_action_arg::has_panic"]
        [::std::mem::offset_of!(q_obj_set_action_arg, has_panic) - 16usize];
    ["Offset of field: q_obj_set_action_arg::panic"]
        [::std::mem::offset_of!(q_obj_set_action_arg, panic) - 20usize];
    ["Offset of field: q_obj_set_action_arg::has_watchdog"]
        [::std::mem::offset_of!(q_obj_set_action_arg, has_watchdog) - 24usize];
    ["Offset of field: q_obj_set_action_arg::watchdog"]
        [::std::mem::offset_of!(q_obj_set_action_arg, watchdog) - 28usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_GUEST_PANICKED_arg {
    pub action: GuestPanicAction,
    pub info: *mut GuestPanicInformation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_GUEST_PANICKED_arg"]
        [::std::mem::size_of::<q_obj_GUEST_PANICKED_arg>() - 16usize];
    ["Alignment of q_obj_GUEST_PANICKED_arg"]
        [::std::mem::align_of::<q_obj_GUEST_PANICKED_arg>() - 8usize];
    ["Offset of field: q_obj_GUEST_PANICKED_arg::action"]
        [::std::mem::offset_of!(q_obj_GUEST_PANICKED_arg, action) - 0usize];
    ["Offset of field: q_obj_GUEST_PANICKED_arg::info"]
        [::std::mem::offset_of!(q_obj_GUEST_PANICKED_arg, info) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_GUEST_CRASHLOADED_arg {
    pub action: GuestPanicAction,
    pub info: *mut GuestPanicInformation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_GUEST_CRASHLOADED_arg"]
        [::std::mem::size_of::<q_obj_GUEST_CRASHLOADED_arg>() - 16usize];
    ["Alignment of q_obj_GUEST_CRASHLOADED_arg"]
        [::std::mem::align_of::<q_obj_GUEST_CRASHLOADED_arg>() - 8usize];
    ["Offset of field: q_obj_GUEST_CRASHLOADED_arg::action"]
        [::std::mem::offset_of!(q_obj_GUEST_CRASHLOADED_arg, action) - 0usize];
    ["Offset of field: q_obj_GUEST_CRASHLOADED_arg::info"]
        [::std::mem::offset_of!(q_obj_GUEST_CRASHLOADED_arg, info) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_GuestPanicInformation_base {
    pub type_: GuestPanicInformationType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_GuestPanicInformation_base"]
        [::std::mem::size_of::<q_obj_GuestPanicInformation_base>() - 4usize];
    ["Alignment of q_obj_GuestPanicInformation_base"]
        [::std::mem::align_of::<q_obj_GuestPanicInformation_base>() - 4usize];
    ["Offset of field: q_obj_GuestPanicInformation_base::type_"]
        [::std::mem::offset_of!(q_obj_GuestPanicInformation_base, type_) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GuestPanicInformationHyperV {
    pub arg1: u64,
    pub arg2: u64,
    pub arg3: u64,
    pub arg4: u64,
    pub arg5: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GuestPanicInformationHyperV"]
        [::std::mem::size_of::<GuestPanicInformationHyperV>() - 40usize];
    ["Alignment of GuestPanicInformationHyperV"]
        [::std::mem::align_of::<GuestPanicInformationHyperV>() - 8usize];
    ["Offset of field: GuestPanicInformationHyperV::arg1"]
        [::std::mem::offset_of!(GuestPanicInformationHyperV, arg1) - 0usize];
    ["Offset of field: GuestPanicInformationHyperV::arg2"]
        [::std::mem::offset_of!(GuestPanicInformationHyperV, arg2) - 8usize];
    ["Offset of field: GuestPanicInformationHyperV::arg3"]
        [::std::mem::offset_of!(GuestPanicInformationHyperV, arg3) - 16usize];
    ["Offset of field: GuestPanicInformationHyperV::arg4"]
        [::std::mem::offset_of!(GuestPanicInformationHyperV, arg4) - 24usize];
    ["Offset of field: GuestPanicInformationHyperV::arg5"]
        [::std::mem::offset_of!(GuestPanicInformationHyperV, arg5) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GuestPanicInformationS390 {
    pub core: u32,
    pub psw_mask: u64,
    pub psw_addr: u64,
    pub reason: S390CrashReason,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GuestPanicInformationS390"]
        [::std::mem::size_of::<GuestPanicInformationS390>() - 32usize];
    ["Alignment of GuestPanicInformationS390"]
        [::std::mem::align_of::<GuestPanicInformationS390>() - 8usize];
    ["Offset of field: GuestPanicInformationS390::core"]
        [::std::mem::offset_of!(GuestPanicInformationS390, core) - 0usize];
    ["Offset of field: GuestPanicInformationS390::psw_mask"]
        [::std::mem::offset_of!(GuestPanicInformationS390, psw_mask) - 8usize];
    ["Offset of field: GuestPanicInformationS390::psw_addr"]
        [::std::mem::offset_of!(GuestPanicInformationS390, psw_addr) - 16usize];
    ["Offset of field: GuestPanicInformationS390::reason"]
        [::std::mem::offset_of!(GuestPanicInformationS390, reason) - 24usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GuestPanicInformation {
    pub type_: GuestPanicInformationType,
    pub u: GuestPanicInformation__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GuestPanicInformation__bindgen_ty_1 {
    pub hyper_v: GuestPanicInformationHyperV,
    pub s390: GuestPanicInformationS390,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GuestPanicInformation__bindgen_ty_1"]
        [::std::mem::size_of::<GuestPanicInformation__bindgen_ty_1>() - 40usize];
    ["Alignment of GuestPanicInformation__bindgen_ty_1"]
        [::std::mem::align_of::<GuestPanicInformation__bindgen_ty_1>() - 8usize];
    ["Offset of field: GuestPanicInformation__bindgen_ty_1::hyper_v"]
        [::std::mem::offset_of!(GuestPanicInformation__bindgen_ty_1, hyper_v) - 0usize];
    ["Offset of field: GuestPanicInformation__bindgen_ty_1::s390"]
        [::std::mem::offset_of!(GuestPanicInformation__bindgen_ty_1, s390) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GuestPanicInformation"][::std::mem::size_of::<GuestPanicInformation>() - 48usize];
    ["Alignment of GuestPanicInformation"]
        [::std::mem::align_of::<GuestPanicInformation>() - 8usize];
    ["Offset of field: GuestPanicInformation::type_"]
        [::std::mem::offset_of!(GuestPanicInformation, type_) - 0usize];
    ["Offset of field: GuestPanicInformation::u"]
        [::std::mem::offset_of!(GuestPanicInformation, u) - 8usize];
};
unsafe extern "C" {
    pub fn qapi_free_GuestPanicInformation(obj: *mut GuestPanicInformation);
}
pub type GuestPanicInformation_autoptr = *mut GuestPanicInformation;
pub type GuestPanicInformation_listautoptr = *mut GList;
pub type GuestPanicInformation_slistautoptr = *mut GSList;
pub type GuestPanicInformation_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn qapi_free_GuestPanicInformationHyperV(obj: *mut GuestPanicInformationHyperV);
}
pub type GuestPanicInformationHyperV_autoptr = *mut GuestPanicInformationHyperV;
pub type GuestPanicInformationHyperV_listautoptr = *mut GList;
pub type GuestPanicInformationHyperV_slistautoptr = *mut GSList;
pub type GuestPanicInformationHyperV_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn qapi_free_GuestPanicInformationS390(obj: *mut GuestPanicInformationS390);
}
pub type GuestPanicInformationS390_autoptr = *mut GuestPanicInformationS390;
pub type GuestPanicInformationS390_listautoptr = *mut GList;
pub type GuestPanicInformationS390_slistautoptr = *mut GSList;
pub type GuestPanicInformationS390_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_MEMORY_FAILURE_arg {
    pub recipient: MemoryFailureRecipient,
    pub action: MemoryFailureAction,
    pub flags: *mut MemoryFailureFlags,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of q_obj_MEMORY_FAILURE_arg"]
        [::std::mem::size_of::<q_obj_MEMORY_FAILURE_arg>() - 16usize];
    ["Alignment of q_obj_MEMORY_FAILURE_arg"]
        [::std::mem::align_of::<q_obj_MEMORY_FAILURE_arg>() - 8usize];
    ["Offset of field: q_obj_MEMORY_FAILURE_arg::recipient"]
        [::std::mem::offset_of!(q_obj_MEMORY_FAILURE_arg, recipient) - 0usize];
    ["Offset of field: q_obj_MEMORY_FAILURE_arg::action"]
        [::std::mem::offset_of!(q_obj_MEMORY_FAILURE_arg, action) - 4usize];
    ["Offset of field: q_obj_MEMORY_FAILURE_arg::flags"]
        [::std::mem::offset_of!(q_obj_MEMORY_FAILURE_arg, flags) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryFailureFlags {
    pub action_required: bool,
    pub recursive: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryFailureFlags"][::std::mem::size_of::<MemoryFailureFlags>() - 2usize];
    ["Alignment of MemoryFailureFlags"][::std::mem::align_of::<MemoryFailureFlags>() - 1usize];
    ["Offset of field: MemoryFailureFlags::action_required"]
        [::std::mem::offset_of!(MemoryFailureFlags, action_required) - 0usize];
    ["Offset of field: MemoryFailureFlags::recursive"]
        [::std::mem::offset_of!(MemoryFailureFlags, recursive) - 1usize];
};
unsafe extern "C" {
    pub fn qapi_free_MemoryFailureFlags(obj: *mut MemoryFailureFlags);
}
pub type MemoryFailureFlags_autoptr = *mut MemoryFailureFlags;
pub type MemoryFailureFlags_listautoptr = *mut GList;
pub type MemoryFailureFlags_slistautoptr = *mut GSList;
pub type MemoryFailureFlags_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuLockCnt {
    pub count: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuLockCnt"][::std::mem::size_of::<QemuLockCnt>() - 4usize];
    ["Alignment of QemuLockCnt"][::std::mem::align_of::<QemuLockCnt>() - 4usize];
    ["Offset of field: QemuLockCnt::count"][::std::mem::offset_of!(QemuLockCnt, count) - 0usize];
};
unsafe extern "C" {
    pub fn qemu_lockcnt_init(lockcnt: *mut QemuLockCnt);
}
unsafe extern "C" {
    pub fn qemu_lockcnt_destroy(lockcnt: *mut QemuLockCnt);
}
unsafe extern "C" {
    pub fn qemu_lockcnt_inc(lockcnt: *mut QemuLockCnt);
}
unsafe extern "C" {
    pub fn qemu_lockcnt_dec(lockcnt: *mut QemuLockCnt);
}
unsafe extern "C" {
    pub fn qemu_lockcnt_dec_and_lock(lockcnt: *mut QemuLockCnt) -> bool;
}
unsafe extern "C" {
    pub fn qemu_lockcnt_dec_if_lock(lockcnt: *mut QemuLockCnt) -> bool;
}
unsafe extern "C" {
    pub fn qemu_lockcnt_lock(lockcnt: *mut QemuLockCnt);
}
unsafe extern "C" {
    pub fn qemu_lockcnt_unlock(lockcnt: *mut QemuLockCnt);
}
unsafe extern "C" {
    pub fn qemu_lockcnt_inc_and_unlock(lockcnt: *mut QemuLockCnt);
}
unsafe extern "C" {
    pub fn qemu_lockcnt_count(lockcnt: *mut QemuLockCnt) -> ::std::os::raw::c_uint;
}
pub type WriteCoreDumpFunction = ::std::option::Option<
    unsafe extern "C" fn(
        buf: *const ::std::os::raw::c_void,
        size: usize,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUAddressSpace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUJumpCache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccelCPUClass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysemuCPUOps {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUClass {
    pub parent_class: DeviceClass,
    pub class_by_name: ::std::option::Option<
        unsafe extern "C" fn(cpu_model: *const ::std::os::raw::c_char) -> *mut ObjectClass,
    >,
    pub parse_features: ::std::option::Option<
        unsafe extern "C" fn(
            typename: *const ::std::os::raw::c_char,
            str_: *mut ::std::os::raw::c_char,
            errp: *mut *mut Error,
        ),
    >,
    pub has_work: ::std::option::Option<unsafe extern "C" fn(cpu: *mut CPUState) -> bool>,
    pub mmu_index: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut CPUState, ifetch: bool) -> ::std::os::raw::c_int,
    >,
    pub memory_rw_debug: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut CPUState,
            addr: vaddr,
            buf: *mut u8,
            len: ::std::os::raw::c_int,
            is_write: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub dump_state: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut CPUState, arg1: *mut FILE, flags: ::std::os::raw::c_int),
    >,
    pub query_cpu_fast:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut CPUState, value: *mut CpuInfoFast)>,
    pub get_arch_id: ::std::option::Option<unsafe extern "C" fn(cpu: *mut CPUState) -> i64>,
    pub set_pc: ::std::option::Option<unsafe extern "C" fn(cpu: *mut CPUState, value: vaddr)>,
    pub get_pc: ::std::option::Option<unsafe extern "C" fn(cpu: *mut CPUState) -> vaddr>,
    pub gdb_read_register: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut CPUState,
            buf: *mut GByteArray,
            reg: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub gdb_write_register: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: *mut CPUState,
            buf: *mut u8,
            reg: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub gdb_adjust_breakpoint:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut CPUState, addr: vaddr) -> vaddr>,
    pub gdb_core_xml_file: *const ::std::os::raw::c_char,
    pub gdb_arch_name:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut CPUState) -> *const gchar>,
    pub disas_set_info: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut CPUState, info: *mut disassemble_info),
    >,
    pub deprecation_note: *const ::std::os::raw::c_char,
    pub accel_cpu: *mut AccelCPUClass,
    pub sysemu_ops: *const SysemuCPUOps,
    pub tcg_ops: *const TCGCPUOps,
    pub init_accel_cpu: ::std::option::Option<
        unsafe extern "C" fn(accel_cpu: *mut AccelCPUClass, cc: *mut CPUClass),
    >,
    pub reset_dump_flags: ::std::os::raw::c_int,
    pub gdb_num_core_regs: ::std::os::raw::c_int,
    pub gdb_stop_before_watchpoint: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUClass"][::std::mem::size_of::<CPUClass>() - 368usize];
    ["Alignment of CPUClass"][::std::mem::align_of::<CPUClass>() - 8usize];
    ["Offset of field: CPUClass::parent_class"]
        [::std::mem::offset_of!(CPUClass, parent_class) - 0usize];
    ["Offset of field: CPUClass::class_by_name"]
        [::std::mem::offset_of!(CPUClass, class_by_name) - 184usize];
    ["Offset of field: CPUClass::parse_features"]
        [::std::mem::offset_of!(CPUClass, parse_features) - 192usize];
    ["Offset of field: CPUClass::has_work"][::std::mem::offset_of!(CPUClass, has_work) - 200usize];
    ["Offset of field: CPUClass::mmu_index"]
        [::std::mem::offset_of!(CPUClass, mmu_index) - 208usize];
    ["Offset of field: CPUClass::memory_rw_debug"]
        [::std::mem::offset_of!(CPUClass, memory_rw_debug) - 216usize];
    ["Offset of field: CPUClass::dump_state"]
        [::std::mem::offset_of!(CPUClass, dump_state) - 224usize];
    ["Offset of field: CPUClass::query_cpu_fast"]
        [::std::mem::offset_of!(CPUClass, query_cpu_fast) - 232usize];
    ["Offset of field: CPUClass::get_arch_id"]
        [::std::mem::offset_of!(CPUClass, get_arch_id) - 240usize];
    ["Offset of field: CPUClass::set_pc"][::std::mem::offset_of!(CPUClass, set_pc) - 248usize];
    ["Offset of field: CPUClass::get_pc"][::std::mem::offset_of!(CPUClass, get_pc) - 256usize];
    ["Offset of field: CPUClass::gdb_read_register"]
        [::std::mem::offset_of!(CPUClass, gdb_read_register) - 264usize];
    ["Offset of field: CPUClass::gdb_write_register"]
        [::std::mem::offset_of!(CPUClass, gdb_write_register) - 272usize];
    ["Offset of field: CPUClass::gdb_adjust_breakpoint"]
        [::std::mem::offset_of!(CPUClass, gdb_adjust_breakpoint) - 280usize];
    ["Offset of field: CPUClass::gdb_core_xml_file"]
        [::std::mem::offset_of!(CPUClass, gdb_core_xml_file) - 288usize];
    ["Offset of field: CPUClass::gdb_arch_name"]
        [::std::mem::offset_of!(CPUClass, gdb_arch_name) - 296usize];
    ["Offset of field: CPUClass::disas_set_info"]
        [::std::mem::offset_of!(CPUClass, disas_set_info) - 304usize];
    ["Offset of field: CPUClass::deprecation_note"]
        [::std::mem::offset_of!(CPUClass, deprecation_note) - 312usize];
    ["Offset of field: CPUClass::accel_cpu"]
        [::std::mem::offset_of!(CPUClass, accel_cpu) - 320usize];
    ["Offset of field: CPUClass::sysemu_ops"]
        [::std::mem::offset_of!(CPUClass, sysemu_ops) - 328usize];
    ["Offset of field: CPUClass::tcg_ops"][::std::mem::offset_of!(CPUClass, tcg_ops) - 336usize];
    ["Offset of field: CPUClass::init_accel_cpu"]
        [::std::mem::offset_of!(CPUClass, init_accel_cpu) - 344usize];
    ["Offset of field: CPUClass::reset_dump_flags"]
        [::std::mem::offset_of!(CPUClass, reset_dump_flags) - 352usize];
    ["Offset of field: CPUClass::gdb_num_core_regs"]
        [::std::mem::offset_of!(CPUClass, gdb_num_core_regs) - 356usize];
    ["Offset of field: CPUClass::gdb_stop_before_watchpoint"]
        [::std::mem::offset_of!(CPUClass, gdb_stop_before_watchpoint) - 360usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CPUTLBEntryFull {
    pub xlat_section: hwaddr,
    pub phys_addr: hwaddr,
    pub attrs: MemTxAttrs,
    pub prot: u8,
    pub lg_page_size: u8,
    pub tlb_fill_flags: u8,
    pub slow_flags: [u8; 3usize],
    pub extra: CPUTLBEntryFull__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUTLBEntryFull__bindgen_ty_1 {
    pub arm: CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1 {
    pub pte_attrs: u8,
    pub shareability: u8,
    pub guarded: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1>() - 3usize];
    ["Alignment of CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Offset of field: CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1::pte_attrs"]
        [::std::mem::offset_of!(CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1, pte_attrs) - 0usize];
    ["Offset of field: CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1::shareability"][::std::mem::offset_of!(
        CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1,
        shareability
    ) - 1usize];
    ["Offset of field: CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1::guarded"]
        [::std::mem::offset_of!(CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1, guarded) - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUTLBEntryFull__bindgen_ty_1"]
        [::std::mem::size_of::<CPUTLBEntryFull__bindgen_ty_1>() - 3usize];
    ["Alignment of CPUTLBEntryFull__bindgen_ty_1"]
        [::std::mem::align_of::<CPUTLBEntryFull__bindgen_ty_1>() - 1usize];
    ["Offset of field: CPUTLBEntryFull__bindgen_ty_1::arm"]
        [::std::mem::offset_of!(CPUTLBEntryFull__bindgen_ty_1, arm) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUTLBEntryFull"][::std::mem::size_of::<CPUTLBEntryFull>() - 40usize];
    ["Alignment of CPUTLBEntryFull"][::std::mem::align_of::<CPUTLBEntryFull>() - 8usize];
    ["Offset of field: CPUTLBEntryFull::xlat_section"]
        [::std::mem::offset_of!(CPUTLBEntryFull, xlat_section) - 0usize];
    ["Offset of field: CPUTLBEntryFull::phys_addr"]
        [::std::mem::offset_of!(CPUTLBEntryFull, phys_addr) - 8usize];
    ["Offset of field: CPUTLBEntryFull::attrs"]
        [::std::mem::offset_of!(CPUTLBEntryFull, attrs) - 16usize];
    ["Offset of field: CPUTLBEntryFull::prot"]
        [::std::mem::offset_of!(CPUTLBEntryFull, prot) - 24usize];
    ["Offset of field: CPUTLBEntryFull::lg_page_size"]
        [::std::mem::offset_of!(CPUTLBEntryFull, lg_page_size) - 25usize];
    ["Offset of field: CPUTLBEntryFull::tlb_fill_flags"]
        [::std::mem::offset_of!(CPUTLBEntryFull, tlb_fill_flags) - 26usize];
    ["Offset of field: CPUTLBEntryFull::slow_flags"]
        [::std::mem::offset_of!(CPUTLBEntryFull, slow_flags) - 27usize];
    ["Offset of field: CPUTLBEntryFull::extra"]
        [::std::mem::offset_of!(CPUTLBEntryFull, extra) - 30usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CPUTLBDesc {
    pub large_page_addr: vaddr,
    pub large_page_mask: vaddr,
    pub window_begin_ns: i64,
    pub window_max_entries: usize,
    pub n_used_entries: usize,
    pub vindex: usize,
    pub vtable: [CPUTLBEntry; 8usize],
    pub vfulltlb: [CPUTLBEntryFull; 8usize],
    pub fulltlb: *mut CPUTLBEntryFull,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUTLBDesc"][::std::mem::size_of::<CPUTLBDesc>() - 632usize];
    ["Alignment of CPUTLBDesc"][::std::mem::align_of::<CPUTLBDesc>() - 8usize];
    ["Offset of field: CPUTLBDesc::large_page_addr"]
        [::std::mem::offset_of!(CPUTLBDesc, large_page_addr) - 0usize];
    ["Offset of field: CPUTLBDesc::large_page_mask"]
        [::std::mem::offset_of!(CPUTLBDesc, large_page_mask) - 8usize];
    ["Offset of field: CPUTLBDesc::window_begin_ns"]
        [::std::mem::offset_of!(CPUTLBDesc, window_begin_ns) - 16usize];
    ["Offset of field: CPUTLBDesc::window_max_entries"]
        [::std::mem::offset_of!(CPUTLBDesc, window_max_entries) - 24usize];
    ["Offset of field: CPUTLBDesc::n_used_entries"]
        [::std::mem::offset_of!(CPUTLBDesc, n_used_entries) - 32usize];
    ["Offset of field: CPUTLBDesc::vindex"][::std::mem::offset_of!(CPUTLBDesc, vindex) - 40usize];
    ["Offset of field: CPUTLBDesc::vtable"][::std::mem::offset_of!(CPUTLBDesc, vtable) - 48usize];
    ["Offset of field: CPUTLBDesc::vfulltlb"]
        [::std::mem::offset_of!(CPUTLBDesc, vfulltlb) - 304usize];
    ["Offset of field: CPUTLBDesc::fulltlb"]
        [::std::mem::offset_of!(CPUTLBDesc, fulltlb) - 624usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUTLBCommon {
    pub lock: QemuSpin,
    pub dirty: u16,
    pub full_flush_count: usize,
    pub part_flush_count: usize,
    pub elide_flush_count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUTLBCommon"][::std::mem::size_of::<CPUTLBCommon>() - 32usize];
    ["Alignment of CPUTLBCommon"][::std::mem::align_of::<CPUTLBCommon>() - 8usize];
    ["Offset of field: CPUTLBCommon::lock"][::std::mem::offset_of!(CPUTLBCommon, lock) - 0usize];
    ["Offset of field: CPUTLBCommon::dirty"][::std::mem::offset_of!(CPUTLBCommon, dirty) - 4usize];
    ["Offset of field: CPUTLBCommon::full_flush_count"]
        [::std::mem::offset_of!(CPUTLBCommon, full_flush_count) - 8usize];
    ["Offset of field: CPUTLBCommon::part_flush_count"]
        [::std::mem::offset_of!(CPUTLBCommon, part_flush_count) - 16usize];
    ["Offset of field: CPUTLBCommon::elide_flush_count"]
        [::std::mem::offset_of!(CPUTLBCommon, elide_flush_count) - 24usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct CPUTLB {
    pub c: CPUTLBCommon,
    pub d: [CPUTLBDesc; 16usize],
    pub f: [CPUTLBDescFast; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUTLB"][::std::mem::size_of::<CPUTLB>() - 10400usize];
    ["Alignment of CPUTLB"][::std::mem::align_of::<CPUTLB>() - 16usize];
    ["Offset of field: CPUTLB::c"][::std::mem::offset_of!(CPUTLB, c) - 0usize];
    ["Offset of field: CPUTLB::d"][::std::mem::offset_of!(CPUTLB, d) - 32usize];
    ["Offset of field: CPUTLB::f"][::std::mem::offset_of!(CPUTLB, f) - 10144usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union IcountDecr {
    pub u32_: u32,
    pub u16_: IcountDecr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IcountDecr__bindgen_ty_1 {
    pub low: u16,
    pub high: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IcountDecr__bindgen_ty_1"]
        [::std::mem::size_of::<IcountDecr__bindgen_ty_1>() - 4usize];
    ["Alignment of IcountDecr__bindgen_ty_1"]
        [::std::mem::align_of::<IcountDecr__bindgen_ty_1>() - 2usize];
    ["Offset of field: IcountDecr__bindgen_ty_1::low"]
        [::std::mem::offset_of!(IcountDecr__bindgen_ty_1, low) - 0usize];
    ["Offset of field: IcountDecr__bindgen_ty_1::high"]
        [::std::mem::offset_of!(IcountDecr__bindgen_ty_1, high) - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IcountDecr"][::std::mem::size_of::<IcountDecr>() - 4usize];
    ["Alignment of IcountDecr"][::std::mem::align_of::<IcountDecr>() - 4usize];
    ["Offset of field: IcountDecr::u32_"][::std::mem::offset_of!(IcountDecr, u32_) - 0usize];
    ["Offset of field: IcountDecr::u16_"][::std::mem::offset_of!(IcountDecr, u16_) - 0usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct CPUNegativeOffsetState {
    pub tlb: CPUTLB,
    pub plugin_mem_cbs: *mut GArray,
    pub plugin_mem_value_low: u64,
    pub plugin_mem_value_high: u64,
    pub icount_decr: IcountDecr,
    pub can_do_io: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUNegativeOffsetState"]
        [::std::mem::size_of::<CPUNegativeOffsetState>() - 10432usize];
    ["Alignment of CPUNegativeOffsetState"]
        [::std::mem::align_of::<CPUNegativeOffsetState>() - 16usize];
    ["Offset of field: CPUNegativeOffsetState::tlb"]
        [::std::mem::offset_of!(CPUNegativeOffsetState, tlb) - 0usize];
    ["Offset of field: CPUNegativeOffsetState::plugin_mem_cbs"]
        [::std::mem::offset_of!(CPUNegativeOffsetState, plugin_mem_cbs) - 10400usize];
    ["Offset of field: CPUNegativeOffsetState::plugin_mem_value_low"]
        [::std::mem::offset_of!(CPUNegativeOffsetState, plugin_mem_value_low) - 10408usize];
    ["Offset of field: CPUNegativeOffsetState::plugin_mem_value_high"]
        [::std::mem::offset_of!(CPUNegativeOffsetState, plugin_mem_value_high) - 10416usize];
    ["Offset of field: CPUNegativeOffsetState::icount_decr"]
        [::std::mem::offset_of!(CPUNegativeOffsetState, icount_decr) - 10424usize];
    ["Offset of field: CPUNegativeOffsetState::can_do_io"]
        [::std::mem::offset_of!(CPUNegativeOffsetState, can_do_io) - 10428usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KVMState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvm_run {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union run_on_cpu_data {
    pub host_int: ::std::os::raw::c_int,
    pub host_ulong: ::std::os::raw::c_ulong,
    pub host_ptr: *mut ::std::os::raw::c_void,
    pub target_ptr: vaddr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of run_on_cpu_data"][::std::mem::size_of::<run_on_cpu_data>() - 8usize];
    ["Alignment of run_on_cpu_data"][::std::mem::align_of::<run_on_cpu_data>() - 8usize];
    ["Offset of field: run_on_cpu_data::host_int"]
        [::std::mem::offset_of!(run_on_cpu_data, host_int) - 0usize];
    ["Offset of field: run_on_cpu_data::host_ulong"]
        [::std::mem::offset_of!(run_on_cpu_data, host_ulong) - 0usize];
    ["Offset of field: run_on_cpu_data::host_ptr"]
        [::std::mem::offset_of!(run_on_cpu_data, host_ptr) - 0usize];
    ["Offset of field: run_on_cpu_data::target_ptr"]
        [::std::mem::offset_of!(run_on_cpu_data, target_ptr) - 0usize];
};
pub type run_on_cpu_func =
    ::std::option::Option<unsafe extern "C" fn(cpu: *mut CPUState, data: run_on_cpu_data)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_work_item {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(16))]
pub struct CPUState {
    pub parent_obj: DeviceState,
    pub cc: *mut CPUClass,
    pub nr_threads: ::std::os::raw::c_int,
    pub thread: *mut QemuThread,
    pub thread_id: ::std::os::raw::c_int,
    pub running: bool,
    pub has_waiter: bool,
    pub halt_cond: *mut QemuCond,
    pub thread_kicked: bool,
    pub created: bool,
    pub stop: bool,
    pub stopped: bool,
    pub start_powered_off: bool,
    pub unplug: bool,
    pub crash_occurred: bool,
    pub exit_request: bool,
    pub exclusive_context_count: ::std::os::raw::c_int,
    pub cflags_next_tb: u32,
    pub interrupt_request: u32,
    pub singlestep_enabled: ::std::os::raw::c_int,
    pub icount_budget: i64,
    pub icount_extra: i64,
    pub random_seed: u64,
    pub jmp_env: sigjmp_buf,
    pub work_mutex: QemuMutex,
    pub work_list: CPUState__bindgen_ty_1,
    pub cpu_ases: *mut CPUAddressSpace,
    pub cpu_ases_count: ::std::os::raw::c_int,
    pub num_ases: ::std::os::raw::c_int,
    pub as_: *mut AddressSpace,
    pub memory: *mut MemoryRegion,
    pub tb_jmp_cache: *mut CPUJumpCache,
    pub gdb_regs: *mut GArray,
    pub gdb_num_regs: ::std::os::raw::c_int,
    pub gdb_num_g_regs: ::std::os::raw::c_int,
    pub node: CPUState__bindgen_ty_2,
    pub breakpoints: CPUState__bindgen_ty_3,
    pub watchpoints: CPUState__bindgen_ty_4,
    pub watchpoint_hit: *mut CPUWatchpoint,
    pub opaque: *mut ::std::os::raw::c_void,
    pub mem_io_pc: usize,
    pub kvm_fd: ::std::os::raw::c_int,
    pub kvm_state: *mut KVMState,
    pub kvm_run: *mut kvm_run,
    pub kvm_dirty_gfns: *mut kvm_dirty_gfn,
    pub kvm_fetch_index: u32,
    pub dirty_pages: u64,
    pub kvm_vcpu_stats_fd: ::std::os::raw::c_int,
    pub vcpu_dirty: bool,
    pub in_ioctl_lock: QemuLockCnt,
    pub plugin_state: *mut CPUPluginState,
    pub cpu_index: ::std::os::raw::c_int,
    pub cluster_index: ::std::os::raw::c_int,
    pub tcg_cflags: u32,
    pub halted: u32,
    pub exception_index: i32,
    pub accel: *mut AccelCPUState,
    pub throttle_thread_scheduled: bool,
    pub throttle_us_per_full: i64,
    pub ignore_memory_transaction_failures: bool,
    pub prctl_unalign_sigbus: bool,
    pub iommu_notifiers: *mut GArray,
    pub neg_align: __IncompleteArrayField<::std::os::raw::c_char>,
    pub neg: CPUNegativeOffsetState,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUState__bindgen_ty_1 {
    pub sqh_first: *mut qemu_work_item,
    pub sqh_last: *mut *mut qemu_work_item,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUState__bindgen_ty_1"][::std::mem::size_of::<CPUState__bindgen_ty_1>() - 16usize];
    ["Alignment of CPUState__bindgen_ty_1"]
        [::std::mem::align_of::<CPUState__bindgen_ty_1>() - 8usize];
    ["Offset of field: CPUState__bindgen_ty_1::sqh_first"]
        [::std::mem::offset_of!(CPUState__bindgen_ty_1, sqh_first) - 0usize];
    ["Offset of field: CPUState__bindgen_ty_1::sqh_last"]
        [::std::mem::offset_of!(CPUState__bindgen_ty_1, sqh_last) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUState__bindgen_ty_2 {
    pub tqe_next: *mut CPUState,
    pub tqe_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUState__bindgen_ty_2"][::std::mem::size_of::<CPUState__bindgen_ty_2>() - 16usize];
    ["Alignment of CPUState__bindgen_ty_2"]
        [::std::mem::align_of::<CPUState__bindgen_ty_2>() - 8usize];
    ["Offset of field: CPUState__bindgen_ty_2::tqe_next"]
        [::std::mem::offset_of!(CPUState__bindgen_ty_2, tqe_next) - 0usize];
    ["Offset of field: CPUState__bindgen_ty_2::tqe_circ"]
        [::std::mem::offset_of!(CPUState__bindgen_ty_2, tqe_circ) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUState__bindgen_ty_3 {
    pub tqh_first: *mut CPUBreakpoint,
    pub tqh_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUState__bindgen_ty_3"][::std::mem::size_of::<CPUState__bindgen_ty_3>() - 16usize];
    ["Alignment of CPUState__bindgen_ty_3"]
        [::std::mem::align_of::<CPUState__bindgen_ty_3>() - 8usize];
    ["Offset of field: CPUState__bindgen_ty_3::tqh_first"]
        [::std::mem::offset_of!(CPUState__bindgen_ty_3, tqh_first) - 0usize];
    ["Offset of field: CPUState__bindgen_ty_3::tqh_circ"]
        [::std::mem::offset_of!(CPUState__bindgen_ty_3, tqh_circ) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUState__bindgen_ty_4 {
    pub tqh_first: *mut CPUWatchpoint,
    pub tqh_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUState__bindgen_ty_4"][::std::mem::size_of::<CPUState__bindgen_ty_4>() - 16usize];
    ["Alignment of CPUState__bindgen_ty_4"]
        [::std::mem::align_of::<CPUState__bindgen_ty_4>() - 8usize];
    ["Offset of field: CPUState__bindgen_ty_4::tqh_first"]
        [::std::mem::offset_of!(CPUState__bindgen_ty_4, tqh_first) - 0usize];
    ["Offset of field: CPUState__bindgen_ty_4::tqh_circ"]
        [::std::mem::offset_of!(CPUState__bindgen_ty_4, tqh_circ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUState"][::std::mem::size_of::<CPUState>() - 11200usize];
    ["Alignment of CPUState"][::std::mem::align_of::<CPUState>() - 16usize];
    ["Offset of field: CPUState::parent_obj"]
        [::std::mem::offset_of!(CPUState, parent_obj) - 0usize];
    ["Offset of field: CPUState::cc"][::std::mem::offset_of!(CPUState, cc) - 152usize];
    ["Offset of field: CPUState::nr_threads"]
        [::std::mem::offset_of!(CPUState, nr_threads) - 160usize];
    ["Offset of field: CPUState::thread"][::std::mem::offset_of!(CPUState, thread) - 168usize];
    ["Offset of field: CPUState::thread_id"]
        [::std::mem::offset_of!(CPUState, thread_id) - 176usize];
    ["Offset of field: CPUState::running"][::std::mem::offset_of!(CPUState, running) - 180usize];
    ["Offset of field: CPUState::has_waiter"]
        [::std::mem::offset_of!(CPUState, has_waiter) - 181usize];
    ["Offset of field: CPUState::halt_cond"]
        [::std::mem::offset_of!(CPUState, halt_cond) - 184usize];
    ["Offset of field: CPUState::thread_kicked"]
        [::std::mem::offset_of!(CPUState, thread_kicked) - 192usize];
    ["Offset of field: CPUState::created"][::std::mem::offset_of!(CPUState, created) - 193usize];
    ["Offset of field: CPUState::stop"][::std::mem::offset_of!(CPUState, stop) - 194usize];
    ["Offset of field: CPUState::stopped"][::std::mem::offset_of!(CPUState, stopped) - 195usize];
    ["Offset of field: CPUState::start_powered_off"]
        [::std::mem::offset_of!(CPUState, start_powered_off) - 196usize];
    ["Offset of field: CPUState::unplug"][::std::mem::offset_of!(CPUState, unplug) - 197usize];
    ["Offset of field: CPUState::crash_occurred"]
        [::std::mem::offset_of!(CPUState, crash_occurred) - 198usize];
    ["Offset of field: CPUState::exit_request"]
        [::std::mem::offset_of!(CPUState, exit_request) - 199usize];
    ["Offset of field: CPUState::exclusive_context_count"]
        [::std::mem::offset_of!(CPUState, exclusive_context_count) - 200usize];
    ["Offset of field: CPUState::cflags_next_tb"]
        [::std::mem::offset_of!(CPUState, cflags_next_tb) - 204usize];
    ["Offset of field: CPUState::interrupt_request"]
        [::std::mem::offset_of!(CPUState, interrupt_request) - 208usize];
    ["Offset of field: CPUState::singlestep_enabled"]
        [::std::mem::offset_of!(CPUState, singlestep_enabled) - 212usize];
    ["Offset of field: CPUState::icount_budget"]
        [::std::mem::offset_of!(CPUState, icount_budget) - 216usize];
    ["Offset of field: CPUState::icount_extra"]
        [::std::mem::offset_of!(CPUState, icount_extra) - 224usize];
    ["Offset of field: CPUState::random_seed"]
        [::std::mem::offset_of!(CPUState, random_seed) - 232usize];
    ["Offset of field: CPUState::jmp_env"][::std::mem::offset_of!(CPUState, jmp_env) - 240usize];
    ["Offset of field: CPUState::work_mutex"]
        [::std::mem::offset_of!(CPUState, work_mutex) - 440usize];
    ["Offset of field: CPUState::work_list"]
        [::std::mem::offset_of!(CPUState, work_list) - 488usize];
    ["Offset of field: CPUState::cpu_ases"][::std::mem::offset_of!(CPUState, cpu_ases) - 504usize];
    ["Offset of field: CPUState::cpu_ases_count"]
        [::std::mem::offset_of!(CPUState, cpu_ases_count) - 512usize];
    ["Offset of field: CPUState::num_ases"][::std::mem::offset_of!(CPUState, num_ases) - 516usize];
    ["Offset of field: CPUState::as_"][::std::mem::offset_of!(CPUState, as_) - 520usize];
    ["Offset of field: CPUState::memory"][::std::mem::offset_of!(CPUState, memory) - 528usize];
    ["Offset of field: CPUState::tb_jmp_cache"]
        [::std::mem::offset_of!(CPUState, tb_jmp_cache) - 536usize];
    ["Offset of field: CPUState::gdb_regs"][::std::mem::offset_of!(CPUState, gdb_regs) - 544usize];
    ["Offset of field: CPUState::gdb_num_regs"]
        [::std::mem::offset_of!(CPUState, gdb_num_regs) - 552usize];
    ["Offset of field: CPUState::gdb_num_g_regs"]
        [::std::mem::offset_of!(CPUState, gdb_num_g_regs) - 556usize];
    ["Offset of field: CPUState::node"][::std::mem::offset_of!(CPUState, node) - 560usize];
    ["Offset of field: CPUState::breakpoints"]
        [::std::mem::offset_of!(CPUState, breakpoints) - 576usize];
    ["Offset of field: CPUState::watchpoints"]
        [::std::mem::offset_of!(CPUState, watchpoints) - 592usize];
    ["Offset of field: CPUState::watchpoint_hit"]
        [::std::mem::offset_of!(CPUState, watchpoint_hit) - 608usize];
    ["Offset of field: CPUState::opaque"][::std::mem::offset_of!(CPUState, opaque) - 616usize];
    ["Offset of field: CPUState::mem_io_pc"]
        [::std::mem::offset_of!(CPUState, mem_io_pc) - 624usize];
    ["Offset of field: CPUState::kvm_fd"][::std::mem::offset_of!(CPUState, kvm_fd) - 632usize];
    ["Offset of field: CPUState::kvm_state"]
        [::std::mem::offset_of!(CPUState, kvm_state) - 640usize];
    ["Offset of field: CPUState::kvm_run"][::std::mem::offset_of!(CPUState, kvm_run) - 648usize];
    ["Offset of field: CPUState::kvm_dirty_gfns"]
        [::std::mem::offset_of!(CPUState, kvm_dirty_gfns) - 656usize];
    ["Offset of field: CPUState::kvm_fetch_index"]
        [::std::mem::offset_of!(CPUState, kvm_fetch_index) - 664usize];
    ["Offset of field: CPUState::dirty_pages"]
        [::std::mem::offset_of!(CPUState, dirty_pages) - 672usize];
    ["Offset of field: CPUState::kvm_vcpu_stats_fd"]
        [::std::mem::offset_of!(CPUState, kvm_vcpu_stats_fd) - 680usize];
    ["Offset of field: CPUState::vcpu_dirty"]
        [::std::mem::offset_of!(CPUState, vcpu_dirty) - 684usize];
    ["Offset of field: CPUState::in_ioctl_lock"]
        [::std::mem::offset_of!(CPUState, in_ioctl_lock) - 688usize];
    ["Offset of field: CPUState::plugin_state"]
        [::std::mem::offset_of!(CPUState, plugin_state) - 696usize];
    ["Offset of field: CPUState::cpu_index"]
        [::std::mem::offset_of!(CPUState, cpu_index) - 704usize];
    ["Offset of field: CPUState::cluster_index"]
        [::std::mem::offset_of!(CPUState, cluster_index) - 708usize];
    ["Offset of field: CPUState::tcg_cflags"]
        [::std::mem::offset_of!(CPUState, tcg_cflags) - 712usize];
    ["Offset of field: CPUState::halted"][::std::mem::offset_of!(CPUState, halted) - 716usize];
    ["Offset of field: CPUState::exception_index"]
        [::std::mem::offset_of!(CPUState, exception_index) - 720usize];
    ["Offset of field: CPUState::accel"][::std::mem::offset_of!(CPUState, accel) - 728usize];
    ["Offset of field: CPUState::throttle_thread_scheduled"]
        [::std::mem::offset_of!(CPUState, throttle_thread_scheduled) - 736usize];
    ["Offset of field: CPUState::throttle_us_per_full"]
        [::std::mem::offset_of!(CPUState, throttle_us_per_full) - 744usize];
    ["Offset of field: CPUState::ignore_memory_transaction_failures"]
        [::std::mem::offset_of!(CPUState, ignore_memory_transaction_failures) - 752usize];
    ["Offset of field: CPUState::prctl_unalign_sigbus"]
        [::std::mem::offset_of!(CPUState, prctl_unalign_sigbus) - 753usize];
    ["Offset of field: CPUState::iommu_notifiers"]
        [::std::mem::offset_of!(CPUState, iommu_notifiers) - 760usize];
    ["Offset of field: CPUState::neg_align"]
        [::std::mem::offset_of!(CPUState, neg_align) - 768usize];
    ["Offset of field: CPUState::neg"][::std::mem::offset_of!(CPUState, neg) - 768usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUTailQ {
    pub tqh_first: *mut CPUState,
    pub tqh_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUTailQ"][::std::mem::size_of::<CPUTailQ>() - 16usize];
    ["Alignment of CPUTailQ"][::std::mem::align_of::<CPUTailQ>() - 8usize];
    ["Offset of field: CPUTailQ::tqh_first"][::std::mem::offset_of!(CPUTailQ, tqh_first) - 0usize];
    ["Offset of field: CPUTailQ::tqh_circ"][::std::mem::offset_of!(CPUTailQ, tqh_circ) - 0usize];
};
unsafe extern "C" {
    pub static mut cpus_queue: CPUTailQ;
}
unsafe extern "C" {
    pub static mut current_cpu: *mut CPUState;
}
unsafe extern "C" {
    pub static mut mttcg_enabled: bool;
}
unsafe extern "C" {
    pub fn cpu_paging_enabled(cpu: *const CPUState) -> bool;
}
unsafe extern "C" {
    pub fn cpu_get_memory_mapping(
        cpu: *mut CPUState,
        list: *mut MemoryMappingList,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn cpu_write_elf64_note(
        f: WriteCoreDumpFunction,
        cpu: *mut CPUState,
        cpuid: ::std::os::raw::c_int,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cpu_write_elf64_qemunote(
        f: WriteCoreDumpFunction,
        cpu: *mut CPUState,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cpu_write_elf32_note(
        f: WriteCoreDumpFunction,
        cpu: *mut CPUState,
        cpuid: ::std::os::raw::c_int,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cpu_write_elf32_qemunote(
        f: WriteCoreDumpFunction,
        cpu: *mut CPUState,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cpu_get_crash_info(cpu: *mut CPUState) -> *mut GuestPanicInformation;
}
pub const CPU_DUMP_CODE: CPUDumpFlags = 65536;
pub const CPU_DUMP_FPU: CPUDumpFlags = 131072;
pub const CPU_DUMP_CCOP: CPUDumpFlags = 262144;
pub const CPU_DUMP_VPU: CPUDumpFlags = 524288;
pub type CPUDumpFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn cpu_dump_state(cpu: *mut CPUState, f: *mut FILE, flags: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn cpu_get_phys_page_attrs_debug(
        cpu: *mut CPUState,
        addr: vaddr,
        attrs: *mut MemTxAttrs,
    ) -> hwaddr;
}
unsafe extern "C" {
    pub fn cpu_get_phys_page_debug(cpu: *mut CPUState, addr: vaddr) -> hwaddr;
}
unsafe extern "C" {
    pub fn cpu_asidx_from_attrs(cpu: *mut CPUState, attrs: MemTxAttrs) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cpu_virtio_is_big_endian(cpu: *mut CPUState) -> bool;
}
unsafe extern "C" {
    pub fn cpu_list_add(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn cpu_list_remove(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn cpu_reset(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn cpu_class_by_name(
        typename: *const ::std::os::raw::c_char,
        cpu_model: *const ::std::os::raw::c_char,
    ) -> *mut ObjectClass;
}
unsafe extern "C" {
    pub fn cpu_model_from_type(
        typename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn cpu_create(typename: *const ::std::os::raw::c_char) -> *mut CPUState;
}
unsafe extern "C" {
    pub fn parse_cpu_option(
        cpu_option: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qemu_cpu_is_self(cpu: *mut CPUState) -> bool;
}
unsafe extern "C" {
    pub fn qemu_cpu_kick(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn cpu_is_stopped(cpu: *mut CPUState) -> bool;
}
unsafe extern "C" {
    pub fn do_run_on_cpu(
        cpu: *mut CPUState,
        func: run_on_cpu_func,
        data: run_on_cpu_data,
        mutex: *mut QemuMutex,
    );
}
unsafe extern "C" {
    pub fn run_on_cpu(cpu: *mut CPUState, func: run_on_cpu_func, data: run_on_cpu_data);
}
unsafe extern "C" {
    pub fn async_run_on_cpu(cpu: *mut CPUState, func: run_on_cpu_func, data: run_on_cpu_data);
}
unsafe extern "C" {
    pub fn async_safe_run_on_cpu(cpu: *mut CPUState, func: run_on_cpu_func, data: run_on_cpu_data);
}
unsafe extern "C" {
    pub fn qemu_get_cpu(index: ::std::os::raw::c_int) -> *mut CPUState;
}
unsafe extern "C" {
    pub fn cpu_exists(id: i64) -> bool;
}
unsafe extern "C" {
    pub fn cpu_by_arch_id(id: i64) -> *mut CPUState;
}
unsafe extern "C" {
    pub fn cpu_interrupt(cpu: *mut CPUState, mask: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn cpu_reset_interrupt(cpu: *mut CPUState, mask: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn cpu_exit(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn cpu_pause(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn cpu_resume(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn cpu_remove_sync(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn free_queued_cpu_work(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn process_queued_cpu_work(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn cpu_exec_start(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn cpu_exec_end(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn start_exclusive();
}
unsafe extern "C" {
    pub fn end_exclusive();
}
unsafe extern "C" {
    pub fn qemu_init_vcpu(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn cpu_single_step(cpu: *mut CPUState, enabled: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn cpu_breakpoint_insert(
        cpu: *mut CPUState,
        pc: vaddr,
        flags: ::std::os::raw::c_int,
        breakpoint: *mut *mut CPUBreakpoint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cpu_breakpoint_remove(
        cpu: *mut CPUState,
        pc: vaddr,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cpu_breakpoint_remove_by_ref(cpu: *mut CPUState, breakpoint: *mut CPUBreakpoint);
}
unsafe extern "C" {
    pub fn cpu_breakpoint_remove_all(cpu: *mut CPUState, mask: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn cpu_watchpoint_insert(
        cpu: *mut CPUState,
        addr: vaddr,
        len: vaddr,
        flags: ::std::os::raw::c_int,
        watchpoint: *mut *mut CPUWatchpoint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cpu_watchpoint_remove(
        cpu: *mut CPUState,
        addr: vaddr,
        len: vaddr,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cpu_watchpoint_remove_by_ref(cpu: *mut CPUState, watchpoint: *mut CPUWatchpoint);
}
unsafe extern "C" {
    pub fn cpu_watchpoint_remove_all(cpu: *mut CPUState, mask: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn cpu_get_address_space(
        cpu: *mut CPUState,
        asidx: ::std::os::raw::c_int,
    ) -> *mut AddressSpace;
}
unsafe extern "C" {
    pub fn cpu_abort(cpu: *mut CPUState, fmt: *const ::std::os::raw::c_char, ...) -> !;
}
unsafe extern "C" {
    pub fn cpu_class_init_props(dc: *mut DeviceClass);
}
unsafe extern "C" {
    pub fn cpu_exec_initfn(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn cpu_exec_realizefn(cpu: *mut CPUState, errp: *mut *mut Error) -> bool;
}
unsafe extern "C" {
    pub fn cpu_exec_unrealizefn(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn cpu_exec_reset_hold(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn target_name() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static vmstate_cpu_common: VMStateDescription;
}
unsafe extern "C" {
    pub fn cpu_exec_init_all();
}
unsafe extern "C" {
    pub fn cpu_exec_step_atomic(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub static mut qemu_cpu_list_lock: QemuMutex;
}
unsafe extern "C" {
    pub fn qemu_init_cpu_list();
}
unsafe extern "C" {
    pub fn cpu_list_lock();
}
unsafe extern "C" {
    pub fn cpu_list_unlock();
}
unsafe extern "C" {
    pub fn cpu_list_generation_id_get() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn cpu_get_free_index() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tcg_iommu_init_notifier_list(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn tcg_iommu_free_notifier_list(cpu: *mut CPUState);
}
pub const DEVICE_NATIVE_ENDIAN: device_endian = 0;
pub const DEVICE_BIG_ENDIAN: device_endian = 1;
pub const DEVICE_LITTLE_ENDIAN: device_endian = 2;
pub type device_endian = ::std::os::raw::c_uint;
pub type ram_addr_t = u64;
unsafe extern "C" {
    pub fn qemu_ram_remap(addr: ram_addr_t, length: ram_addr_t);
}
unsafe extern "C" {
    pub fn qemu_ram_addr_from_host(ptr: *mut ::std::os::raw::c_void) -> ram_addr_t;
}
unsafe extern "C" {
    pub fn qemu_ram_addr_from_host_nofail(ptr: *mut ::std::os::raw::c_void) -> ram_addr_t;
}
unsafe extern "C" {
    pub fn qemu_ram_block_by_name(name: *const ::std::os::raw::c_char) -> *mut RAMBlock;
}
unsafe extern "C" {
    pub fn qemu_ram_block_from_host(
        ptr: *mut ::std::os::raw::c_void,
        round_offset: bool,
        offset: *mut ram_addr_t,
    ) -> *mut RAMBlock;
}
unsafe extern "C" {
    pub fn qemu_ram_block_host_offset(
        rb: *mut RAMBlock,
        host: *mut ::std::os::raw::c_void,
    ) -> ram_addr_t;
}
unsafe extern "C" {
    pub fn qemu_ram_set_idstr(
        block: *mut RAMBlock,
        name: *const ::std::os::raw::c_char,
        dev: *mut DeviceState,
    );
}
unsafe extern "C" {
    pub fn qemu_ram_unset_idstr(block: *mut RAMBlock);
}
unsafe extern "C" {
    pub fn qemu_ram_get_idstr(rb: *mut RAMBlock) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qemu_ram_get_host_addr(rb: *mut RAMBlock) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qemu_ram_get_offset(rb: *mut RAMBlock) -> ram_addr_t;
}
unsafe extern "C" {
    pub fn qemu_ram_get_used_length(rb: *mut RAMBlock) -> ram_addr_t;
}
unsafe extern "C" {
    pub fn qemu_ram_get_max_length(rb: *mut RAMBlock) -> ram_addr_t;
}
unsafe extern "C" {
    pub fn qemu_ram_is_shared(rb: *mut RAMBlock) -> bool;
}
unsafe extern "C" {
    pub fn qemu_ram_is_noreserve(rb: *mut RAMBlock) -> bool;
}
unsafe extern "C" {
    pub fn qemu_ram_is_uf_zeroable(rb: *mut RAMBlock) -> bool;
}
unsafe extern "C" {
    pub fn qemu_ram_set_uf_zeroable(rb: *mut RAMBlock);
}
unsafe extern "C" {
    pub fn qemu_ram_is_migratable(rb: *mut RAMBlock) -> bool;
}
unsafe extern "C" {
    pub fn qemu_ram_set_migratable(rb: *mut RAMBlock);
}
unsafe extern "C" {
    pub fn qemu_ram_unset_migratable(rb: *mut RAMBlock);
}
unsafe extern "C" {
    pub fn qemu_ram_is_named_file(rb: *mut RAMBlock) -> bool;
}
unsafe extern "C" {
    pub fn qemu_ram_get_fd(rb: *mut RAMBlock) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_ram_pagesize(block: *mut RAMBlock) -> usize;
}
unsafe extern "C" {
    pub fn qemu_ram_pagesize_largest() -> usize;
}
unsafe extern "C" {
    pub fn cpu_address_space_init(
        cpu: *mut CPUState,
        asidx: ::std::os::raw::c_int,
        prefix: *const ::std::os::raw::c_char,
        mr: *mut MemoryRegion,
    );
}
unsafe extern "C" {
    pub fn cpu_address_space_destroy(cpu: *mut CPUState, asidx: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn cpu_physical_memory_rw(
        addr: hwaddr,
        buf: *mut ::std::os::raw::c_void,
        len: hwaddr,
        is_write: bool,
    );
}
unsafe extern "C" {
    pub fn cpu_physical_memory_map(
        addr: hwaddr,
        plen: *mut hwaddr,
        is_write: bool,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn cpu_physical_memory_unmap(
        buffer: *mut ::std::os::raw::c_void,
        len: hwaddr,
        is_write: bool,
        access_len: hwaddr,
    );
}
unsafe extern "C" {
    pub fn cpu_physical_memory_is_io(phys_addr: hwaddr) -> bool;
}
unsafe extern "C" {
    pub fn qemu_flush_coalesced_mmio_buffer();
}
unsafe extern "C" {
    pub fn cpu_flush_icache_range(start: hwaddr, len: hwaddr);
}
pub type RAMBlockIterFunc = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut RAMBlock,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn qemu_ram_foreach_block(
        func: RAMBlockIterFunc,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ram_block_discard_range(
        rb: *mut RAMBlock,
        start: u64,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ram_block_discard_guest_memfd_range(
        rb: *mut RAMBlock,
        start: u64,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cpu_memory_rw_debug(
        cpu: *mut CPUState,
        addr: vaddr,
        ptr: *mut ::std::os::raw::c_void,
        len: usize,
        is_write: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn list_cpus();
}
unsafe extern "C" {
    pub fn cpu_unwind_state_data(cpu: *mut CPUState, host_pc: usize, data: *mut u64) -> bool;
}
unsafe extern "C" {
    pub fn cpu_restore_state(cpu: *mut CPUState, host_pc: usize) -> bool;
}
unsafe extern "C" {
    pub fn cpu_loop_exit_noexc(cpu: *mut CPUState) -> !;
}
unsafe extern "C" {
    pub fn cpu_loop_exit_atomic(cpu: *mut CPUState, pc: usize) -> !;
}
unsafe extern "C" {
    pub fn cpu_loop_exit(cpu: *mut CPUState) -> !;
}
unsafe extern "C" {
    pub fn cpu_loop_exit_restore(cpu: *mut CPUState, pc: usize) -> !;
}
unsafe extern "C" {
    pub fn cpu_exec(cpu: *mut CPUState) -> ::std::os::raw::c_int;
}
pub type target_long = i32;
pub type target_ulong = u32;
unsafe extern "C" {
    pub fn runstate_check(state: RunState) -> bool;
}
unsafe extern "C" {
    pub fn runstate_set(new_state: RunState);
}
unsafe extern "C" {
    pub fn runstate_get() -> RunState;
}
unsafe extern "C" {
    pub fn runstate_is_running() -> bool;
}
unsafe extern "C" {
    pub fn runstate_needs_reset() -> bool;
}
unsafe extern "C" {
    pub fn runstate_replay_enable();
}
pub type VMChangeStateHandler = ::std::option::Option<
    unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, running: bool, state: RunState),
>;
unsafe extern "C" {
    pub fn qemu_add_vm_change_state_handler(
        cb: VMChangeStateHandler,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut VMChangeStateEntry;
}
unsafe extern "C" {
    pub fn qemu_add_vm_change_state_handler_prio(
        cb: VMChangeStateHandler,
        opaque: *mut ::std::os::raw::c_void,
        priority: ::std::os::raw::c_int,
    ) -> *mut VMChangeStateEntry;
}
unsafe extern "C" {
    pub fn qemu_add_vm_change_state_handler_prio_full(
        cb: VMChangeStateHandler,
        prepare_cb: VMChangeStateHandler,
        opaque: *mut ::std::os::raw::c_void,
        priority: ::std::os::raw::c_int,
    ) -> *mut VMChangeStateEntry;
}
unsafe extern "C" {
    pub fn qdev_add_vm_change_state_handler(
        dev: *mut DeviceState,
        cb: VMChangeStateHandler,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut VMChangeStateEntry;
}
unsafe extern "C" {
    pub fn qdev_add_vm_change_state_handler_full(
        dev: *mut DeviceState,
        cb: VMChangeStateHandler,
        prepare_cb: VMChangeStateHandler,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut VMChangeStateEntry;
}
unsafe extern "C" {
    pub fn qemu_del_vm_change_state_handler(e: *mut VMChangeStateEntry);
}
unsafe extern "C" {
    pub fn vm_state_notify(running: bool, state: RunState);
}
unsafe extern "C" {
    pub fn vm_start();
}
unsafe extern "C" {
    pub fn vm_prepare_start(step_pending: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vm_resume(state: RunState);
}
unsafe extern "C" {
    pub fn vm_stop(state: RunState) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vm_stop_force_state(state: RunState) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vm_shutdown() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vm_set_suspended(suspended: bool);
}
unsafe extern "C" {
    pub fn vm_get_suspended() -> bool;
}
pub const QEMU_WAKEUP_REASON_NONE: WakeupReason = 0;
pub const QEMU_WAKEUP_REASON_RTC: WakeupReason = 1;
pub const QEMU_WAKEUP_REASON_PMTIMER: WakeupReason = 2;
pub const QEMU_WAKEUP_REASON_OTHER: WakeupReason = 3;
pub type WakeupReason = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn qemu_system_reset_request(reason: ShutdownCause);
}
unsafe extern "C" {
    pub fn qemu_system_suspend_request();
}
unsafe extern "C" {
    pub fn qemu_register_suspend_notifier(notifier: *mut Notifier);
}
unsafe extern "C" {
    pub fn qemu_wakeup_suspend_enabled() -> bool;
}
unsafe extern "C" {
    pub fn qemu_system_wakeup_request(reason: WakeupReason, errp: *mut *mut Error);
}
unsafe extern "C" {
    pub fn qemu_system_wakeup_enable(reason: WakeupReason, enabled: bool);
}
unsafe extern "C" {
    pub fn qemu_register_wakeup_notifier(notifier: *mut Notifier);
}
unsafe extern "C" {
    pub fn qemu_register_wakeup_support();
}
unsafe extern "C" {
    pub fn qemu_system_shutdown_request_with_code(
        reason: ShutdownCause,
        exit_code: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn qemu_system_shutdown_request(reason: ShutdownCause);
}
unsafe extern "C" {
    pub fn qemu_system_powerdown_request();
}
unsafe extern "C" {
    pub fn qemu_register_powerdown_notifier(notifier: *mut Notifier);
}
unsafe extern "C" {
    pub fn qemu_register_shutdown_notifier(notifier: *mut Notifier);
}
unsafe extern "C" {
    pub fn qemu_system_debug_request();
}
unsafe extern "C" {
    pub fn qemu_system_vmstop_request(reason: RunState);
}
unsafe extern "C" {
    pub fn qemu_system_vmstop_request_prepare();
}
unsafe extern "C" {
    pub fn qemu_vmstop_requested(r: *mut RunState) -> bool;
}
unsafe extern "C" {
    pub fn qemu_shutdown_requested_get() -> ShutdownCause;
}
unsafe extern "C" {
    pub fn qemu_reset_requested_get() -> ShutdownCause;
}
unsafe extern "C" {
    pub fn qemu_system_killed(signal: ::std::os::raw::c_int, pid: pid_t);
}
unsafe extern "C" {
    pub fn qemu_system_reset(reason: ShutdownCause);
}
unsafe extern "C" {
    pub fn qemu_system_guest_panicked(info: *mut GuestPanicInformation);
}
unsafe extern "C" {
    pub fn qemu_system_guest_crashloaded(info: *mut GuestPanicInformation);
}
unsafe extern "C" {
    pub fn qemu_system_guest_pvshutdown();
}
unsafe extern "C" {
    pub fn qemu_system_dump_in_progress() -> bool;
}
pub const QEMU_ARCH_ALL: _bindgen_ty_38 = -1;
pub const QEMU_ARCH_ALPHA: _bindgen_ty_38 = 1;
pub const QEMU_ARCH_ARM: _bindgen_ty_38 = 2;
pub const QEMU_ARCH_I386: _bindgen_ty_38 = 8;
pub const QEMU_ARCH_M68K: _bindgen_ty_38 = 16;
pub const QEMU_ARCH_MICROBLAZE: _bindgen_ty_38 = 64;
pub const QEMU_ARCH_MIPS: _bindgen_ty_38 = 128;
pub const QEMU_ARCH_PPC: _bindgen_ty_38 = 256;
pub const QEMU_ARCH_S390X: _bindgen_ty_38 = 512;
pub const QEMU_ARCH_SH4: _bindgen_ty_38 = 1024;
pub const QEMU_ARCH_SPARC: _bindgen_ty_38 = 2048;
pub const QEMU_ARCH_XTENSA: _bindgen_ty_38 = 4096;
pub const QEMU_ARCH_OPENRISC: _bindgen_ty_38 = 8192;
pub const QEMU_ARCH_TRICORE: _bindgen_ty_38 = 65536;
pub const QEMU_ARCH_HPPA: _bindgen_ty_38 = 262144;
pub const QEMU_ARCH_RISCV: _bindgen_ty_38 = 524288;
pub const QEMU_ARCH_RX: _bindgen_ty_38 = 1048576;
pub const QEMU_ARCH_AVR: _bindgen_ty_38 = 2097152;
pub const QEMU_ARCH_HEXAGON: _bindgen_ty_38 = 4194304;
pub const QEMU_ARCH_LOONGARCH: _bindgen_ty_38 = 8388608;
pub type _bindgen_ty_38 = ::std::os::raw::c_int;
unsafe extern "C" {
    pub static arch_type: u32;
}
unsafe extern "C" {
    pub fn qemu_init_arch_modules();
}
pub type QEMUConfigCB = ::std::option::Option<
    unsafe extern "C" fn(
        group: *const ::std::os::raw::c_char,
        qdict: *mut QDict,
        opaque: *mut ::std::os::raw::c_void,
        errp: *mut *mut Error,
    ),
>;
unsafe extern "C" {
    pub fn qemu_load_module_for_opts(group: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn qemu_find_opts(group: *const ::std::os::raw::c_char) -> *mut QemuOptsList;
}
unsafe extern "C" {
    pub fn qemu_find_opts_err(
        group: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> *mut QemuOptsList;
}
unsafe extern "C" {
    pub fn qemu_find_opts_singleton(group: *const ::std::os::raw::c_char) -> *mut QemuOpts;
}
unsafe extern "C" {
    pub static mut vm_config_groups: [*mut QemuOptsList; 0usize];
}
unsafe extern "C" {
    pub static mut drive_config_groups: [*mut QemuOptsList; 0usize];
}
unsafe extern "C" {
    pub fn qemu_add_opts(list: *mut QemuOptsList);
}
unsafe extern "C" {
    pub fn qemu_add_drive_opts(list: *mut QemuOptsList);
}
unsafe extern "C" {
    pub fn qemu_global_option(str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_config_parse(
        fp: *mut FILE,
        lists: *mut *mut QemuOptsList,
        fname: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_config_do_parse(
        group: *const ::std::os::raw::c_char,
        qdict: *mut QDict,
        opaque: *mut ::std::os::raw::c_void,
        errp: *mut *mut Error,
    );
}
unsafe extern "C" {
    pub fn qemu_read_config_file(
        filename: *const ::std::os::raw::c_char,
        f: QEMUConfigCB,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_config_parse_qdict(
        options: *mut QDict,
        lists: *mut *mut QemuOptsList,
        errp: *mut *mut Error,
    ) -> bool;
}
pub type qemu_plugin_id_t = u64;
unsafe extern "C" {
    pub static mut qemu_plugin_version: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qemu_info_t {
    pub target_name: *const ::std::os::raw::c_char,
    pub version: qemu_info_t__bindgen_ty_1,
    pub system_emulation: bool,
    pub __bindgen_anon_1: qemu_info_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_info_t__bindgen_ty_1 {
    pub min: ::std::os::raw::c_int,
    pub cur: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_info_t__bindgen_ty_1"]
        [::std::mem::size_of::<qemu_info_t__bindgen_ty_1>() - 8usize];
    ["Alignment of qemu_info_t__bindgen_ty_1"]
        [::std::mem::align_of::<qemu_info_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: qemu_info_t__bindgen_ty_1::min"]
        [::std::mem::offset_of!(qemu_info_t__bindgen_ty_1, min) - 0usize];
    ["Offset of field: qemu_info_t__bindgen_ty_1::cur"]
        [::std::mem::offset_of!(qemu_info_t__bindgen_ty_1, cur) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union qemu_info_t__bindgen_ty_2 {
    pub system: qemu_info_t__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_info_t__bindgen_ty_2__bindgen_ty_1 {
    pub smp_vcpus: ::std::os::raw::c_int,
    pub max_vcpus: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_info_t__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::size_of::<qemu_info_t__bindgen_ty_2__bindgen_ty_1>() - 8usize];
    ["Alignment of qemu_info_t__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::align_of::<qemu_info_t__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    ["Offset of field: qemu_info_t__bindgen_ty_2__bindgen_ty_1::smp_vcpus"]
        [::std::mem::offset_of!(qemu_info_t__bindgen_ty_2__bindgen_ty_1, smp_vcpus) - 0usize];
    ["Offset of field: qemu_info_t__bindgen_ty_2__bindgen_ty_1::max_vcpus"]
        [::std::mem::offset_of!(qemu_info_t__bindgen_ty_2__bindgen_ty_1, max_vcpus) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_info_t__bindgen_ty_2"]
        [::std::mem::size_of::<qemu_info_t__bindgen_ty_2>() - 8usize];
    ["Alignment of qemu_info_t__bindgen_ty_2"]
        [::std::mem::align_of::<qemu_info_t__bindgen_ty_2>() - 4usize];
    ["Offset of field: qemu_info_t__bindgen_ty_2::system"]
        [::std::mem::offset_of!(qemu_info_t__bindgen_ty_2, system) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_info_t"][::std::mem::size_of::<qemu_info_t>() - 32usize];
    ["Alignment of qemu_info_t"][::std::mem::align_of::<qemu_info_t>() - 8usize];
    ["Offset of field: qemu_info_t::target_name"]
        [::std::mem::offset_of!(qemu_info_t, target_name) - 0usize];
    ["Offset of field: qemu_info_t::version"]
        [::std::mem::offset_of!(qemu_info_t, version) - 8usize];
    ["Offset of field: qemu_info_t::system_emulation"]
        [::std::mem::offset_of!(qemu_info_t, system_emulation) - 16usize];
};
unsafe extern "C" {
    pub fn qemu_plugin_install(
        id: qemu_plugin_id_t,
        info: *const qemu_info_t,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type qemu_plugin_simple_cb_t =
    ::std::option::Option<unsafe extern "C" fn(id: qemu_plugin_id_t)>;
pub type qemu_plugin_udata_cb_t = ::std::option::Option<
    unsafe extern "C" fn(id: qemu_plugin_id_t, userdata: *mut ::std::os::raw::c_void),
>;
pub type qemu_plugin_vcpu_simple_cb_t = ::std::option::Option<
    unsafe extern "C" fn(id: qemu_plugin_id_t, vcpu_index: ::std::os::raw::c_uint),
>;
pub type qemu_plugin_vcpu_udata_cb_t = ::std::option::Option<
    unsafe extern "C" fn(vcpu_index: ::std::os::raw::c_uint, userdata: *mut ::std::os::raw::c_void),
>;
unsafe extern "C" {
    pub fn qemu_plugin_uninstall(id: qemu_plugin_id_t, cb: qemu_plugin_simple_cb_t);
}
unsafe extern "C" {
    pub fn qemu_plugin_reset(id: qemu_plugin_id_t, cb: qemu_plugin_simple_cb_t);
}
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_init_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_simple_cb_t,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_exit_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_simple_cb_t,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_idle_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_simple_cb_t,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_resume_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_simple_cb_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_u64 {
    pub score: *mut qemu_plugin_scoreboard,
    pub offset: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_u64"][::std::mem::size_of::<qemu_plugin_u64>() - 16usize];
    ["Alignment of qemu_plugin_u64"][::std::mem::align_of::<qemu_plugin_u64>() - 8usize];
    ["Offset of field: qemu_plugin_u64::score"]
        [::std::mem::offset_of!(qemu_plugin_u64, score) - 0usize];
    ["Offset of field: qemu_plugin_u64::offset"]
        [::std::mem::offset_of!(qemu_plugin_u64, offset) - 8usize];
};
pub const QEMU_PLUGIN_CB_NO_REGS: qemu_plugin_cb_flags = 0;
pub const QEMU_PLUGIN_CB_R_REGS: qemu_plugin_cb_flags = 1;
pub const QEMU_PLUGIN_CB_RW_REGS: qemu_plugin_cb_flags = 2;
pub type qemu_plugin_cb_flags = ::std::os::raw::c_uint;
pub const QEMU_PLUGIN_MEM_R: qemu_plugin_mem_rw = 1;
pub const QEMU_PLUGIN_MEM_W: qemu_plugin_mem_rw = 2;
pub const QEMU_PLUGIN_MEM_RW: qemu_plugin_mem_rw = 3;
pub type qemu_plugin_mem_rw = ::std::os::raw::c_uint;
pub const QEMU_PLUGIN_MEM_VALUE_U8: qemu_plugin_mem_value_type = 0;
pub const QEMU_PLUGIN_MEM_VALUE_U16: qemu_plugin_mem_value_type = 1;
pub const QEMU_PLUGIN_MEM_VALUE_U32: qemu_plugin_mem_value_type = 2;
pub const QEMU_PLUGIN_MEM_VALUE_U64: qemu_plugin_mem_value_type = 3;
pub const QEMU_PLUGIN_MEM_VALUE_U128: qemu_plugin_mem_value_type = 4;
pub type qemu_plugin_mem_value_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qemu_plugin_mem_value {
    pub type_: qemu_plugin_mem_value_type,
    pub data: qemu_plugin_mem_value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qemu_plugin_mem_value__bindgen_ty_1 {
    pub u8_: u8,
    pub u16_: u16,
    pub u32_: u32,
    pub u64_: u64,
    pub u128_: qemu_plugin_mem_value__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_mem_value__bindgen_ty_1__bindgen_ty_1 {
    pub low: u64,
    pub high: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_mem_value__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<qemu_plugin_mem_value__bindgen_ty_1__bindgen_ty_1>() - 16usize];
    ["Alignment of qemu_plugin_mem_value__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<qemu_plugin_mem_value__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: qemu_plugin_mem_value__bindgen_ty_1__bindgen_ty_1::low"]
        [::std::mem::offset_of!(qemu_plugin_mem_value__bindgen_ty_1__bindgen_ty_1, low) - 0usize];
    ["Offset of field: qemu_plugin_mem_value__bindgen_ty_1__bindgen_ty_1::high"]
        [::std::mem::offset_of!(qemu_plugin_mem_value__bindgen_ty_1__bindgen_ty_1, high) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_mem_value__bindgen_ty_1"]
        [::std::mem::size_of::<qemu_plugin_mem_value__bindgen_ty_1>() - 16usize];
    ["Alignment of qemu_plugin_mem_value__bindgen_ty_1"]
        [::std::mem::align_of::<qemu_plugin_mem_value__bindgen_ty_1>() - 8usize];
    ["Offset of field: qemu_plugin_mem_value__bindgen_ty_1::u8_"]
        [::std::mem::offset_of!(qemu_plugin_mem_value__bindgen_ty_1, u8_) - 0usize];
    ["Offset of field: qemu_plugin_mem_value__bindgen_ty_1::u16_"]
        [::std::mem::offset_of!(qemu_plugin_mem_value__bindgen_ty_1, u16_) - 0usize];
    ["Offset of field: qemu_plugin_mem_value__bindgen_ty_1::u32_"]
        [::std::mem::offset_of!(qemu_plugin_mem_value__bindgen_ty_1, u32_) - 0usize];
    ["Offset of field: qemu_plugin_mem_value__bindgen_ty_1::u64_"]
        [::std::mem::offset_of!(qemu_plugin_mem_value__bindgen_ty_1, u64_) - 0usize];
    ["Offset of field: qemu_plugin_mem_value__bindgen_ty_1::u128_"]
        [::std::mem::offset_of!(qemu_plugin_mem_value__bindgen_ty_1, u128_) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_mem_value"][::std::mem::size_of::<qemu_plugin_mem_value>() - 24usize];
    ["Alignment of qemu_plugin_mem_value"]
        [::std::mem::align_of::<qemu_plugin_mem_value>() - 8usize];
    ["Offset of field: qemu_plugin_mem_value::type_"]
        [::std::mem::offset_of!(qemu_plugin_mem_value, type_) - 0usize];
    ["Offset of field: qemu_plugin_mem_value::data"]
        [::std::mem::offset_of!(qemu_plugin_mem_value, data) - 8usize];
};
pub const QEMU_PLUGIN_COND_NEVER: qemu_plugin_cond = 0;
pub const QEMU_PLUGIN_COND_ALWAYS: qemu_plugin_cond = 1;
pub const QEMU_PLUGIN_COND_EQ: qemu_plugin_cond = 2;
pub const QEMU_PLUGIN_COND_NE: qemu_plugin_cond = 3;
pub const QEMU_PLUGIN_COND_LT: qemu_plugin_cond = 4;
pub const QEMU_PLUGIN_COND_LE: qemu_plugin_cond = 5;
pub const QEMU_PLUGIN_COND_GT: qemu_plugin_cond = 6;
pub const QEMU_PLUGIN_COND_GE: qemu_plugin_cond = 7;
pub type qemu_plugin_cond = ::std::os::raw::c_uint;
pub type qemu_plugin_vcpu_tb_trans_cb_t =
    ::std::option::Option<unsafe extern "C" fn(id: qemu_plugin_id_t, tb: *mut qemu_plugin_tb)>;
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_tb_trans_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_tb_trans_cb_t,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_tb_exec_cb(
        tb: *mut qemu_plugin_tb,
        cb: qemu_plugin_vcpu_udata_cb_t,
        flags: qemu_plugin_cb_flags,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_tb_exec_cond_cb(
        tb: *mut qemu_plugin_tb,
        cb: qemu_plugin_vcpu_udata_cb_t,
        flags: qemu_plugin_cb_flags,
        cond: qemu_plugin_cond,
        entry: qemu_plugin_u64,
        imm: u64,
        userdata: *mut ::std::os::raw::c_void,
    );
}
pub const QEMU_PLUGIN_INLINE_ADD_U64: qemu_plugin_op = 0;
pub const QEMU_PLUGIN_INLINE_STORE_U64: qemu_plugin_op = 1;
pub type qemu_plugin_op = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_tb_exec_inline_per_vcpu(
        tb: *mut qemu_plugin_tb,
        op: qemu_plugin_op,
        entry: qemu_plugin_u64,
        imm: u64,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_insn_exec_cb(
        insn: *mut qemu_plugin_insn,
        cb: qemu_plugin_vcpu_udata_cb_t,
        flags: qemu_plugin_cb_flags,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_insn_exec_cond_cb(
        insn: *mut qemu_plugin_insn,
        cb: qemu_plugin_vcpu_udata_cb_t,
        flags: qemu_plugin_cb_flags,
        cond: qemu_plugin_cond,
        entry: qemu_plugin_u64,
        imm: u64,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_insn_exec_inline_per_vcpu(
        insn: *mut qemu_plugin_insn,
        op: qemu_plugin_op,
        entry: qemu_plugin_u64,
        imm: u64,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_tb_n_insns(tb: *const qemu_plugin_tb) -> usize;
}
unsafe extern "C" {
    pub fn qemu_plugin_tb_size(tb: *const qemu_plugin_tb) -> usize;
}
unsafe extern "C" {
    pub fn qemu_plugin_tb_vaddr(tb: *const qemu_plugin_tb) -> u64;
}
unsafe extern "C" {
    pub fn qemu_plugin_tb_get_insn(tb: *const qemu_plugin_tb, idx: usize) -> *mut qemu_plugin_insn;
}
unsafe extern "C" {
    pub fn qemu_plugin_tb_get_insn_by_vaddr(
        tb: *const qemu_plugin_tb,
        vaddr: u64,
    ) -> *mut qemu_plugin_insn;
}
unsafe extern "C" {
    pub fn qemu_plugin_insn_data(
        insn: *const qemu_plugin_insn,
        dest: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn qemu_plugin_insn_size(insn: *const qemu_plugin_insn) -> usize;
}
unsafe extern "C" {
    pub fn qemu_plugin_insn_vaddr(insn: *const qemu_plugin_insn) -> u64;
}
unsafe extern "C" {
    pub fn qemu_plugin_insn_haddr(insn: *const qemu_plugin_insn) -> *mut ::std::os::raw::c_void;
}
pub type qemu_plugin_meminfo_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_hwaddr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn qemu_plugin_mem_size_shift(info: qemu_plugin_meminfo_t) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn qemu_plugin_mem_is_sign_extended(info: qemu_plugin_meminfo_t) -> bool;
}
unsafe extern "C" {
    pub fn qemu_plugin_mem_is_big_endian(info: qemu_plugin_meminfo_t) -> bool;
}
unsafe extern "C" {
    pub fn qemu_plugin_mem_is_store(info: qemu_plugin_meminfo_t) -> bool;
}
unsafe extern "C" {
    pub fn qemu_plugin_mem_get_value(info: qemu_plugin_meminfo_t) -> qemu_plugin_mem_value;
}
unsafe extern "C" {
    pub fn qemu_plugin_get_hwaddr(
        info: qemu_plugin_meminfo_t,
        vaddr: u64,
    ) -> *mut qemu_plugin_hwaddr;
}
unsafe extern "C" {
    pub fn qemu_plugin_hwaddr_is_io(haddr: *const qemu_plugin_hwaddr) -> bool;
}
unsafe extern "C" {
    pub fn qemu_plugin_hwaddr_phys_addr(haddr: *const qemu_plugin_hwaddr) -> u64;
}
unsafe extern "C" {
    pub fn qemu_plugin_hwaddr_device_name(
        h: *const qemu_plugin_hwaddr,
    ) -> *const ::std::os::raw::c_char;
}
pub type qemu_plugin_vcpu_mem_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        vcpu_index: ::std::os::raw::c_uint,
        info: qemu_plugin_meminfo_t,
        vaddr: u64,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_mem_cb(
        insn: *mut qemu_plugin_insn,
        cb: qemu_plugin_vcpu_mem_cb_t,
        flags: qemu_plugin_cb_flags,
        rw: qemu_plugin_mem_rw,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_mem_inline_per_vcpu(
        insn: *mut qemu_plugin_insn,
        rw: qemu_plugin_mem_rw,
        op: qemu_plugin_op,
        entry: qemu_plugin_u64,
        imm: u64,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_request_time_control() -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qemu_plugin_update_ns(handle: *const ::std::os::raw::c_void, time: i64);
}
pub type qemu_plugin_vcpu_syscall_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        id: qemu_plugin_id_t,
        vcpu_index: ::std::os::raw::c_uint,
        num: i64,
        a1: u64,
        a2: u64,
        a3: u64,
        a4: u64,
        a5: u64,
        a6: u64,
        a7: u64,
        a8: u64,
    ),
>;
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_syscall_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_syscall_cb_t,
    );
}
pub type qemu_plugin_vcpu_syscall_ret_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        id: qemu_plugin_id_t,
        vcpu_idx: ::std::os::raw::c_uint,
        num: i64,
        ret: i64,
    ),
>;
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_syscall_ret_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_syscall_ret_cb_t,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_insn_disas(insn: *const qemu_plugin_insn) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qemu_plugin_insn_symbol(insn: *const qemu_plugin_insn) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qemu_plugin_vcpu_for_each(id: qemu_plugin_id_t, cb: qemu_plugin_vcpu_simple_cb_t);
}
unsafe extern "C" {
    pub fn qemu_plugin_register_flush_cb(id: qemu_plugin_id_t, cb: qemu_plugin_simple_cb_t);
}
unsafe extern "C" {
    pub fn qemu_plugin_register_atexit_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_udata_cb_t,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_num_vcpus() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_plugin_outs(string: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn qemu_plugin_bool_parse(
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        ret: *mut bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn qemu_plugin_path_to_binary() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qemu_plugin_start_code() -> u64;
}
unsafe extern "C" {
    pub fn qemu_plugin_end_code() -> u64;
}
unsafe extern "C" {
    pub fn qemu_plugin_entry_code() -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_register {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_reg_descriptor {
    pub handle: *mut qemu_plugin_register,
    pub name: *const ::std::os::raw::c_char,
    pub feature: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_reg_descriptor"]
        [::std::mem::size_of::<qemu_plugin_reg_descriptor>() - 24usize];
    ["Alignment of qemu_plugin_reg_descriptor"]
        [::std::mem::align_of::<qemu_plugin_reg_descriptor>() - 8usize];
    ["Offset of field: qemu_plugin_reg_descriptor::handle"]
        [::std::mem::offset_of!(qemu_plugin_reg_descriptor, handle) - 0usize];
    ["Offset of field: qemu_plugin_reg_descriptor::name"]
        [::std::mem::offset_of!(qemu_plugin_reg_descriptor, name) - 8usize];
    ["Offset of field: qemu_plugin_reg_descriptor::feature"]
        [::std::mem::offset_of!(qemu_plugin_reg_descriptor, feature) - 16usize];
};
unsafe extern "C" {
    pub fn qemu_plugin_get_registers() -> *mut GArray;
}
unsafe extern "C" {
    pub fn qemu_plugin_read_memory_vaddr(addr: u64, data: *mut GByteArray, len: usize) -> bool;
}
unsafe extern "C" {
    pub fn qemu_plugin_read_register(
        handle: *mut qemu_plugin_register,
        buf: *mut GByteArray,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_plugin_scoreboard_new(element_size: usize) -> *mut qemu_plugin_scoreboard;
}
unsafe extern "C" {
    pub fn qemu_plugin_scoreboard_free(score: *mut qemu_plugin_scoreboard);
}
unsafe extern "C" {
    pub fn qemu_plugin_scoreboard_find(
        score: *mut qemu_plugin_scoreboard,
        vcpu_index: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qemu_plugin_u64_add(
        entry: qemu_plugin_u64,
        vcpu_index: ::std::os::raw::c_uint,
        added: u64,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_u64_get(entry: qemu_plugin_u64, vcpu_index: ::std::os::raw::c_uint) -> u64;
}
unsafe extern "C" {
    pub fn qemu_plugin_u64_set(
        entry: qemu_plugin_u64,
        vcpu_index: ::std::os::raw::c_uint,
        val: u64,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_u64_sum(entry: qemu_plugin_u64) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Location {
    pub kind: Location__bindgen_ty_1,
    pub num: ::std::os::raw::c_int,
    pub ptr: *const ::std::os::raw::c_void,
    pub prev: *mut Location,
}
pub const LOC_NONE: Location__bindgen_ty_1 = 0;
pub const LOC_CMDLINE: Location__bindgen_ty_1 = 1;
pub const LOC_FILE: Location__bindgen_ty_1 = 2;
pub type Location__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Location"][::std::mem::size_of::<Location>() - 24usize];
    ["Alignment of Location"][::std::mem::align_of::<Location>() - 8usize];
    ["Offset of field: Location::kind"][::std::mem::offset_of!(Location, kind) - 0usize];
    ["Offset of field: Location::num"][::std::mem::offset_of!(Location, num) - 4usize];
    ["Offset of field: Location::ptr"][::std::mem::offset_of!(Location, ptr) - 8usize];
    ["Offset of field: Location::prev"][::std::mem::offset_of!(Location, prev) - 16usize];
};
unsafe extern "C" {
    pub fn loc_push_restore(loc: *mut Location) -> *mut Location;
}
unsafe extern "C" {
    pub fn loc_push_none(loc: *mut Location) -> *mut Location;
}
unsafe extern "C" {
    pub fn loc_pop(loc: *mut Location) -> *mut Location;
}
unsafe extern "C" {
    pub fn loc_save(loc: *mut Location) -> *mut Location;
}
unsafe extern "C" {
    pub fn loc_restore(loc: *mut Location);
}
unsafe extern "C" {
    pub fn loc_set_none();
}
unsafe extern "C" {
    pub fn loc_set_cmdline(
        argv: *mut *mut ::std::os::raw::c_char,
        idx: ::std::os::raw::c_int,
        cnt: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn loc_set_file(fname: *const ::std::os::raw::c_char, lno: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn error_vprintf(
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn error_printf(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn error_vreport(fmt: *const ::std::os::raw::c_char, ap: *mut __va_list_tag);
}
unsafe extern "C" {
    pub fn warn_vreport(fmt: *const ::std::os::raw::c_char, ap: *mut __va_list_tag);
}
unsafe extern "C" {
    pub fn info_vreport(fmt: *const ::std::os::raw::c_char, ap: *mut __va_list_tag);
}
unsafe extern "C" {
    pub fn error_report(fmt: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn warn_report(fmt: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn info_report(fmt: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn error_report_once_cond(
        printed: *mut bool,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> bool;
}
unsafe extern "C" {
    pub fn warn_report_once_cond(
        printed: *mut bool,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> bool;
}
unsafe extern "C" {
    pub fn error_init(argv0: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub static mut message_with_timestamp: bool;
}
unsafe extern "C" {
    pub static mut error_with_guestname: bool;
}
unsafe extern "C" {
    pub static mut error_guest_name: *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn get_opt_value(
        p: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn parse_option_size(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        ret: *mut u64,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn has_help_option(param: *const ::std::os::raw::c_char) -> bool;
}
pub const QEMU_OPT_STRING: QemuOptType = 0;
pub const QEMU_OPT_BOOL: QemuOptType = 1;
pub const QEMU_OPT_NUMBER: QemuOptType = 2;
pub const QEMU_OPT_SIZE: QemuOptType = 3;
pub type QemuOptType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuOpt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuOptDesc {
    pub name: *const ::std::os::raw::c_char,
    pub type_: QemuOptType,
    pub help: *const ::std::os::raw::c_char,
    pub def_value_str: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuOptDesc"][::std::mem::size_of::<QemuOptDesc>() - 32usize];
    ["Alignment of QemuOptDesc"][::std::mem::align_of::<QemuOptDesc>() - 8usize];
    ["Offset of field: QemuOptDesc::name"][::std::mem::offset_of!(QemuOptDesc, name) - 0usize];
    ["Offset of field: QemuOptDesc::type_"][::std::mem::offset_of!(QemuOptDesc, type_) - 8usize];
    ["Offset of field: QemuOptDesc::help"][::std::mem::offset_of!(QemuOptDesc, help) - 16usize];
    ["Offset of field: QemuOptDesc::def_value_str"]
        [::std::mem::offset_of!(QemuOptDesc, def_value_str) - 24usize];
};
#[repr(C)]
pub struct QemuOptsList {
    pub name: *const ::std::os::raw::c_char,
    pub implied_opt_name: *const ::std::os::raw::c_char,
    pub merge_lists: bool,
    pub head: QemuOptsList__bindgen_ty_1,
    pub desc: __IncompleteArrayField<QemuOptDesc>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union QemuOptsList__bindgen_ty_1 {
    pub tqh_first: *mut QemuOpts,
    pub tqh_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuOptsList__bindgen_ty_1"]
        [::std::mem::size_of::<QemuOptsList__bindgen_ty_1>() - 16usize];
    ["Alignment of QemuOptsList__bindgen_ty_1"]
        [::std::mem::align_of::<QemuOptsList__bindgen_ty_1>() - 8usize];
    ["Offset of field: QemuOptsList__bindgen_ty_1::tqh_first"]
        [::std::mem::offset_of!(QemuOptsList__bindgen_ty_1, tqh_first) - 0usize];
    ["Offset of field: QemuOptsList__bindgen_ty_1::tqh_circ"]
        [::std::mem::offset_of!(QemuOptsList__bindgen_ty_1, tqh_circ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuOptsList"][::std::mem::size_of::<QemuOptsList>() - 40usize];
    ["Alignment of QemuOptsList"][::std::mem::align_of::<QemuOptsList>() - 8usize];
    ["Offset of field: QemuOptsList::name"][::std::mem::offset_of!(QemuOptsList, name) - 0usize];
    ["Offset of field: QemuOptsList::implied_opt_name"]
        [::std::mem::offset_of!(QemuOptsList, implied_opt_name) - 8usize];
    ["Offset of field: QemuOptsList::merge_lists"]
        [::std::mem::offset_of!(QemuOptsList, merge_lists) - 16usize];
    ["Offset of field: QemuOptsList::head"][::std::mem::offset_of!(QemuOptsList, head) - 24usize];
    ["Offset of field: QemuOptsList::desc"][::std::mem::offset_of!(QemuOptsList, desc) - 40usize];
};
unsafe extern "C" {
    pub fn qemu_opt_get(
        opts: *mut QemuOpts,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qemu_opt_get_del(
        opts: *mut QemuOpts,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qemu_opt_has_help_opt(opts: *mut QemuOpts) -> bool;
}
unsafe extern "C" {
    pub fn qemu_opt_find(opts: *mut QemuOpts, name: *const ::std::os::raw::c_char) -> *mut QemuOpt;
}
unsafe extern "C" {
    pub fn qemu_opt_get_bool(
        opts: *mut QemuOpts,
        name: *const ::std::os::raw::c_char,
        defval: bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn qemu_opt_get_number(
        opts: *mut QemuOpts,
        name: *const ::std::os::raw::c_char,
        defval: u64,
    ) -> u64;
}
unsafe extern "C" {
    pub fn qemu_opt_get_size(
        opts: *mut QemuOpts,
        name: *const ::std::os::raw::c_char,
        defval: u64,
    ) -> u64;
}
unsafe extern "C" {
    pub fn qemu_opt_get_bool_del(
        opts: *mut QemuOpts,
        name: *const ::std::os::raw::c_char,
        defval: bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn qemu_opt_get_number_del(
        opts: *mut QemuOpts,
        name: *const ::std::os::raw::c_char,
        defval: u64,
    ) -> u64;
}
unsafe extern "C" {
    pub fn qemu_opt_get_size_del(
        opts: *mut QemuOpts,
        name: *const ::std::os::raw::c_char,
        defval: u64,
    ) -> u64;
}
unsafe extern "C" {
    pub fn qemu_opt_unset(
        opts: *mut QemuOpts,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_opt_set(
        opts: *mut QemuOpts,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn qemu_opt_set_bool(
        opts: *mut QemuOpts,
        name: *const ::std::os::raw::c_char,
        val: bool,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn qemu_opt_set_number(
        opts: *mut QemuOpts,
        name: *const ::std::os::raw::c_char,
        val: i64,
        errp: *mut *mut Error,
    ) -> bool;
}
pub type qemu_opt_loopfunc = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn qemu_opt_foreach(
        opts: *mut QemuOpts,
        func: qemu_opt_loopfunc,
        opaque: *mut ::std::os::raw::c_void,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuOptsIter {
    pub opts: *mut QemuOpts,
    pub opt: *mut QemuOpt,
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuOptsIter"][::std::mem::size_of::<QemuOptsIter>() - 24usize];
    ["Alignment of QemuOptsIter"][::std::mem::align_of::<QemuOptsIter>() - 8usize];
    ["Offset of field: QemuOptsIter::opts"][::std::mem::offset_of!(QemuOptsIter, opts) - 0usize];
    ["Offset of field: QemuOptsIter::opt"][::std::mem::offset_of!(QemuOptsIter, opt) - 8usize];
    ["Offset of field: QemuOptsIter::name"][::std::mem::offset_of!(QemuOptsIter, name) - 16usize];
};
unsafe extern "C" {
    pub fn qemu_opt_iter_init(
        iter: *mut QemuOptsIter,
        opts: *mut QemuOpts,
        name: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn qemu_opt_iter_next(iter: *mut QemuOptsIter) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qemu_opts_find(
        list: *mut QemuOptsList,
        id: *const ::std::os::raw::c_char,
    ) -> *mut QemuOpts;
}
unsafe extern "C" {
    pub fn qemu_opts_create(
        list: *mut QemuOptsList,
        id: *const ::std::os::raw::c_char,
        fail_if_exists: ::std::os::raw::c_int,
        errp: *mut *mut Error,
    ) -> *mut QemuOpts;
}
unsafe extern "C" {
    pub fn qemu_opts_reset(list: *mut QemuOptsList);
}
unsafe extern "C" {
    pub fn qemu_opts_loc_restore(opts: *mut QemuOpts);
}
unsafe extern "C" {
    pub fn qemu_opts_id(opts: *mut QemuOpts) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qemu_opts_set_id(opts: *mut QemuOpts, id: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn qemu_opts_del(opts: *mut QemuOpts);
}
unsafe extern "C" {
    pub fn qemu_opts_validate(
        opts: *mut QemuOpts,
        desc: *const QemuOptDesc,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn qemu_opts_do_parse(
        opts: *mut QemuOpts,
        params: *const ::std::os::raw::c_char,
        firstname: *const ::std::os::raw::c_char,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn qemu_opts_parse_noisily(
        list: *mut QemuOptsList,
        params: *const ::std::os::raw::c_char,
        permit_abbrev: bool,
    ) -> *mut QemuOpts;
}
unsafe extern "C" {
    pub fn qemu_opts_parse(
        list: *mut QemuOptsList,
        params: *const ::std::os::raw::c_char,
        permit_abbrev: bool,
        errp: *mut *mut Error,
    ) -> *mut QemuOpts;
}
unsafe extern "C" {
    pub fn qemu_opts_from_qdict(
        list: *mut QemuOptsList,
        qdict: *const QDict,
        errp: *mut *mut Error,
    ) -> *mut QemuOpts;
}
unsafe extern "C" {
    pub fn qemu_opts_to_qdict_filtered(
        opts: *mut QemuOpts,
        qdict: *mut QDict,
        list: *mut QemuOptsList,
        del: bool,
    ) -> *mut QDict;
}
unsafe extern "C" {
    pub fn qemu_opts_to_qdict(opts: *mut QemuOpts, qdict: *mut QDict) -> *mut QDict;
}
unsafe extern "C" {
    pub fn qemu_opts_absorb_qdict(
        opts: *mut QemuOpts,
        qdict: *mut QDict,
        errp: *mut *mut Error,
    ) -> bool;
}
pub type qemu_opts_loopfunc = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        opts: *mut QemuOpts,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn qemu_opts_foreach(
        list: *mut QemuOptsList,
        func: qemu_opts_loopfunc,
        opaque: *mut ::std::os::raw::c_void,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qemu_opts_print(opts: *mut QemuOpts, sep: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn qemu_opts_print_help(list: *mut QemuOptsList, print_caption: bool);
}
unsafe extern "C" {
    pub fn qemu_opts_free(list: *mut QemuOptsList);
}
unsafe extern "C" {
    pub fn qemu_opts_append(dst: *mut QemuOptsList, list: *mut QemuOptsList) -> *mut QemuOptsList;
}
pub type QemuOpts_autoptr = *mut QemuOpts;
pub type QemuOpts_listautoptr = *mut GList;
pub type QemuOpts_slistautoptr = *mut GSList;
pub type QemuOpts_queueautoptr = *mut GQueue;
pub const QEMU_PLUGIN_EV_VCPU_INIT: qemu_plugin_event = 0;
pub const QEMU_PLUGIN_EV_VCPU_EXIT: qemu_plugin_event = 1;
pub const QEMU_PLUGIN_EV_VCPU_TB_TRANS: qemu_plugin_event = 2;
pub const QEMU_PLUGIN_EV_VCPU_IDLE: qemu_plugin_event = 3;
pub const QEMU_PLUGIN_EV_VCPU_RESUME: qemu_plugin_event = 4;
pub const QEMU_PLUGIN_EV_VCPU_SYSCALL: qemu_plugin_event = 5;
pub const QEMU_PLUGIN_EV_VCPU_SYSCALL_RET: qemu_plugin_event = 6;
pub const QEMU_PLUGIN_EV_FLUSH: qemu_plugin_event = 7;
pub const QEMU_PLUGIN_EV_ATEXIT: qemu_plugin_event = 8;
pub const QEMU_PLUGIN_EV_MAX: qemu_plugin_event = 9;
pub type qemu_plugin_event = ::std::os::raw::c_uint;
pub const MO_8: MemOp = 0;
pub const MO_16: MemOp = 1;
pub const MO_32: MemOp = 2;
pub const MO_64: MemOp = 3;
pub const MO_128: MemOp = 4;
pub const MO_256: MemOp = 5;
pub const MO_512: MemOp = 6;
pub const MO_1024: MemOp = 7;
pub const MO_SIZE: MemOp = 7;
pub const MO_SIGN: MemOp = 8;
pub const MO_BSWAP: MemOp = 16;
pub const MO_LE: MemOp = 0;
pub const MO_BE: MemOp = 16;
pub const MO_TE: MemOp = 16;
pub const MO_ASHIFT: MemOp = 5;
pub const MO_AMASK: MemOp = 224;
pub const MO_UNALN: MemOp = 0;
pub const MO_ALIGN_2: MemOp = 32;
pub const MO_ALIGN_4: MemOp = 64;
pub const MO_ALIGN_8: MemOp = 96;
pub const MO_ALIGN_16: MemOp = 128;
pub const MO_ALIGN_32: MemOp = 160;
pub const MO_ALIGN_64: MemOp = 192;
pub const MO_ALIGN: MemOp = 224;
pub const MO_ATOM_SHIFT: MemOp = 8;
pub const MO_ATOM_IFALIGN: MemOp = 0;
pub const MO_ATOM_IFALIGN_PAIR: MemOp = 256;
pub const MO_ATOM_WITHIN16: MemOp = 512;
pub const MO_ATOM_WITHIN16_PAIR: MemOp = 768;
pub const MO_ATOM_SUBALIGN: MemOp = 1024;
pub const MO_ATOM_NONE: MemOp = 1280;
pub const MO_ATOM_MASK: MemOp = 1792;
pub const MO_UB: MemOp = 0;
pub const MO_UW: MemOp = 1;
pub const MO_UL: MemOp = 2;
pub const MO_UQ: MemOp = 3;
pub const MO_UO: MemOp = 4;
pub const MO_SB: MemOp = 8;
pub const MO_SW: MemOp = 9;
pub const MO_SL: MemOp = 10;
pub const MO_SQ: MemOp = 11;
pub const MO_SO: MemOp = 12;
pub const MO_LEUW: MemOp = 1;
pub const MO_LEUL: MemOp = 2;
pub const MO_LEUQ: MemOp = 3;
pub const MO_LESW: MemOp = 9;
pub const MO_LESL: MemOp = 10;
pub const MO_LESQ: MemOp = 11;
pub const MO_BEUW: MemOp = 17;
pub const MO_BEUL: MemOp = 18;
pub const MO_BEUQ: MemOp = 19;
pub const MO_BESW: MemOp = 25;
pub const MO_BESL: MemOp = 26;
pub const MO_BESQ: MemOp = 27;
pub const MO_TEUW: MemOp = 17;
pub const MO_TEUL: MemOp = 18;
pub const MO_TEUQ: MemOp = 19;
pub const MO_TEUO: MemOp = 20;
pub const MO_TESW: MemOp = 25;
pub const MO_TESL: MemOp = 26;
pub const MO_TESQ: MemOp = 27;
pub const MO_SSIZE: MemOp = 15;
pub type MemOp = ::std::os::raw::c_uint;
pub type MemOpIdx = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_desc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union QemuPluginList {
    pub tqh_first: *mut qemu_plugin_desc,
    pub tqh_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuPluginList"][::std::mem::size_of::<QemuPluginList>() - 16usize];
    ["Alignment of QemuPluginList"][::std::mem::align_of::<QemuPluginList>() - 8usize];
    ["Offset of field: QemuPluginList::tqh_first"]
        [::std::mem::offset_of!(QemuPluginList, tqh_first) - 0usize];
    ["Offset of field: QemuPluginList::tqh_circ"]
        [::std::mem::offset_of!(QemuPluginList, tqh_circ) - 0usize];
};
unsafe extern "C" {
    pub static mut qemu_plugin_opts: QemuOptsList;
}
unsafe extern "C" {
    pub fn qemu_plugin_opt_parse(optstr: *const ::std::os::raw::c_char, head: *mut QemuPluginList);
}
unsafe extern "C" {
    pub fn qemu_plugin_load_list(
        head: *mut QemuPluginList,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qemu_plugin_cb_sig {
    pub simple: qemu_plugin_simple_cb_t,
    pub udata: qemu_plugin_udata_cb_t,
    pub vcpu_simple: qemu_plugin_vcpu_simple_cb_t,
    pub vcpu_udata: qemu_plugin_vcpu_udata_cb_t,
    pub vcpu_tb_trans: qemu_plugin_vcpu_tb_trans_cb_t,
    pub vcpu_mem: qemu_plugin_vcpu_mem_cb_t,
    pub vcpu_syscall: qemu_plugin_vcpu_syscall_cb_t,
    pub vcpu_syscall_ret: qemu_plugin_vcpu_syscall_ret_cb_t,
    pub generic: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_cb_sig"][::std::mem::size_of::<qemu_plugin_cb_sig>() - 8usize];
    ["Alignment of qemu_plugin_cb_sig"][::std::mem::align_of::<qemu_plugin_cb_sig>() - 8usize];
    ["Offset of field: qemu_plugin_cb_sig::simple"]
        [::std::mem::offset_of!(qemu_plugin_cb_sig, simple) - 0usize];
    ["Offset of field: qemu_plugin_cb_sig::udata"]
        [::std::mem::offset_of!(qemu_plugin_cb_sig, udata) - 0usize];
    ["Offset of field: qemu_plugin_cb_sig::vcpu_simple"]
        [::std::mem::offset_of!(qemu_plugin_cb_sig, vcpu_simple) - 0usize];
    ["Offset of field: qemu_plugin_cb_sig::vcpu_udata"]
        [::std::mem::offset_of!(qemu_plugin_cb_sig, vcpu_udata) - 0usize];
    ["Offset of field: qemu_plugin_cb_sig::vcpu_tb_trans"]
        [::std::mem::offset_of!(qemu_plugin_cb_sig, vcpu_tb_trans) - 0usize];
    ["Offset of field: qemu_plugin_cb_sig::vcpu_mem"]
        [::std::mem::offset_of!(qemu_plugin_cb_sig, vcpu_mem) - 0usize];
    ["Offset of field: qemu_plugin_cb_sig::vcpu_syscall"]
        [::std::mem::offset_of!(qemu_plugin_cb_sig, vcpu_syscall) - 0usize];
    ["Offset of field: qemu_plugin_cb_sig::vcpu_syscall_ret"]
        [::std::mem::offset_of!(qemu_plugin_cb_sig, vcpu_syscall_ret) - 0usize];
    ["Offset of field: qemu_plugin_cb_sig::generic"]
        [::std::mem::offset_of!(qemu_plugin_cb_sig, generic) - 0usize];
};
pub const PLUGIN_CB_REGULAR: plugin_dyn_cb_type = 0;
pub const PLUGIN_CB_COND: plugin_dyn_cb_type = 1;
pub const PLUGIN_CB_MEM_REGULAR: plugin_dyn_cb_type = 2;
pub const PLUGIN_CB_INLINE_ADD_U64: plugin_dyn_cb_type = 3;
pub const PLUGIN_CB_INLINE_STORE_U64: plugin_dyn_cb_type = 4;
pub type plugin_dyn_cb_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qemu_plugin_regular_cb {
    pub f: qemu_plugin_cb_sig,
    pub info: *mut TCGHelperInfo,
    pub userp: *mut ::std::os::raw::c_void,
    pub rw: qemu_plugin_mem_rw,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_regular_cb"][::std::mem::size_of::<qemu_plugin_regular_cb>() - 32usize];
    ["Alignment of qemu_plugin_regular_cb"]
        [::std::mem::align_of::<qemu_plugin_regular_cb>() - 8usize];
    ["Offset of field: qemu_plugin_regular_cb::f"]
        [::std::mem::offset_of!(qemu_plugin_regular_cb, f) - 0usize];
    ["Offset of field: qemu_plugin_regular_cb::info"]
        [::std::mem::offset_of!(qemu_plugin_regular_cb, info) - 8usize];
    ["Offset of field: qemu_plugin_regular_cb::userp"]
        [::std::mem::offset_of!(qemu_plugin_regular_cb, userp) - 16usize];
    ["Offset of field: qemu_plugin_regular_cb::rw"]
        [::std::mem::offset_of!(qemu_plugin_regular_cb, rw) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_inline_cb {
    pub entry: qemu_plugin_u64,
    pub imm: u64,
    pub rw: qemu_plugin_mem_rw,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_inline_cb"][::std::mem::size_of::<qemu_plugin_inline_cb>() - 32usize];
    ["Alignment of qemu_plugin_inline_cb"]
        [::std::mem::align_of::<qemu_plugin_inline_cb>() - 8usize];
    ["Offset of field: qemu_plugin_inline_cb::entry"]
        [::std::mem::offset_of!(qemu_plugin_inline_cb, entry) - 0usize];
    ["Offset of field: qemu_plugin_inline_cb::imm"]
        [::std::mem::offset_of!(qemu_plugin_inline_cb, imm) - 16usize];
    ["Offset of field: qemu_plugin_inline_cb::rw"]
        [::std::mem::offset_of!(qemu_plugin_inline_cb, rw) - 24usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qemu_plugin_conditional_cb {
    pub f: qemu_plugin_cb_sig,
    pub info: *mut TCGHelperInfo,
    pub userp: *mut ::std::os::raw::c_void,
    pub entry: qemu_plugin_u64,
    pub cond: qemu_plugin_cond,
    pub imm: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_conditional_cb"]
        [::std::mem::size_of::<qemu_plugin_conditional_cb>() - 56usize];
    ["Alignment of qemu_plugin_conditional_cb"]
        [::std::mem::align_of::<qemu_plugin_conditional_cb>() - 8usize];
    ["Offset of field: qemu_plugin_conditional_cb::f"]
        [::std::mem::offset_of!(qemu_plugin_conditional_cb, f) - 0usize];
    ["Offset of field: qemu_plugin_conditional_cb::info"]
        [::std::mem::offset_of!(qemu_plugin_conditional_cb, info) - 8usize];
    ["Offset of field: qemu_plugin_conditional_cb::userp"]
        [::std::mem::offset_of!(qemu_plugin_conditional_cb, userp) - 16usize];
    ["Offset of field: qemu_plugin_conditional_cb::entry"]
        [::std::mem::offset_of!(qemu_plugin_conditional_cb, entry) - 24usize];
    ["Offset of field: qemu_plugin_conditional_cb::cond"]
        [::std::mem::offset_of!(qemu_plugin_conditional_cb, cond) - 40usize];
    ["Offset of field: qemu_plugin_conditional_cb::imm"]
        [::std::mem::offset_of!(qemu_plugin_conditional_cb, imm) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qemu_plugin_dyn_cb {
    pub type_: plugin_dyn_cb_type,
    pub __bindgen_anon_1: qemu_plugin_dyn_cb__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qemu_plugin_dyn_cb__bindgen_ty_1 {
    pub regular: qemu_plugin_regular_cb,
    pub cond: qemu_plugin_conditional_cb,
    pub inline_insn: qemu_plugin_inline_cb,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_dyn_cb__bindgen_ty_1"]
        [::std::mem::size_of::<qemu_plugin_dyn_cb__bindgen_ty_1>() - 56usize];
    ["Alignment of qemu_plugin_dyn_cb__bindgen_ty_1"]
        [::std::mem::align_of::<qemu_plugin_dyn_cb__bindgen_ty_1>() - 8usize];
    ["Offset of field: qemu_plugin_dyn_cb__bindgen_ty_1::regular"]
        [::std::mem::offset_of!(qemu_plugin_dyn_cb__bindgen_ty_1, regular) - 0usize];
    ["Offset of field: qemu_plugin_dyn_cb__bindgen_ty_1::cond"]
        [::std::mem::offset_of!(qemu_plugin_dyn_cb__bindgen_ty_1, cond) - 0usize];
    ["Offset of field: qemu_plugin_dyn_cb__bindgen_ty_1::inline_insn"]
        [::std::mem::offset_of!(qemu_plugin_dyn_cb__bindgen_ty_1, inline_insn) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_dyn_cb"][::std::mem::size_of::<qemu_plugin_dyn_cb>() - 64usize];
    ["Alignment of qemu_plugin_dyn_cb"][::std::mem::align_of::<qemu_plugin_dyn_cb>() - 8usize];
    ["Offset of field: qemu_plugin_dyn_cb::type_"]
        [::std::mem::offset_of!(qemu_plugin_dyn_cb, type_) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_insn {
    pub vaddr: u64,
    pub insn_cbs: *mut GArray,
    pub mem_cbs: *mut GArray,
    pub len: u8,
    pub calls_helpers: bool,
    pub mem_helper: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_insn"][::std::mem::size_of::<qemu_plugin_insn>() - 32usize];
    ["Alignment of qemu_plugin_insn"][::std::mem::align_of::<qemu_plugin_insn>() - 8usize];
    ["Offset of field: qemu_plugin_insn::vaddr"]
        [::std::mem::offset_of!(qemu_plugin_insn, vaddr) - 0usize];
    ["Offset of field: qemu_plugin_insn::insn_cbs"]
        [::std::mem::offset_of!(qemu_plugin_insn, insn_cbs) - 8usize];
    ["Offset of field: qemu_plugin_insn::mem_cbs"]
        [::std::mem::offset_of!(qemu_plugin_insn, mem_cbs) - 16usize];
    ["Offset of field: qemu_plugin_insn::len"]
        [::std::mem::offset_of!(qemu_plugin_insn, len) - 24usize];
    ["Offset of field: qemu_plugin_insn::calls_helpers"]
        [::std::mem::offset_of!(qemu_plugin_insn, calls_helpers) - 25usize];
    ["Offset of field: qemu_plugin_insn::mem_helper"]
        [::std::mem::offset_of!(qemu_plugin_insn, mem_helper) - 26usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_scoreboard {
    pub data: *mut GArray,
    pub entry: qemu_plugin_scoreboard__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_scoreboard__bindgen_ty_1 {
    pub le_next: *mut qemu_plugin_scoreboard,
    pub le_prev: *mut *mut qemu_plugin_scoreboard,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_scoreboard__bindgen_ty_1"]
        [::std::mem::size_of::<qemu_plugin_scoreboard__bindgen_ty_1>() - 16usize];
    ["Alignment of qemu_plugin_scoreboard__bindgen_ty_1"]
        [::std::mem::align_of::<qemu_plugin_scoreboard__bindgen_ty_1>() - 8usize];
    ["Offset of field: qemu_plugin_scoreboard__bindgen_ty_1::le_next"]
        [::std::mem::offset_of!(qemu_plugin_scoreboard__bindgen_ty_1, le_next) - 0usize];
    ["Offset of field: qemu_plugin_scoreboard__bindgen_ty_1::le_prev"]
        [::std::mem::offset_of!(qemu_plugin_scoreboard__bindgen_ty_1, le_prev) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_scoreboard"][::std::mem::size_of::<qemu_plugin_scoreboard>() - 24usize];
    ["Alignment of qemu_plugin_scoreboard"]
        [::std::mem::align_of::<qemu_plugin_scoreboard>() - 8usize];
    ["Offset of field: qemu_plugin_scoreboard::data"]
        [::std::mem::offset_of!(qemu_plugin_scoreboard, data) - 0usize];
    ["Offset of field: qemu_plugin_scoreboard::entry"]
        [::std::mem::offset_of!(qemu_plugin_scoreboard, entry) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_tb {
    pub insns: *mut GPtrArray,
    pub n: usize,
    pub mem_helper: bool,
    pub cbs: *mut GArray,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_tb"][::std::mem::size_of::<qemu_plugin_tb>() - 32usize];
    ["Alignment of qemu_plugin_tb"][::std::mem::align_of::<qemu_plugin_tb>() - 8usize];
    ["Offset of field: qemu_plugin_tb::insns"]
        [::std::mem::offset_of!(qemu_plugin_tb, insns) - 0usize];
    ["Offset of field: qemu_plugin_tb::n"][::std::mem::offset_of!(qemu_plugin_tb, n) - 8usize];
    ["Offset of field: qemu_plugin_tb::mem_helper"]
        [::std::mem::offset_of!(qemu_plugin_tb, mem_helper) - 16usize];
    ["Offset of field: qemu_plugin_tb::cbs"][::std::mem::offset_of!(qemu_plugin_tb, cbs) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUPluginState {
    pub event_mask: [::std::os::raw::c_ulong; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUPluginState"][::std::mem::size_of::<CPUPluginState>() - 8usize];
    ["Alignment of CPUPluginState"][::std::mem::align_of::<CPUPluginState>() - 8usize];
    ["Offset of field: CPUPluginState::event_mask"]
        [::std::mem::offset_of!(CPUPluginState, event_mask) - 0usize];
};
unsafe extern "C" {
    pub fn qemu_plugin_create_vcpu_state() -> *mut CPUPluginState;
}
unsafe extern "C" {
    pub fn qemu_plugin_vcpu_init_hook(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn qemu_plugin_vcpu_exit_hook(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn qemu_plugin_tb_trans_cb(cpu: *mut CPUState, tb: *mut qemu_plugin_tb);
}
unsafe extern "C" {
    pub fn qemu_plugin_vcpu_idle_cb(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn qemu_plugin_vcpu_resume_cb(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn qemu_plugin_vcpu_syscall(
        cpu: *mut CPUState,
        num: i64,
        a1: u64,
        a2: u64,
        a3: u64,
        a4: u64,
        a5: u64,
        a6: u64,
        a7: u64,
        a8: u64,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_vcpu_syscall_ret(cpu: *mut CPUState, num: i64, ret: i64);
}
unsafe extern "C" {
    pub fn qemu_plugin_vcpu_mem_cb(
        cpu: *mut CPUState,
        vaddr: u64,
        value_low: u64,
        value_high: u64,
        oi: MemOpIdx,
        rw: qemu_plugin_mem_rw,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_flush_cb();
}
unsafe extern "C" {
    pub fn qemu_plugin_atexit_cb();
}
unsafe extern "C" {
    pub fn qemu_plugin_add_dyn_cb_arr(arr: *mut GArray);
}
unsafe extern "C" {
    pub fn qemu_plugin_user_exit();
}
unsafe extern "C" {
    pub fn qemu_plugin_user_prefork_lock();
}
unsafe extern "C" {
    pub fn qemu_plugin_user_postfork(is_child: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Coroutine {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoMutex {
    _unused: [u8; 0],
}
pub type CoroutineEntry =
    ::std::option::Option<unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    pub fn qemu_coroutine_create(
        entry: CoroutineEntry,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut Coroutine;
}
unsafe extern "C" {
    pub fn qemu_coroutine_enter(coroutine: *mut Coroutine);
}
unsafe extern "C" {
    pub fn qemu_coroutine_enter_if_inactive(co: *mut Coroutine);
}
unsafe extern "C" {
    pub fn qemu_aio_coroutine_enter(ctx: *mut AioContext, co: *mut Coroutine);
}
unsafe extern "C" {
    pub fn qemu_coroutine_yield();
}
unsafe extern "C" {
    pub fn qemu_coroutine_get_aio_context(co: *mut Coroutine) -> *mut AioContext;
}
unsafe extern "C" {
    pub fn qemu_coroutine_self() -> *mut Coroutine;
}
unsafe extern "C" {
    pub fn qemu_in_coroutine() -> bool;
}
unsafe extern "C" {
    pub fn qemu_coroutine_entered(co: *mut Coroutine) -> bool;
}
unsafe extern "C" {
    pub fn qemu_co_mutex_init(mutex: *mut CoMutex);
}
unsafe extern "C" {
    pub fn qemu_co_mutex_lock(mutex: *mut CoMutex);
}
unsafe extern "C" {
    pub fn qemu_co_mutex_unlock(mutex: *mut CoMutex);
}
pub type QemuLockUnlockFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuLockable {
    pub object: *mut ::std::os::raw::c_void,
    pub lock: QemuLockUnlockFunc,
    pub unlock: QemuLockUnlockFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuLockable"][::std::mem::size_of::<QemuLockable>() - 24usize];
    ["Alignment of QemuLockable"][::std::mem::align_of::<QemuLockable>() - 8usize];
    ["Offset of field: QemuLockable::object"]
        [::std::mem::offset_of!(QemuLockable, object) - 0usize];
    ["Offset of field: QemuLockable::lock"][::std::mem::offset_of!(QemuLockable, lock) - 8usize];
    ["Offset of field: QemuLockable::unlock"]
        [::std::mem::offset_of!(QemuLockable, unlock) - 16usize];
};
pub type QemuLockable_autoptr = *mut QemuLockable;
pub type QemuLockable_listautoptr = *mut GList;
pub type QemuLockable_slistautoptr = *mut GSList;
pub type QemuLockable_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuSeqLock {
    pub sequence: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QemuSeqLock"][::std::mem::size_of::<QemuSeqLock>() - 4usize];
    ["Alignment of QemuSeqLock"][::std::mem::align_of::<QemuSeqLock>() - 4usize];
    ["Offset of field: QemuSeqLock::sequence"]
        [::std::mem::offset_of!(QemuSeqLock, sequence) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdist_entry {
    pub x: f64,
    pub count: ::std::os::raw::c_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qdist_entry"][::std::mem::size_of::<qdist_entry>() - 16usize];
    ["Alignment of qdist_entry"][::std::mem::align_of::<qdist_entry>() - 8usize];
    ["Offset of field: qdist_entry::x"][::std::mem::offset_of!(qdist_entry, x) - 0usize];
    ["Offset of field: qdist_entry::count"][::std::mem::offset_of!(qdist_entry, count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdist {
    pub entries: *mut qdist_entry,
    pub n: usize,
    pub size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qdist"][::std::mem::size_of::<qdist>() - 24usize];
    ["Alignment of qdist"][::std::mem::align_of::<qdist>() - 8usize];
    ["Offset of field: qdist::entries"][::std::mem::offset_of!(qdist, entries) - 0usize];
    ["Offset of field: qdist::n"][::std::mem::offset_of!(qdist, n) - 8usize];
    ["Offset of field: qdist::size"][::std::mem::offset_of!(qdist, size) - 16usize];
};
unsafe extern "C" {
    pub fn qdist_init(dist: *mut qdist);
}
unsafe extern "C" {
    pub fn qdist_destroy(dist: *mut qdist);
}
unsafe extern "C" {
    pub fn qdist_add(dist: *mut qdist, x: f64, count: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn qdist_inc(dist: *mut qdist, x: f64);
}
unsafe extern "C" {
    pub fn qdist_xmin(dist: *const qdist) -> f64;
}
unsafe extern "C" {
    pub fn qdist_xmax(dist: *const qdist) -> f64;
}
unsafe extern "C" {
    pub fn qdist_avg(dist: *const qdist) -> f64;
}
unsafe extern "C" {
    pub fn qdist_sample_count(dist: *const qdist) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn qdist_unique_entries(dist: *const qdist) -> usize;
}
unsafe extern "C" {
    pub fn qdist_pr_plain(dist: *const qdist, n_groups: usize) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qdist_pr(dist: *const qdist, n_groups: usize, opt: u32) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qdist_bin__internal(to: *mut qdist, from: *const qdist, n: usize);
}
pub type qht_cmp_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> bool,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qht {
    pub map: *mut qht_map,
    pub cmp: qht_cmp_func_t,
    pub lock: QemuMutex,
    pub mode: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qht"][::std::mem::size_of::<qht>() - 72usize];
    ["Alignment of qht"][::std::mem::align_of::<qht>() - 8usize];
    ["Offset of field: qht::map"][::std::mem::offset_of!(qht, map) - 0usize];
    ["Offset of field: qht::cmp"][::std::mem::offset_of!(qht, cmp) - 8usize];
    ["Offset of field: qht::lock"][::std::mem::offset_of!(qht, lock) - 16usize];
    ["Offset of field: qht::mode"][::std::mem::offset_of!(qht, mode) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qht_stats {
    pub head_buckets: usize,
    pub used_head_buckets: usize,
    pub entries: usize,
    pub chain: qdist,
    pub occupancy: qdist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qht_stats"][::std::mem::size_of::<qht_stats>() - 72usize];
    ["Alignment of qht_stats"][::std::mem::align_of::<qht_stats>() - 8usize];
    ["Offset of field: qht_stats::head_buckets"]
        [::std::mem::offset_of!(qht_stats, head_buckets) - 0usize];
    ["Offset of field: qht_stats::used_head_buckets"]
        [::std::mem::offset_of!(qht_stats, used_head_buckets) - 8usize];
    ["Offset of field: qht_stats::entries"][::std::mem::offset_of!(qht_stats, entries) - 16usize];
    ["Offset of field: qht_stats::chain"][::std::mem::offset_of!(qht_stats, chain) - 24usize];
    ["Offset of field: qht_stats::occupancy"]
        [::std::mem::offset_of!(qht_stats, occupancy) - 48usize];
};
pub type qht_lookup_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *const ::std::os::raw::c_void,
        userp: *const ::std::os::raw::c_void,
    ) -> bool,
>;
pub type qht_iter_func_t = ::std::option::Option<
    unsafe extern "C" fn(p: *mut ::std::os::raw::c_void, h: u32, up: *mut ::std::os::raw::c_void),
>;
pub type qht_iter_bool_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        p: *mut ::std::os::raw::c_void,
        h: u32,
        up: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
unsafe extern "C" {
    pub fn qht_init(
        ht: *mut qht,
        cmp: qht_cmp_func_t,
        n_elems: usize,
        mode: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn qht_destroy(ht: *mut qht);
}
unsafe extern "C" {
    pub fn qht_insert(
        ht: *mut qht,
        p: *mut ::std::os::raw::c_void,
        hash: u32,
        existing: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn qht_lookup_custom(
        ht: *const qht,
        userp: *const ::std::os::raw::c_void,
        hash: u32,
        func: qht_lookup_func_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qht_lookup(
        ht: *const qht,
        userp: *const ::std::os::raw::c_void,
        hash: u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qht_remove(ht: *mut qht, p: *const ::std::os::raw::c_void, hash: u32) -> bool;
}
unsafe extern "C" {
    pub fn qht_reset(ht: *mut qht);
}
unsafe extern "C" {
    pub fn qht_reset_size(ht: *mut qht, n_elems: usize) -> bool;
}
unsafe extern "C" {
    pub fn qht_resize(ht: *mut qht, n_elems: usize) -> bool;
}
unsafe extern "C" {
    pub fn qht_iter(ht: *mut qht, func: qht_iter_func_t, userp: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn qht_iter_remove(
        ht: *mut qht,
        func: qht_iter_bool_func_t,
        userp: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn qht_statistics_init(ht: *const qht, stats: *mut qht_stats);
}
unsafe extern "C" {
    pub fn qht_statistics_destroy(stats: *mut qht_stats);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qemu_plugin_state {
    pub ctxs: qemu_plugin_state__bindgen_ty_1,
    pub cb_lists: [qemu_plugin_state__bindgen_ty_2; 9usize],
    pub id_ht: *mut GHashTable,
    pub cpu_ht: *mut GHashTable,
    pub scoreboards: qemu_plugin_state__bindgen_ty_3,
    pub scoreboard_alloc_size: usize,
    pub mask: [::std::os::raw::c_ulong; 1usize],
    pub lock: QemuRecMutex,
    pub dyn_cb_arr_ht: qht,
    pub num_vcpus: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qemu_plugin_state__bindgen_ty_1 {
    pub tqh_first: *mut qemu_plugin_ctx,
    pub tqh_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_state__bindgen_ty_1"]
        [::std::mem::size_of::<qemu_plugin_state__bindgen_ty_1>() - 16usize];
    ["Alignment of qemu_plugin_state__bindgen_ty_1"]
        [::std::mem::align_of::<qemu_plugin_state__bindgen_ty_1>() - 8usize];
    ["Offset of field: qemu_plugin_state__bindgen_ty_1::tqh_first"]
        [::std::mem::offset_of!(qemu_plugin_state__bindgen_ty_1, tqh_first) - 0usize];
    ["Offset of field: qemu_plugin_state__bindgen_ty_1::tqh_circ"]
        [::std::mem::offset_of!(qemu_plugin_state__bindgen_ty_1, tqh_circ) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_state__bindgen_ty_2 {
    pub lh_first: *mut qemu_plugin_cb,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_state__bindgen_ty_2"]
        [::std::mem::size_of::<qemu_plugin_state__bindgen_ty_2>() - 8usize];
    ["Alignment of qemu_plugin_state__bindgen_ty_2"]
        [::std::mem::align_of::<qemu_plugin_state__bindgen_ty_2>() - 8usize];
    ["Offset of field: qemu_plugin_state__bindgen_ty_2::lh_first"]
        [::std::mem::offset_of!(qemu_plugin_state__bindgen_ty_2, lh_first) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_state__bindgen_ty_3 {
    pub lh_first: *mut qemu_plugin_scoreboard,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_state__bindgen_ty_3"]
        [::std::mem::size_of::<qemu_plugin_state__bindgen_ty_3>() - 8usize];
    ["Alignment of qemu_plugin_state__bindgen_ty_3"]
        [::std::mem::align_of::<qemu_plugin_state__bindgen_ty_3>() - 8usize];
    ["Offset of field: qemu_plugin_state__bindgen_ty_3::lh_first"]
        [::std::mem::offset_of!(qemu_plugin_state__bindgen_ty_3, lh_first) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_state"][::std::mem::size_of::<qemu_plugin_state>() - 256usize];
    ["Alignment of qemu_plugin_state"][::std::mem::align_of::<qemu_plugin_state>() - 8usize];
    ["Offset of field: qemu_plugin_state::ctxs"]
        [::std::mem::offset_of!(qemu_plugin_state, ctxs) - 0usize];
    ["Offset of field: qemu_plugin_state::cb_lists"]
        [::std::mem::offset_of!(qemu_plugin_state, cb_lists) - 16usize];
    ["Offset of field: qemu_plugin_state::id_ht"]
        [::std::mem::offset_of!(qemu_plugin_state, id_ht) - 88usize];
    ["Offset of field: qemu_plugin_state::cpu_ht"]
        [::std::mem::offset_of!(qemu_plugin_state, cpu_ht) - 96usize];
    ["Offset of field: qemu_plugin_state::scoreboards"]
        [::std::mem::offset_of!(qemu_plugin_state, scoreboards) - 104usize];
    ["Offset of field: qemu_plugin_state::scoreboard_alloc_size"]
        [::std::mem::offset_of!(qemu_plugin_state, scoreboard_alloc_size) - 112usize];
    ["Offset of field: qemu_plugin_state::mask"]
        [::std::mem::offset_of!(qemu_plugin_state, mask) - 120usize];
    ["Offset of field: qemu_plugin_state::lock"]
        [::std::mem::offset_of!(qemu_plugin_state, lock) - 128usize];
    ["Offset of field: qemu_plugin_state::dyn_cb_arr_ht"]
        [::std::mem::offset_of!(qemu_plugin_state, dyn_cb_arr_ht) - 176usize];
    ["Offset of field: qemu_plugin_state::num_vcpus"]
        [::std::mem::offset_of!(qemu_plugin_state, num_vcpus) - 248usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qemu_plugin_ctx {
    pub handle: *mut GModule,
    pub id: qemu_plugin_id_t,
    pub callbacks: [*mut qemu_plugin_cb; 9usize],
    pub entry: qemu_plugin_ctx__bindgen_ty_1,
    pub desc: *mut qemu_plugin_desc,
    pub installing: bool,
    pub uninstalling: bool,
    pub resetting: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qemu_plugin_ctx__bindgen_ty_1 {
    pub tqe_next: *mut qemu_plugin_ctx,
    pub tqe_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_ctx__bindgen_ty_1"]
        [::std::mem::size_of::<qemu_plugin_ctx__bindgen_ty_1>() - 16usize];
    ["Alignment of qemu_plugin_ctx__bindgen_ty_1"]
        [::std::mem::align_of::<qemu_plugin_ctx__bindgen_ty_1>() - 8usize];
    ["Offset of field: qemu_plugin_ctx__bindgen_ty_1::tqe_next"]
        [::std::mem::offset_of!(qemu_plugin_ctx__bindgen_ty_1, tqe_next) - 0usize];
    ["Offset of field: qemu_plugin_ctx__bindgen_ty_1::tqe_circ"]
        [::std::mem::offset_of!(qemu_plugin_ctx__bindgen_ty_1, tqe_circ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of qemu_plugin_ctx"][::std::mem::size_of::<qemu_plugin_ctx>() - 120usize];
    ["Alignment of qemu_plugin_ctx"][::std::mem::align_of::<qemu_plugin_ctx>() - 8usize];
    ["Offset of field: qemu_plugin_ctx::handle"]
        [::std::mem::offset_of!(qemu_plugin_ctx, handle) - 0usize];
    ["Offset of field: qemu_plugin_ctx::id"][::std::mem::offset_of!(qemu_plugin_ctx, id) - 8usize];
    ["Offset of field: qemu_plugin_ctx::callbacks"]
        [::std::mem::offset_of!(qemu_plugin_ctx, callbacks) - 16usize];
    ["Offset of field: qemu_plugin_ctx::entry"]
        [::std::mem::offset_of!(qemu_plugin_ctx, entry) - 88usize];
    ["Offset of field: qemu_plugin_ctx::desc"]
        [::std::mem::offset_of!(qemu_plugin_ctx, desc) - 104usize];
    ["Offset of field: qemu_plugin_ctx::installing"]
        [::std::mem::offset_of!(qemu_plugin_ctx, installing) - 112usize];
    ["Offset of field: qemu_plugin_ctx::uninstalling"]
        [::std::mem::offset_of!(qemu_plugin_ctx, uninstalling) - 113usize];
    ["Offset of field: qemu_plugin_ctx::resetting"]
        [::std::mem::offset_of!(qemu_plugin_ctx, resetting) - 114usize];
};
unsafe extern "C" {
    pub fn plugin_id_to_ctx_locked(id: qemu_plugin_id_t) -> *mut qemu_plugin_ctx;
}
unsafe extern "C" {
    pub fn plugin_register_inline_op_on_entry(
        arr: *mut *mut GArray,
        rw: qemu_plugin_mem_rw,
        op: qemu_plugin_op,
        entry: qemu_plugin_u64,
        imm: u64,
    );
}
unsafe extern "C" {
    pub fn plugin_reset_uninstall(id: qemu_plugin_id_t, cb: qemu_plugin_simple_cb_t, reset: bool);
}
unsafe extern "C" {
    pub fn plugin_register_cb(
        id: qemu_plugin_id_t,
        ev: qemu_plugin_event,
        func: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn plugin_unregister_cb__locked(ctx: *mut qemu_plugin_ctx, ev: qemu_plugin_event);
}
unsafe extern "C" {
    pub fn plugin_register_cb_udata(
        id: qemu_plugin_id_t,
        ev: qemu_plugin_event,
        func: *mut ::std::os::raw::c_void,
        udata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn plugin_register_dyn_cb__udata(
        arr: *mut *mut GArray,
        cb: qemu_plugin_vcpu_udata_cb_t,
        flags: qemu_plugin_cb_flags,
        udata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn plugin_register_dyn_cond_cb__udata(
        arr: *mut *mut GArray,
        cb: qemu_plugin_vcpu_udata_cb_t,
        flags: qemu_plugin_cb_flags,
        cond: qemu_plugin_cond,
        entry: qemu_plugin_u64,
        imm: u64,
        udata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn plugin_register_vcpu_mem_cb(
        arr: *mut *mut GArray,
        cb: *mut ::std::os::raw::c_void,
        flags: qemu_plugin_cb_flags,
        rw: qemu_plugin_mem_rw,
        udata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn exec_inline_op(
        type_: plugin_dyn_cb_type,
        cb: *mut qemu_plugin_inline_cb,
        cpu_index: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn plugin_num_vcpus() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn plugin_scoreboard_new(element_size: usize) -> *mut qemu_plugin_scoreboard;
}
unsafe extern "C" {
    pub fn plugin_scoreboard_free(score: *mut qemu_plugin_scoreboard);
}
pub type MIPSCPU = ArchCPU;
pub type ArchCPU_autoptr = *mut ArchCPU;
pub type ArchCPU_listautoptr = *mut GList;
pub type ArchCPU_slistautoptr = *mut GSList;
pub type ArchCPU_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug)]
pub struct DirtyMemoryBlocks {
    pub rcu: rcu_head,
    pub blocks: __IncompleteArrayField<*mut ::std::os::raw::c_ulong>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DirtyMemoryBlocks"][::std::mem::size_of::<DirtyMemoryBlocks>() - 16usize];
    ["Alignment of DirtyMemoryBlocks"][::std::mem::align_of::<DirtyMemoryBlocks>() - 8usize];
    ["Offset of field: DirtyMemoryBlocks::rcu"]
        [::std::mem::offset_of!(DirtyMemoryBlocks, rcu) - 0usize];
    ["Offset of field: DirtyMemoryBlocks::blocks"]
        [::std::mem::offset_of!(DirtyMemoryBlocks, blocks) - 16usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RAMList {
    pub mutex: QemuMutex,
    pub mru_block: *mut RAMBlock,
    pub blocks: RAMList__bindgen_ty_1,
    pub dirty_memory: [*mut DirtyMemoryBlocks; 3usize],
    pub num_dirty_blocks: ::std::os::raw::c_uint,
    pub version: u32,
    pub ramblock_notifiers: RAMList__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RAMList__bindgen_ty_1 {
    pub lh_first: *mut RAMBlock,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RAMList__bindgen_ty_1"][::std::mem::size_of::<RAMList__bindgen_ty_1>() - 8usize];
    ["Alignment of RAMList__bindgen_ty_1"]
        [::std::mem::align_of::<RAMList__bindgen_ty_1>() - 8usize];
    ["Offset of field: RAMList__bindgen_ty_1::lh_first"]
        [::std::mem::offset_of!(RAMList__bindgen_ty_1, lh_first) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RAMList__bindgen_ty_2 {
    pub lh_first: *mut RAMBlockNotifier,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RAMList__bindgen_ty_2"][::std::mem::size_of::<RAMList__bindgen_ty_2>() - 8usize];
    ["Alignment of RAMList__bindgen_ty_2"]
        [::std::mem::align_of::<RAMList__bindgen_ty_2>() - 8usize];
    ["Offset of field: RAMList__bindgen_ty_2::lh_first"]
        [::std::mem::offset_of!(RAMList__bindgen_ty_2, lh_first) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RAMList"][::std::mem::size_of::<RAMList>() - 104usize];
    ["Alignment of RAMList"][::std::mem::align_of::<RAMList>() - 8usize];
    ["Offset of field: RAMList::mutex"][::std::mem::offset_of!(RAMList, mutex) - 0usize];
    ["Offset of field: RAMList::mru_block"][::std::mem::offset_of!(RAMList, mru_block) - 48usize];
    ["Offset of field: RAMList::blocks"][::std::mem::offset_of!(RAMList, blocks) - 56usize];
    ["Offset of field: RAMList::dirty_memory"]
        [::std::mem::offset_of!(RAMList, dirty_memory) - 64usize];
    ["Offset of field: RAMList::num_dirty_blocks"]
        [::std::mem::offset_of!(RAMList, num_dirty_blocks) - 88usize];
    ["Offset of field: RAMList::version"][::std::mem::offset_of!(RAMList, version) - 92usize];
    ["Offset of field: RAMList::ramblock_notifiers"]
        [::std::mem::offset_of!(RAMList, ramblock_notifiers) - 96usize];
};
unsafe extern "C" {
    pub static mut ram_list: RAMList;
}
unsafe extern "C" {
    pub fn qemu_mutex_lock_ramlist();
}
unsafe extern "C" {
    pub fn qemu_mutex_unlock_ramlist();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RAMBlockNotifier {
    pub ram_block_added: ::std::option::Option<
        unsafe extern "C" fn(
            n: *mut RAMBlockNotifier,
            host: *mut ::std::os::raw::c_void,
            size: usize,
            max_size: usize,
        ),
    >,
    pub ram_block_removed: ::std::option::Option<
        unsafe extern "C" fn(
            n: *mut RAMBlockNotifier,
            host: *mut ::std::os::raw::c_void,
            size: usize,
            max_size: usize,
        ),
    >,
    pub ram_block_resized: ::std::option::Option<
        unsafe extern "C" fn(
            n: *mut RAMBlockNotifier,
            host: *mut ::std::os::raw::c_void,
            old_size: usize,
            new_size: usize,
        ),
    >,
    pub next: RAMBlockNotifier__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RAMBlockNotifier__bindgen_ty_1 {
    pub le_next: *mut RAMBlockNotifier,
    pub le_prev: *mut *mut RAMBlockNotifier,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RAMBlockNotifier__bindgen_ty_1"]
        [::std::mem::size_of::<RAMBlockNotifier__bindgen_ty_1>() - 16usize];
    ["Alignment of RAMBlockNotifier__bindgen_ty_1"]
        [::std::mem::align_of::<RAMBlockNotifier__bindgen_ty_1>() - 8usize];
    ["Offset of field: RAMBlockNotifier__bindgen_ty_1::le_next"]
        [::std::mem::offset_of!(RAMBlockNotifier__bindgen_ty_1, le_next) - 0usize];
    ["Offset of field: RAMBlockNotifier__bindgen_ty_1::le_prev"]
        [::std::mem::offset_of!(RAMBlockNotifier__bindgen_ty_1, le_prev) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RAMBlockNotifier"][::std::mem::size_of::<RAMBlockNotifier>() - 40usize];
    ["Alignment of RAMBlockNotifier"][::std::mem::align_of::<RAMBlockNotifier>() - 8usize];
    ["Offset of field: RAMBlockNotifier::ram_block_added"]
        [::std::mem::offset_of!(RAMBlockNotifier, ram_block_added) - 0usize];
    ["Offset of field: RAMBlockNotifier::ram_block_removed"]
        [::std::mem::offset_of!(RAMBlockNotifier, ram_block_removed) - 8usize];
    ["Offset of field: RAMBlockNotifier::ram_block_resized"]
        [::std::mem::offset_of!(RAMBlockNotifier, ram_block_resized) - 16usize];
    ["Offset of field: RAMBlockNotifier::next"]
        [::std::mem::offset_of!(RAMBlockNotifier, next) - 24usize];
};
unsafe extern "C" {
    pub fn ram_block_notifier_add(n: *mut RAMBlockNotifier);
}
unsafe extern "C" {
    pub fn ram_block_notifier_remove(n: *mut RAMBlockNotifier);
}
unsafe extern "C" {
    pub fn ram_block_notify_add(host: *mut ::std::os::raw::c_void, size: usize, max_size: usize);
}
unsafe extern "C" {
    pub fn ram_block_notify_remove(host: *mut ::std::os::raw::c_void, size: usize, max_size: usize);
}
unsafe extern "C" {
    pub fn ram_block_notify_resize(
        host: *mut ::std::os::raw::c_void,
        old_size: usize,
        new_size: usize,
    );
}
unsafe extern "C" {
    pub fn ram_block_format() -> *mut GString;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Range {
    pub lob: u64,
    pub upb: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Range"][::std::mem::size_of::<Range>() - 16usize];
    ["Alignment of Range"][::std::mem::align_of::<Range>() - 8usize];
    ["Offset of field: Range::lob"][::std::mem::offset_of!(Range, lob) - 0usize];
    ["Offset of field: Range::upb"][::std::mem::offset_of!(Range, upb) - 8usize];
};
unsafe extern "C" {
    pub fn range_compare(a: *mut Range, b: *mut Range) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn range_list_insert(list: *mut GList, data: *mut Range) -> *mut GList;
}
unsafe extern "C" {
    pub fn range_inverse_array(
        in_ranges: *mut GList,
        out_ranges: *mut *mut GList,
        low: u64,
        high: u64,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RamDiscardManager {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub static mut global_dirty_tracking: ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReservedRegion {
    pub range: Range,
    pub type_: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ReservedRegion"][::std::mem::size_of::<ReservedRegion>() - 24usize];
    ["Alignment of ReservedRegion"][::std::mem::align_of::<ReservedRegion>() - 8usize];
    ["Offset of field: ReservedRegion::range"]
        [::std::mem::offset_of!(ReservedRegion, range) - 0usize];
    ["Offset of field: ReservedRegion::type_"]
        [::std::mem::offset_of!(ReservedRegion, type_) - 16usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct MemoryRegionSection {
    pub size: Int128,
    pub mr: *mut MemoryRegion,
    pub fv: *mut FlatView,
    pub offset_within_region: hwaddr,
    pub offset_within_address_space: hwaddr,
    pub readonly: bool,
    pub nonvolatile: bool,
    pub unmergeable: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryRegionSection"][::std::mem::size_of::<MemoryRegionSection>() - 64usize];
    ["Alignment of MemoryRegionSection"][::std::mem::align_of::<MemoryRegionSection>() - 16usize];
    ["Offset of field: MemoryRegionSection::size"]
        [::std::mem::offset_of!(MemoryRegionSection, size) - 0usize];
    ["Offset of field: MemoryRegionSection::mr"]
        [::std::mem::offset_of!(MemoryRegionSection, mr) - 16usize];
    ["Offset of field: MemoryRegionSection::fv"]
        [::std::mem::offset_of!(MemoryRegionSection, fv) - 24usize];
    ["Offset of field: MemoryRegionSection::offset_within_region"]
        [::std::mem::offset_of!(MemoryRegionSection, offset_within_region) - 32usize];
    ["Offset of field: MemoryRegionSection::offset_within_address_space"]
        [::std::mem::offset_of!(MemoryRegionSection, offset_within_address_space) - 40usize];
    ["Offset of field: MemoryRegionSection::readonly"]
        [::std::mem::offset_of!(MemoryRegionSection, readonly) - 48usize];
    ["Offset of field: MemoryRegionSection::nonvolatile"]
        [::std::mem::offset_of!(MemoryRegionSection, nonvolatile) - 49usize];
    ["Offset of field: MemoryRegionSection::unmergeable"]
        [::std::mem::offset_of!(MemoryRegionSection, unmergeable) - 50usize];
};
pub const IOMMU_NONE: IOMMUAccessFlags = 0;
pub const IOMMU_RO: IOMMUAccessFlags = 1;
pub const IOMMU_WO: IOMMUAccessFlags = 2;
pub const IOMMU_RW: IOMMUAccessFlags = 3;
pub type IOMMUAccessFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOMMUTLBEntry {
    pub target_as: *mut AddressSpace,
    pub iova: hwaddr,
    pub translated_addr: hwaddr,
    pub addr_mask: hwaddr,
    pub perm: IOMMUAccessFlags,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IOMMUTLBEntry"][::std::mem::size_of::<IOMMUTLBEntry>() - 40usize];
    ["Alignment of IOMMUTLBEntry"][::std::mem::align_of::<IOMMUTLBEntry>() - 8usize];
    ["Offset of field: IOMMUTLBEntry::target_as"]
        [::std::mem::offset_of!(IOMMUTLBEntry, target_as) - 0usize];
    ["Offset of field: IOMMUTLBEntry::iova"][::std::mem::offset_of!(IOMMUTLBEntry, iova) - 8usize];
    ["Offset of field: IOMMUTLBEntry::translated_addr"]
        [::std::mem::offset_of!(IOMMUTLBEntry, translated_addr) - 16usize];
    ["Offset of field: IOMMUTLBEntry::addr_mask"]
        [::std::mem::offset_of!(IOMMUTLBEntry, addr_mask) - 24usize];
    ["Offset of field: IOMMUTLBEntry::perm"][::std::mem::offset_of!(IOMMUTLBEntry, perm) - 32usize];
};
pub const IOMMU_NOTIFIER_NONE: IOMMUNotifierFlag = 0;
pub const IOMMU_NOTIFIER_UNMAP: IOMMUNotifierFlag = 1;
pub const IOMMU_NOTIFIER_MAP: IOMMUNotifierFlag = 2;
pub const IOMMU_NOTIFIER_DEVIOTLB_UNMAP: IOMMUNotifierFlag = 4;
pub type IOMMUNotifierFlag = ::std::os::raw::c_uint;
pub type IOMMUNotify = ::std::option::Option<
    unsafe extern "C" fn(notifier: *mut IOMMUNotifier, data: *mut IOMMUTLBEntry),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOMMUNotifier {
    pub notify: IOMMUNotify,
    pub notifier_flags: IOMMUNotifierFlag,
    pub start: hwaddr,
    pub end: hwaddr,
    pub iommu_idx: ::std::os::raw::c_int,
    pub node: IOMMUNotifier__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOMMUNotifier__bindgen_ty_1 {
    pub le_next: *mut IOMMUNotifier,
    pub le_prev: *mut *mut IOMMUNotifier,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IOMMUNotifier__bindgen_ty_1"]
        [::std::mem::size_of::<IOMMUNotifier__bindgen_ty_1>() - 16usize];
    ["Alignment of IOMMUNotifier__bindgen_ty_1"]
        [::std::mem::align_of::<IOMMUNotifier__bindgen_ty_1>() - 8usize];
    ["Offset of field: IOMMUNotifier__bindgen_ty_1::le_next"]
        [::std::mem::offset_of!(IOMMUNotifier__bindgen_ty_1, le_next) - 0usize];
    ["Offset of field: IOMMUNotifier__bindgen_ty_1::le_prev"]
        [::std::mem::offset_of!(IOMMUNotifier__bindgen_ty_1, le_prev) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IOMMUNotifier"][::std::mem::size_of::<IOMMUNotifier>() - 56usize];
    ["Alignment of IOMMUNotifier"][::std::mem::align_of::<IOMMUNotifier>() - 8usize];
    ["Offset of field: IOMMUNotifier::notify"]
        [::std::mem::offset_of!(IOMMUNotifier, notify) - 0usize];
    ["Offset of field: IOMMUNotifier::notifier_flags"]
        [::std::mem::offset_of!(IOMMUNotifier, notifier_flags) - 8usize];
    ["Offset of field: IOMMUNotifier::start"]
        [::std::mem::offset_of!(IOMMUNotifier, start) - 16usize];
    ["Offset of field: IOMMUNotifier::end"][::std::mem::offset_of!(IOMMUNotifier, end) - 24usize];
    ["Offset of field: IOMMUNotifier::iommu_idx"]
        [::std::mem::offset_of!(IOMMUNotifier, iommu_idx) - 32usize];
    ["Offset of field: IOMMUNotifier::node"][::std::mem::offset_of!(IOMMUNotifier, node) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOMMUTLBEvent {
    pub type_: IOMMUNotifierFlag,
    pub entry: IOMMUTLBEntry,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IOMMUTLBEvent"][::std::mem::size_of::<IOMMUTLBEvent>() - 48usize];
    ["Alignment of IOMMUTLBEvent"][::std::mem::align_of::<IOMMUTLBEvent>() - 8usize];
    ["Offset of field: IOMMUTLBEvent::type_"]
        [::std::mem::offset_of!(IOMMUTLBEvent, type_) - 0usize];
    ["Offset of field: IOMMUTLBEvent::entry"]
        [::std::mem::offset_of!(IOMMUTLBEvent, entry) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryRegionOps {
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            addr: hwaddr,
            size: ::std::os::raw::c_uint,
        ) -> u64,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            addr: hwaddr,
            data: u64,
            size: ::std::os::raw::c_uint,
        ),
    >,
    pub read_with_attrs: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            addr: hwaddr,
            data: *mut u64,
            size: ::std::os::raw::c_uint,
            attrs: MemTxAttrs,
        ) -> MemTxResult,
    >,
    pub write_with_attrs: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            addr: hwaddr,
            data: u64,
            size: ::std::os::raw::c_uint,
            attrs: MemTxAttrs,
        ) -> MemTxResult,
    >,
    pub endianness: device_endian,
    pub valid: MemoryRegionOps__bindgen_ty_1,
    pub impl_: MemoryRegionOps__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryRegionOps__bindgen_ty_1 {
    pub min_access_size: ::std::os::raw::c_uint,
    pub max_access_size: ::std::os::raw::c_uint,
    pub unaligned: bool,
    pub accepts: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            addr: hwaddr,
            size: ::std::os::raw::c_uint,
            is_write: bool,
            attrs: MemTxAttrs,
        ) -> bool,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryRegionOps__bindgen_ty_1"]
        [::std::mem::size_of::<MemoryRegionOps__bindgen_ty_1>() - 24usize];
    ["Alignment of MemoryRegionOps__bindgen_ty_1"]
        [::std::mem::align_of::<MemoryRegionOps__bindgen_ty_1>() - 8usize];
    ["Offset of field: MemoryRegionOps__bindgen_ty_1::min_access_size"]
        [::std::mem::offset_of!(MemoryRegionOps__bindgen_ty_1, min_access_size) - 0usize];
    ["Offset of field: MemoryRegionOps__bindgen_ty_1::max_access_size"]
        [::std::mem::offset_of!(MemoryRegionOps__bindgen_ty_1, max_access_size) - 4usize];
    ["Offset of field: MemoryRegionOps__bindgen_ty_1::unaligned"]
        [::std::mem::offset_of!(MemoryRegionOps__bindgen_ty_1, unaligned) - 8usize];
    ["Offset of field: MemoryRegionOps__bindgen_ty_1::accepts"]
        [::std::mem::offset_of!(MemoryRegionOps__bindgen_ty_1, accepts) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryRegionOps__bindgen_ty_2 {
    pub min_access_size: ::std::os::raw::c_uint,
    pub max_access_size: ::std::os::raw::c_uint,
    pub unaligned: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryRegionOps__bindgen_ty_2"]
        [::std::mem::size_of::<MemoryRegionOps__bindgen_ty_2>() - 12usize];
    ["Alignment of MemoryRegionOps__bindgen_ty_2"]
        [::std::mem::align_of::<MemoryRegionOps__bindgen_ty_2>() - 4usize];
    ["Offset of field: MemoryRegionOps__bindgen_ty_2::min_access_size"]
        [::std::mem::offset_of!(MemoryRegionOps__bindgen_ty_2, min_access_size) - 0usize];
    ["Offset of field: MemoryRegionOps__bindgen_ty_2::max_access_size"]
        [::std::mem::offset_of!(MemoryRegionOps__bindgen_ty_2, max_access_size) - 4usize];
    ["Offset of field: MemoryRegionOps__bindgen_ty_2::unaligned"]
        [::std::mem::offset_of!(MemoryRegionOps__bindgen_ty_2, unaligned) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryRegionOps"][::std::mem::size_of::<MemoryRegionOps>() - 80usize];
    ["Alignment of MemoryRegionOps"][::std::mem::align_of::<MemoryRegionOps>() - 8usize];
    ["Offset of field: MemoryRegionOps::read"]
        [::std::mem::offset_of!(MemoryRegionOps, read) - 0usize];
    ["Offset of field: MemoryRegionOps::write"]
        [::std::mem::offset_of!(MemoryRegionOps, write) - 8usize];
    ["Offset of field: MemoryRegionOps::read_with_attrs"]
        [::std::mem::offset_of!(MemoryRegionOps, read_with_attrs) - 16usize];
    ["Offset of field: MemoryRegionOps::write_with_attrs"]
        [::std::mem::offset_of!(MemoryRegionOps, write_with_attrs) - 24usize];
    ["Offset of field: MemoryRegionOps::endianness"]
        [::std::mem::offset_of!(MemoryRegionOps, endianness) - 32usize];
    ["Offset of field: MemoryRegionOps::valid"]
        [::std::mem::offset_of!(MemoryRegionOps, valid) - 40usize];
    ["Offset of field: MemoryRegionOps::impl_"]
        [::std::mem::offset_of!(MemoryRegionOps, impl_) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryRegionClass {
    pub parent_class: ObjectClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryRegionClass"][::std::mem::size_of::<MemoryRegionClass>() - 96usize];
    ["Alignment of MemoryRegionClass"][::std::mem::align_of::<MemoryRegionClass>() - 8usize];
    ["Offset of field: MemoryRegionClass::parent_class"]
        [::std::mem::offset_of!(MemoryRegionClass, parent_class) - 0usize];
};
pub const IOMMU_ATTR_SPAPR_TCE_FD: IOMMUMemoryRegionAttr = 0;
pub type IOMMUMemoryRegionAttr = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOMMUMemoryRegionClass {
    pub parent_class: MemoryRegionClass,
    pub translate: ::std::option::Option<
        unsafe extern "C" fn(
            iommu: *mut IOMMUMemoryRegion,
            addr: hwaddr,
            flag: IOMMUAccessFlags,
            iommu_idx: ::std::os::raw::c_int,
        ) -> IOMMUTLBEntry,
    >,
    pub get_min_page_size:
        ::std::option::Option<unsafe extern "C" fn(iommu: *mut IOMMUMemoryRegion) -> u64>,
    pub notify_flag_changed: ::std::option::Option<
        unsafe extern "C" fn(
            iommu: *mut IOMMUMemoryRegion,
            old_flags: IOMMUNotifierFlag,
            new_flags: IOMMUNotifierFlag,
            errp: *mut *mut Error,
        ) -> ::std::os::raw::c_int,
    >,
    pub replay: ::std::option::Option<
        unsafe extern "C" fn(iommu: *mut IOMMUMemoryRegion, notifier: *mut IOMMUNotifier),
    >,
    pub get_attr: ::std::option::Option<
        unsafe extern "C" fn(
            iommu: *mut IOMMUMemoryRegion,
            attr: IOMMUMemoryRegionAttr,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub attrs_to_index: ::std::option::Option<
        unsafe extern "C" fn(
            iommu: *mut IOMMUMemoryRegion,
            attrs: MemTxAttrs,
        ) -> ::std::os::raw::c_int,
    >,
    pub num_indexes: ::std::option::Option<
        unsafe extern "C" fn(iommu: *mut IOMMUMemoryRegion) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IOMMUMemoryRegionClass"][::std::mem::size_of::<IOMMUMemoryRegionClass>() - 152usize];
    ["Alignment of IOMMUMemoryRegionClass"]
        [::std::mem::align_of::<IOMMUMemoryRegionClass>() - 8usize];
    ["Offset of field: IOMMUMemoryRegionClass::parent_class"]
        [::std::mem::offset_of!(IOMMUMemoryRegionClass, parent_class) - 0usize];
    ["Offset of field: IOMMUMemoryRegionClass::translate"]
        [::std::mem::offset_of!(IOMMUMemoryRegionClass, translate) - 96usize];
    ["Offset of field: IOMMUMemoryRegionClass::get_min_page_size"]
        [::std::mem::offset_of!(IOMMUMemoryRegionClass, get_min_page_size) - 104usize];
    ["Offset of field: IOMMUMemoryRegionClass::notify_flag_changed"]
        [::std::mem::offset_of!(IOMMUMemoryRegionClass, notify_flag_changed) - 112usize];
    ["Offset of field: IOMMUMemoryRegionClass::replay"]
        [::std::mem::offset_of!(IOMMUMemoryRegionClass, replay) - 120usize];
    ["Offset of field: IOMMUMemoryRegionClass::get_attr"]
        [::std::mem::offset_of!(IOMMUMemoryRegionClass, get_attr) - 128usize];
    ["Offset of field: IOMMUMemoryRegionClass::attrs_to_index"]
        [::std::mem::offset_of!(IOMMUMemoryRegionClass, attrs_to_index) - 136usize];
    ["Offset of field: IOMMUMemoryRegionClass::num_indexes"]
        [::std::mem::offset_of!(IOMMUMemoryRegionClass, num_indexes) - 144usize];
};
pub type NotifyRamPopulate = ::std::option::Option<
    unsafe extern "C" fn(
        rdl: *mut RamDiscardListener,
        section: *mut MemoryRegionSection,
    ) -> ::std::os::raw::c_int,
>;
pub type NotifyRamDiscard = ::std::option::Option<
    unsafe extern "C" fn(rdl: *mut RamDiscardListener, section: *mut MemoryRegionSection),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RamDiscardListener {
    pub notify_populate: NotifyRamPopulate,
    pub notify_discard: NotifyRamDiscard,
    pub double_discard_supported: bool,
    pub section: *mut MemoryRegionSection,
    pub next: RamDiscardListener__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RamDiscardListener__bindgen_ty_1 {
    pub le_next: *mut RamDiscardListener,
    pub le_prev: *mut *mut RamDiscardListener,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RamDiscardListener__bindgen_ty_1"]
        [::std::mem::size_of::<RamDiscardListener__bindgen_ty_1>() - 16usize];
    ["Alignment of RamDiscardListener__bindgen_ty_1"]
        [::std::mem::align_of::<RamDiscardListener__bindgen_ty_1>() - 8usize];
    ["Offset of field: RamDiscardListener__bindgen_ty_1::le_next"]
        [::std::mem::offset_of!(RamDiscardListener__bindgen_ty_1, le_next) - 0usize];
    ["Offset of field: RamDiscardListener__bindgen_ty_1::le_prev"]
        [::std::mem::offset_of!(RamDiscardListener__bindgen_ty_1, le_prev) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RamDiscardListener"][::std::mem::size_of::<RamDiscardListener>() - 48usize];
    ["Alignment of RamDiscardListener"][::std::mem::align_of::<RamDiscardListener>() - 8usize];
    ["Offset of field: RamDiscardListener::notify_populate"]
        [::std::mem::offset_of!(RamDiscardListener, notify_populate) - 0usize];
    ["Offset of field: RamDiscardListener::notify_discard"]
        [::std::mem::offset_of!(RamDiscardListener, notify_discard) - 8usize];
    ["Offset of field: RamDiscardListener::double_discard_supported"]
        [::std::mem::offset_of!(RamDiscardListener, double_discard_supported) - 16usize];
    ["Offset of field: RamDiscardListener::section"]
        [::std::mem::offset_of!(RamDiscardListener, section) - 24usize];
    ["Offset of field: RamDiscardListener::next"]
        [::std::mem::offset_of!(RamDiscardListener, next) - 32usize];
};
pub type ReplayRamPopulate = ::std::option::Option<
    unsafe extern "C" fn(
        section: *mut MemoryRegionSection,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type ReplayRamDiscard = ::std::option::Option<
    unsafe extern "C" fn(section: *mut MemoryRegionSection, opaque: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RamDiscardManagerClass {
    pub parent_class: InterfaceClass,
    pub get_min_granularity: ::std::option::Option<
        unsafe extern "C" fn(rdm: *const RamDiscardManager, mr: *const MemoryRegion) -> u64,
    >,
    pub is_populated: ::std::option::Option<
        unsafe extern "C" fn(
            rdm: *const RamDiscardManager,
            section: *const MemoryRegionSection,
        ) -> bool,
    >,
    pub replay_populated: ::std::option::Option<
        unsafe extern "C" fn(
            rdm: *const RamDiscardManager,
            section: *mut MemoryRegionSection,
            replay_fn: ReplayRamPopulate,
            opaque: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub replay_discarded: ::std::option::Option<
        unsafe extern "C" fn(
            rdm: *const RamDiscardManager,
            section: *mut MemoryRegionSection,
            replay_fn: ReplayRamDiscard,
            opaque: *mut ::std::os::raw::c_void,
        ),
    >,
    pub register_listener: ::std::option::Option<
        unsafe extern "C" fn(
            rdm: *mut RamDiscardManager,
            rdl: *mut RamDiscardListener,
            section: *mut MemoryRegionSection,
        ),
    >,
    pub unregister_listener: ::std::option::Option<
        unsafe extern "C" fn(rdm: *mut RamDiscardManager, rdl: *mut RamDiscardListener),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RamDiscardManagerClass"][::std::mem::size_of::<RamDiscardManagerClass>() - 152usize];
    ["Alignment of RamDiscardManagerClass"]
        [::std::mem::align_of::<RamDiscardManagerClass>() - 8usize];
    ["Offset of field: RamDiscardManagerClass::parent_class"]
        [::std::mem::offset_of!(RamDiscardManagerClass, parent_class) - 0usize];
    ["Offset of field: RamDiscardManagerClass::get_min_granularity"]
        [::std::mem::offset_of!(RamDiscardManagerClass, get_min_granularity) - 104usize];
    ["Offset of field: RamDiscardManagerClass::is_populated"]
        [::std::mem::offset_of!(RamDiscardManagerClass, is_populated) - 112usize];
    ["Offset of field: RamDiscardManagerClass::replay_populated"]
        [::std::mem::offset_of!(RamDiscardManagerClass, replay_populated) - 120usize];
    ["Offset of field: RamDiscardManagerClass::replay_discarded"]
        [::std::mem::offset_of!(RamDiscardManagerClass, replay_discarded) - 128usize];
    ["Offset of field: RamDiscardManagerClass::register_listener"]
        [::std::mem::offset_of!(RamDiscardManagerClass, register_listener) - 136usize];
    ["Offset of field: RamDiscardManagerClass::unregister_listener"]
        [::std::mem::offset_of!(RamDiscardManagerClass, unregister_listener) - 144usize];
};
unsafe extern "C" {
    pub fn ram_discard_manager_get_min_granularity(
        rdm: *const RamDiscardManager,
        mr: *const MemoryRegion,
    ) -> u64;
}
unsafe extern "C" {
    pub fn ram_discard_manager_is_populated(
        rdm: *const RamDiscardManager,
        section: *const MemoryRegionSection,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ram_discard_manager_replay_populated(
        rdm: *const RamDiscardManager,
        section: *mut MemoryRegionSection,
        replay_fn: ReplayRamPopulate,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ram_discard_manager_replay_discarded(
        rdm: *const RamDiscardManager,
        section: *mut MemoryRegionSection,
        replay_fn: ReplayRamDiscard,
        opaque: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn ram_discard_manager_register_listener(
        rdm: *mut RamDiscardManager,
        rdl: *mut RamDiscardListener,
        section: *mut MemoryRegionSection,
    );
}
unsafe extern "C" {
    pub fn ram_discard_manager_unregister_listener(
        rdm: *mut RamDiscardManager,
        rdl: *mut RamDiscardListener,
    );
}
unsafe extern "C" {
    pub fn memory_get_xlat_addr(
        iotlb: *mut IOMMUTLBEntry,
        vaddr: *mut *mut ::std::os::raw::c_void,
        ram_addr: *mut ram_addr_t,
        read_only: *mut bool,
        mr_has_discard_manager: *mut bool,
        errp: *mut *mut Error,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoalescedMemoryRange {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryRegionIoeventfd {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct MemoryRegion {
    pub parent_obj: Object,
    pub romd_mode: bool,
    pub ram: bool,
    pub subpage: bool,
    pub readonly: bool,
    pub nonvolatile: bool,
    pub rom_device: bool,
    pub flush_coalesced_mmio: bool,
    pub unmergeable: bool,
    pub dirty_log_mask: u8,
    pub is_iommu: bool,
    pub ram_block: *mut RAMBlock,
    pub owner: *mut Object,
    pub dev: *mut DeviceState,
    pub ops: *const MemoryRegionOps,
    pub opaque: *mut ::std::os::raw::c_void,
    pub container: *mut MemoryRegion,
    pub mapped_via_alias: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u64; 0usize],
    pub size: Int128,
    pub addr: hwaddr,
    pub destructor: ::std::option::Option<unsafe extern "C" fn(mr: *mut MemoryRegion)>,
    pub align: u64,
    pub terminates: bool,
    pub ram_device: bool,
    pub enabled: bool,
    pub vga_logging_count: u8,
    pub alias: *mut MemoryRegion,
    pub alias_offset: hwaddr,
    pub priority: i32,
    pub subregions: MemoryRegion__bindgen_ty_1,
    pub subregions_link: MemoryRegion__bindgen_ty_2,
    pub coalesced: MemoryRegion__bindgen_ty_3,
    pub name: *const ::std::os::raw::c_char,
    pub ioeventfd_nb: ::std::os::raw::c_uint,
    pub ioeventfds: *mut MemoryRegionIoeventfd,
    pub rdm: *mut RamDiscardManager,
    pub disable_reentrancy_guard: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MemoryRegion__bindgen_ty_1 {
    pub tqh_first: *mut MemoryRegion,
    pub tqh_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryRegion__bindgen_ty_1"]
        [::std::mem::size_of::<MemoryRegion__bindgen_ty_1>() - 16usize];
    ["Alignment of MemoryRegion__bindgen_ty_1"]
        [::std::mem::align_of::<MemoryRegion__bindgen_ty_1>() - 8usize];
    ["Offset of field: MemoryRegion__bindgen_ty_1::tqh_first"]
        [::std::mem::offset_of!(MemoryRegion__bindgen_ty_1, tqh_first) - 0usize];
    ["Offset of field: MemoryRegion__bindgen_ty_1::tqh_circ"]
        [::std::mem::offset_of!(MemoryRegion__bindgen_ty_1, tqh_circ) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union MemoryRegion__bindgen_ty_2 {
    pub tqe_next: *mut MemoryRegion,
    pub tqe_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryRegion__bindgen_ty_2"]
        [::std::mem::size_of::<MemoryRegion__bindgen_ty_2>() - 16usize];
    ["Alignment of MemoryRegion__bindgen_ty_2"]
        [::std::mem::align_of::<MemoryRegion__bindgen_ty_2>() - 8usize];
    ["Offset of field: MemoryRegion__bindgen_ty_2::tqe_next"]
        [::std::mem::offset_of!(MemoryRegion__bindgen_ty_2, tqe_next) - 0usize];
    ["Offset of field: MemoryRegion__bindgen_ty_2::tqe_circ"]
        [::std::mem::offset_of!(MemoryRegion__bindgen_ty_2, tqe_circ) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union MemoryRegion__bindgen_ty_3 {
    pub tqh_first: *mut CoalescedMemoryRange,
    pub tqh_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryRegion__bindgen_ty_3"]
        [::std::mem::size_of::<MemoryRegion__bindgen_ty_3>() - 16usize];
    ["Alignment of MemoryRegion__bindgen_ty_3"]
        [::std::mem::align_of::<MemoryRegion__bindgen_ty_3>() - 8usize];
    ["Offset of field: MemoryRegion__bindgen_ty_3::tqh_first"]
        [::std::mem::offset_of!(MemoryRegion__bindgen_ty_3, tqh_first) - 0usize];
    ["Offset of field: MemoryRegion__bindgen_ty_3::tqh_circ"]
        [::std::mem::offset_of!(MemoryRegion__bindgen_ty_3, tqh_circ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryRegion"][::std::mem::size_of::<MemoryRegion>() - 272usize];
    ["Alignment of MemoryRegion"][::std::mem::align_of::<MemoryRegion>() - 16usize];
    ["Offset of field: MemoryRegion::parent_obj"]
        [::std::mem::offset_of!(MemoryRegion, parent_obj) - 0usize];
    ["Offset of field: MemoryRegion::romd_mode"]
        [::std::mem::offset_of!(MemoryRegion, romd_mode) - 40usize];
    ["Offset of field: MemoryRegion::ram"][::std::mem::offset_of!(MemoryRegion, ram) - 41usize];
    ["Offset of field: MemoryRegion::subpage"]
        [::std::mem::offset_of!(MemoryRegion, subpage) - 42usize];
    ["Offset of field: MemoryRegion::readonly"]
        [::std::mem::offset_of!(MemoryRegion, readonly) - 43usize];
    ["Offset of field: MemoryRegion::nonvolatile"]
        [::std::mem::offset_of!(MemoryRegion, nonvolatile) - 44usize];
    ["Offset of field: MemoryRegion::rom_device"]
        [::std::mem::offset_of!(MemoryRegion, rom_device) - 45usize];
    ["Offset of field: MemoryRegion::flush_coalesced_mmio"]
        [::std::mem::offset_of!(MemoryRegion, flush_coalesced_mmio) - 46usize];
    ["Offset of field: MemoryRegion::unmergeable"]
        [::std::mem::offset_of!(MemoryRegion, unmergeable) - 47usize];
    ["Offset of field: MemoryRegion::dirty_log_mask"]
        [::std::mem::offset_of!(MemoryRegion, dirty_log_mask) - 48usize];
    ["Offset of field: MemoryRegion::is_iommu"]
        [::std::mem::offset_of!(MemoryRegion, is_iommu) - 49usize];
    ["Offset of field: MemoryRegion::ram_block"]
        [::std::mem::offset_of!(MemoryRegion, ram_block) - 56usize];
    ["Offset of field: MemoryRegion::owner"][::std::mem::offset_of!(MemoryRegion, owner) - 64usize];
    ["Offset of field: MemoryRegion::dev"][::std::mem::offset_of!(MemoryRegion, dev) - 72usize];
    ["Offset of field: MemoryRegion::ops"][::std::mem::offset_of!(MemoryRegion, ops) - 80usize];
    ["Offset of field: MemoryRegion::opaque"]
        [::std::mem::offset_of!(MemoryRegion, opaque) - 88usize];
    ["Offset of field: MemoryRegion::container"]
        [::std::mem::offset_of!(MemoryRegion, container) - 96usize];
    ["Offset of field: MemoryRegion::mapped_via_alias"]
        [::std::mem::offset_of!(MemoryRegion, mapped_via_alias) - 104usize];
    ["Offset of field: MemoryRegion::size"][::std::mem::offset_of!(MemoryRegion, size) - 112usize];
    ["Offset of field: MemoryRegion::addr"][::std::mem::offset_of!(MemoryRegion, addr) - 128usize];
    ["Offset of field: MemoryRegion::destructor"]
        [::std::mem::offset_of!(MemoryRegion, destructor) - 136usize];
    ["Offset of field: MemoryRegion::align"]
        [::std::mem::offset_of!(MemoryRegion, align) - 144usize];
    ["Offset of field: MemoryRegion::terminates"]
        [::std::mem::offset_of!(MemoryRegion, terminates) - 152usize];
    ["Offset of field: MemoryRegion::ram_device"]
        [::std::mem::offset_of!(MemoryRegion, ram_device) - 153usize];
    ["Offset of field: MemoryRegion::enabled"]
        [::std::mem::offset_of!(MemoryRegion, enabled) - 154usize];
    ["Offset of field: MemoryRegion::vga_logging_count"]
        [::std::mem::offset_of!(MemoryRegion, vga_logging_count) - 155usize];
    ["Offset of field: MemoryRegion::alias"]
        [::std::mem::offset_of!(MemoryRegion, alias) - 160usize];
    ["Offset of field: MemoryRegion::alias_offset"]
        [::std::mem::offset_of!(MemoryRegion, alias_offset) - 168usize];
    ["Offset of field: MemoryRegion::priority"]
        [::std::mem::offset_of!(MemoryRegion, priority) - 176usize];
    ["Offset of field: MemoryRegion::subregions"]
        [::std::mem::offset_of!(MemoryRegion, subregions) - 184usize];
    ["Offset of field: MemoryRegion::subregions_link"]
        [::std::mem::offset_of!(MemoryRegion, subregions_link) - 200usize];
    ["Offset of field: MemoryRegion::coalesced"]
        [::std::mem::offset_of!(MemoryRegion, coalesced) - 216usize];
    ["Offset of field: MemoryRegion::name"][::std::mem::offset_of!(MemoryRegion, name) - 232usize];
    ["Offset of field: MemoryRegion::ioeventfd_nb"]
        [::std::mem::offset_of!(MemoryRegion, ioeventfd_nb) - 240usize];
    ["Offset of field: MemoryRegion::ioeventfds"]
        [::std::mem::offset_of!(MemoryRegion, ioeventfds) - 248usize];
    ["Offset of field: MemoryRegion::rdm"][::std::mem::offset_of!(MemoryRegion, rdm) - 256usize];
    ["Offset of field: MemoryRegion::disable_reentrancy_guard"]
        [::std::mem::offset_of!(MemoryRegion, disable_reentrancy_guard) - 264usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct IOMMUMemoryRegion {
    pub parent_obj: MemoryRegion,
    pub iommu_notify: IOMMUMemoryRegion__bindgen_ty_1,
    pub iommu_notify_flags: IOMMUNotifierFlag,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOMMUMemoryRegion__bindgen_ty_1 {
    pub lh_first: *mut IOMMUNotifier,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IOMMUMemoryRegion__bindgen_ty_1"]
        [::std::mem::size_of::<IOMMUMemoryRegion__bindgen_ty_1>() - 8usize];
    ["Alignment of IOMMUMemoryRegion__bindgen_ty_1"]
        [::std::mem::align_of::<IOMMUMemoryRegion__bindgen_ty_1>() - 8usize];
    ["Offset of field: IOMMUMemoryRegion__bindgen_ty_1::lh_first"]
        [::std::mem::offset_of!(IOMMUMemoryRegion__bindgen_ty_1, lh_first) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IOMMUMemoryRegion"][::std::mem::size_of::<IOMMUMemoryRegion>() - 288usize];
    ["Alignment of IOMMUMemoryRegion"][::std::mem::align_of::<IOMMUMemoryRegion>() - 16usize];
    ["Offset of field: IOMMUMemoryRegion::parent_obj"]
        [::std::mem::offset_of!(IOMMUMemoryRegion, parent_obj) - 0usize];
    ["Offset of field: IOMMUMemoryRegion::iommu_notify"]
        [::std::mem::offset_of!(IOMMUMemoryRegion, iommu_notify) - 272usize];
    ["Offset of field: IOMMUMemoryRegion::iommu_notify_flags"]
        [::std::mem::offset_of!(IOMMUMemoryRegion, iommu_notify_flags) - 280usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryListener {
    pub begin: ::std::option::Option<unsafe extern "C" fn(listener: *mut MemoryListener)>,
    pub commit: ::std::option::Option<unsafe extern "C" fn(listener: *mut MemoryListener)>,
    pub region_add: ::std::option::Option<
        unsafe extern "C" fn(listener: *mut MemoryListener, section: *mut MemoryRegionSection),
    >,
    pub region_del: ::std::option::Option<
        unsafe extern "C" fn(listener: *mut MemoryListener, section: *mut MemoryRegionSection),
    >,
    pub region_nop: ::std::option::Option<
        unsafe extern "C" fn(listener: *mut MemoryListener, section: *mut MemoryRegionSection),
    >,
    pub log_start: ::std::option::Option<
        unsafe extern "C" fn(
            listener: *mut MemoryListener,
            section: *mut MemoryRegionSection,
            old_val: ::std::os::raw::c_int,
            new_val: ::std::os::raw::c_int,
        ),
    >,
    pub log_stop: ::std::option::Option<
        unsafe extern "C" fn(
            listener: *mut MemoryListener,
            section: *mut MemoryRegionSection,
            old_val: ::std::os::raw::c_int,
            new_val: ::std::os::raw::c_int,
        ),
    >,
    pub log_sync: ::std::option::Option<
        unsafe extern "C" fn(listener: *mut MemoryListener, section: *mut MemoryRegionSection),
    >,
    pub log_sync_global: ::std::option::Option<
        unsafe extern "C" fn(listener: *mut MemoryListener, last_stage: bool),
    >,
    pub log_clear: ::std::option::Option<
        unsafe extern "C" fn(listener: *mut MemoryListener, section: *mut MemoryRegionSection),
    >,
    pub log_global_start: ::std::option::Option<
        unsafe extern "C" fn(listener: *mut MemoryListener, errp: *mut *mut Error) -> bool,
    >,
    pub log_global_stop: ::std::option::Option<unsafe extern "C" fn(listener: *mut MemoryListener)>,
    pub log_global_after_sync:
        ::std::option::Option<unsafe extern "C" fn(listener: *mut MemoryListener)>,
    pub eventfd_add: ::std::option::Option<
        unsafe extern "C" fn(
            listener: *mut MemoryListener,
            section: *mut MemoryRegionSection,
            match_data: bool,
            data: u64,
            e: *mut EventNotifier,
        ),
    >,
    pub eventfd_del: ::std::option::Option<
        unsafe extern "C" fn(
            listener: *mut MemoryListener,
            section: *mut MemoryRegionSection,
            match_data: bool,
            data: u64,
            e: *mut EventNotifier,
        ),
    >,
    pub coalesced_io_add: ::std::option::Option<
        unsafe extern "C" fn(
            listener: *mut MemoryListener,
            section: *mut MemoryRegionSection,
            addr: hwaddr,
            len: hwaddr,
        ),
    >,
    pub coalesced_io_del: ::std::option::Option<
        unsafe extern "C" fn(
            listener: *mut MemoryListener,
            section: *mut MemoryRegionSection,
            addr: hwaddr,
            len: hwaddr,
        ),
    >,
    pub priority: ::std::os::raw::c_uint,
    pub name: *const ::std::os::raw::c_char,
    pub address_space: *mut AddressSpace,
    pub link: MemoryListener__bindgen_ty_1,
    pub link_as: MemoryListener__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MemoryListener__bindgen_ty_1 {
    pub tqe_next: *mut MemoryListener,
    pub tqe_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryListener__bindgen_ty_1"]
        [::std::mem::size_of::<MemoryListener__bindgen_ty_1>() - 16usize];
    ["Alignment of MemoryListener__bindgen_ty_1"]
        [::std::mem::align_of::<MemoryListener__bindgen_ty_1>() - 8usize];
    ["Offset of field: MemoryListener__bindgen_ty_1::tqe_next"]
        [::std::mem::offset_of!(MemoryListener__bindgen_ty_1, tqe_next) - 0usize];
    ["Offset of field: MemoryListener__bindgen_ty_1::tqe_circ"]
        [::std::mem::offset_of!(MemoryListener__bindgen_ty_1, tqe_circ) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union MemoryListener__bindgen_ty_2 {
    pub tqe_next: *mut MemoryListener,
    pub tqe_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryListener__bindgen_ty_2"]
        [::std::mem::size_of::<MemoryListener__bindgen_ty_2>() - 16usize];
    ["Alignment of MemoryListener__bindgen_ty_2"]
        [::std::mem::align_of::<MemoryListener__bindgen_ty_2>() - 8usize];
    ["Offset of field: MemoryListener__bindgen_ty_2::tqe_next"]
        [::std::mem::offset_of!(MemoryListener__bindgen_ty_2, tqe_next) - 0usize];
    ["Offset of field: MemoryListener__bindgen_ty_2::tqe_circ"]
        [::std::mem::offset_of!(MemoryListener__bindgen_ty_2, tqe_circ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryListener"][::std::mem::size_of::<MemoryListener>() - 192usize];
    ["Alignment of MemoryListener"][::std::mem::align_of::<MemoryListener>() - 8usize];
    ["Offset of field: MemoryListener::begin"]
        [::std::mem::offset_of!(MemoryListener, begin) - 0usize];
    ["Offset of field: MemoryListener::commit"]
        [::std::mem::offset_of!(MemoryListener, commit) - 8usize];
    ["Offset of field: MemoryListener::region_add"]
        [::std::mem::offset_of!(MemoryListener, region_add) - 16usize];
    ["Offset of field: MemoryListener::region_del"]
        [::std::mem::offset_of!(MemoryListener, region_del) - 24usize];
    ["Offset of field: MemoryListener::region_nop"]
        [::std::mem::offset_of!(MemoryListener, region_nop) - 32usize];
    ["Offset of field: MemoryListener::log_start"]
        [::std::mem::offset_of!(MemoryListener, log_start) - 40usize];
    ["Offset of field: MemoryListener::log_stop"]
        [::std::mem::offset_of!(MemoryListener, log_stop) - 48usize];
    ["Offset of field: MemoryListener::log_sync"]
        [::std::mem::offset_of!(MemoryListener, log_sync) - 56usize];
    ["Offset of field: MemoryListener::log_sync_global"]
        [::std::mem::offset_of!(MemoryListener, log_sync_global) - 64usize];
    ["Offset of field: MemoryListener::log_clear"]
        [::std::mem::offset_of!(MemoryListener, log_clear) - 72usize];
    ["Offset of field: MemoryListener::log_global_start"]
        [::std::mem::offset_of!(MemoryListener, log_global_start) - 80usize];
    ["Offset of field: MemoryListener::log_global_stop"]
        [::std::mem::offset_of!(MemoryListener, log_global_stop) - 88usize];
    ["Offset of field: MemoryListener::log_global_after_sync"]
        [::std::mem::offset_of!(MemoryListener, log_global_after_sync) - 96usize];
    ["Offset of field: MemoryListener::eventfd_add"]
        [::std::mem::offset_of!(MemoryListener, eventfd_add) - 104usize];
    ["Offset of field: MemoryListener::eventfd_del"]
        [::std::mem::offset_of!(MemoryListener, eventfd_del) - 112usize];
    ["Offset of field: MemoryListener::coalesced_io_add"]
        [::std::mem::offset_of!(MemoryListener, coalesced_io_add) - 120usize];
    ["Offset of field: MemoryListener::coalesced_io_del"]
        [::std::mem::offset_of!(MemoryListener, coalesced_io_del) - 128usize];
    ["Offset of field: MemoryListener::priority"]
        [::std::mem::offset_of!(MemoryListener, priority) - 136usize];
    ["Offset of field: MemoryListener::name"]
        [::std::mem::offset_of!(MemoryListener, name) - 144usize];
    ["Offset of field: MemoryListener::address_space"]
        [::std::mem::offset_of!(MemoryListener, address_space) - 152usize];
    ["Offset of field: MemoryListener::link"]
        [::std::mem::offset_of!(MemoryListener, link) - 160usize];
    ["Offset of field: MemoryListener::link_as"]
        [::std::mem::offset_of!(MemoryListener, link_as) - 176usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AddressSpaceMapClient {
    pub bh: *mut QEMUBH,
    pub link: AddressSpaceMapClient__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AddressSpaceMapClient__bindgen_ty_1 {
    pub le_next: *mut AddressSpaceMapClient,
    pub le_prev: *mut *mut AddressSpaceMapClient,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AddressSpaceMapClient__bindgen_ty_1"]
        [::std::mem::size_of::<AddressSpaceMapClient__bindgen_ty_1>() - 16usize];
    ["Alignment of AddressSpaceMapClient__bindgen_ty_1"]
        [::std::mem::align_of::<AddressSpaceMapClient__bindgen_ty_1>() - 8usize];
    ["Offset of field: AddressSpaceMapClient__bindgen_ty_1::le_next"]
        [::std::mem::offset_of!(AddressSpaceMapClient__bindgen_ty_1, le_next) - 0usize];
    ["Offset of field: AddressSpaceMapClient__bindgen_ty_1::le_prev"]
        [::std::mem::offset_of!(AddressSpaceMapClient__bindgen_ty_1, le_prev) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AddressSpaceMapClient"][::std::mem::size_of::<AddressSpaceMapClient>() - 24usize];
    ["Alignment of AddressSpaceMapClient"]
        [::std::mem::align_of::<AddressSpaceMapClient>() - 8usize];
    ["Offset of field: AddressSpaceMapClient::bh"]
        [::std::mem::offset_of!(AddressSpaceMapClient, bh) - 0usize];
    ["Offset of field: AddressSpaceMapClient::link"]
        [::std::mem::offset_of!(AddressSpaceMapClient, link) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AddressSpace {
    pub rcu: rcu_head,
    pub name: *mut ::std::os::raw::c_char,
    pub root: *mut MemoryRegion,
    pub current_map: *mut FlatView,
    pub ioeventfd_nb: ::std::os::raw::c_int,
    pub ioeventfd_notifiers: ::std::os::raw::c_int,
    pub ioeventfds: *mut MemoryRegionIoeventfd,
    pub listeners: AddressSpace__bindgen_ty_1,
    pub address_spaces_link: AddressSpace__bindgen_ty_2,
    pub max_bounce_buffer_size: usize,
    pub bounce_buffer_size: usize,
    pub map_client_list_lock: QemuMutex,
    pub map_client_list: AddressSpace__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AddressSpace__bindgen_ty_1 {
    pub tqh_first: *mut MemoryListener,
    pub tqh_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AddressSpace__bindgen_ty_1"]
        [::std::mem::size_of::<AddressSpace__bindgen_ty_1>() - 16usize];
    ["Alignment of AddressSpace__bindgen_ty_1"]
        [::std::mem::align_of::<AddressSpace__bindgen_ty_1>() - 8usize];
    ["Offset of field: AddressSpace__bindgen_ty_1::tqh_first"]
        [::std::mem::offset_of!(AddressSpace__bindgen_ty_1, tqh_first) - 0usize];
    ["Offset of field: AddressSpace__bindgen_ty_1::tqh_circ"]
        [::std::mem::offset_of!(AddressSpace__bindgen_ty_1, tqh_circ) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union AddressSpace__bindgen_ty_2 {
    pub tqe_next: *mut AddressSpace,
    pub tqe_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AddressSpace__bindgen_ty_2"]
        [::std::mem::size_of::<AddressSpace__bindgen_ty_2>() - 16usize];
    ["Alignment of AddressSpace__bindgen_ty_2"]
        [::std::mem::align_of::<AddressSpace__bindgen_ty_2>() - 8usize];
    ["Offset of field: AddressSpace__bindgen_ty_2::tqe_next"]
        [::std::mem::offset_of!(AddressSpace__bindgen_ty_2, tqe_next) - 0usize];
    ["Offset of field: AddressSpace__bindgen_ty_2::tqe_circ"]
        [::std::mem::offset_of!(AddressSpace__bindgen_ty_2, tqe_circ) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AddressSpace__bindgen_ty_3 {
    pub lh_first: *mut AddressSpaceMapClient,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AddressSpace__bindgen_ty_3"]
        [::std::mem::size_of::<AddressSpace__bindgen_ty_3>() - 8usize];
    ["Alignment of AddressSpace__bindgen_ty_3"]
        [::std::mem::align_of::<AddressSpace__bindgen_ty_3>() - 8usize];
    ["Offset of field: AddressSpace__bindgen_ty_3::lh_first"]
        [::std::mem::offset_of!(AddressSpace__bindgen_ty_3, lh_first) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AddressSpace"][::std::mem::size_of::<AddressSpace>() - 160usize];
    ["Alignment of AddressSpace"][::std::mem::align_of::<AddressSpace>() - 8usize];
    ["Offset of field: AddressSpace::rcu"][::std::mem::offset_of!(AddressSpace, rcu) - 0usize];
    ["Offset of field: AddressSpace::name"][::std::mem::offset_of!(AddressSpace, name) - 16usize];
    ["Offset of field: AddressSpace::root"][::std::mem::offset_of!(AddressSpace, root) - 24usize];
    ["Offset of field: AddressSpace::current_map"]
        [::std::mem::offset_of!(AddressSpace, current_map) - 32usize];
    ["Offset of field: AddressSpace::ioeventfd_nb"]
        [::std::mem::offset_of!(AddressSpace, ioeventfd_nb) - 40usize];
    ["Offset of field: AddressSpace::ioeventfd_notifiers"]
        [::std::mem::offset_of!(AddressSpace, ioeventfd_notifiers) - 44usize];
    ["Offset of field: AddressSpace::ioeventfds"]
        [::std::mem::offset_of!(AddressSpace, ioeventfds) - 48usize];
    ["Offset of field: AddressSpace::listeners"]
        [::std::mem::offset_of!(AddressSpace, listeners) - 56usize];
    ["Offset of field: AddressSpace::address_spaces_link"]
        [::std::mem::offset_of!(AddressSpace, address_spaces_link) - 72usize];
    ["Offset of field: AddressSpace::max_bounce_buffer_size"]
        [::std::mem::offset_of!(AddressSpace, max_bounce_buffer_size) - 88usize];
    ["Offset of field: AddressSpace::bounce_buffer_size"]
        [::std::mem::offset_of!(AddressSpace, bounce_buffer_size) - 96usize];
    ["Offset of field: AddressSpace::map_client_list_lock"]
        [::std::mem::offset_of!(AddressSpace, map_client_list_lock) - 104usize];
    ["Offset of field: AddressSpace::map_client_list"]
        [::std::mem::offset_of!(AddressSpace, map_client_list) - 152usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AddressSpaceDispatch {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlatRange {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlatView {
    pub rcu: rcu_head,
    pub ref_: ::std::os::raw::c_uint,
    pub ranges: *mut FlatRange,
    pub nr: ::std::os::raw::c_uint,
    pub nr_allocated: ::std::os::raw::c_uint,
    pub dispatch: *mut AddressSpaceDispatch,
    pub root: *mut MemoryRegion,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlatView"][::std::mem::size_of::<FlatView>() - 56usize];
    ["Alignment of FlatView"][::std::mem::align_of::<FlatView>() - 8usize];
    ["Offset of field: FlatView::rcu"][::std::mem::offset_of!(FlatView, rcu) - 0usize];
    ["Offset of field: FlatView::ref_"][::std::mem::offset_of!(FlatView, ref_) - 16usize];
    ["Offset of field: FlatView::ranges"][::std::mem::offset_of!(FlatView, ranges) - 24usize];
    ["Offset of field: FlatView::nr"][::std::mem::offset_of!(FlatView, nr) - 32usize];
    ["Offset of field: FlatView::nr_allocated"]
        [::std::mem::offset_of!(FlatView, nr_allocated) - 36usize];
    ["Offset of field: FlatView::dispatch"][::std::mem::offset_of!(FlatView, dispatch) - 40usize];
    ["Offset of field: FlatView::root"][::std::mem::offset_of!(FlatView, root) - 48usize];
};
pub type flatview_cb = ::std::option::Option<
    unsafe extern "C" fn(
        start: Int128,
        len: Int128,
        mr: *const MemoryRegion,
        offset_in_region: hwaddr,
        opaque: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
unsafe extern "C" {
    pub fn flatview_for_each_range(
        fv: *mut FlatView,
        cb: flatview_cb,
        opaque: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn memory_region_section_new_copy(s: *mut MemoryRegionSection) -> *mut MemoryRegionSection;
}
unsafe extern "C" {
    pub fn memory_region_section_free_copy(s: *mut MemoryRegionSection);
}
unsafe extern "C" {
    pub fn memory_region_init(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const ::std::os::raw::c_char,
        size: u64,
    );
}
unsafe extern "C" {
    pub fn memory_region_ref(mr: *mut MemoryRegion);
}
unsafe extern "C" {
    pub fn memory_region_unref(mr: *mut MemoryRegion);
}
unsafe extern "C" {
    pub fn memory_region_init_io(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        ops: *const MemoryRegionOps,
        opaque: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        size: u64,
    );
}
unsafe extern "C" {
    pub fn memory_region_init_ram_nomigrate(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const ::std::os::raw::c_char,
        size: u64,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_init_ram_flags_nomigrate(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const ::std::os::raw::c_char,
        size: u64,
        ram_flags: u32,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_init_resizeable_ram(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const ::std::os::raw::c_char,
        size: u64,
        max_size: u64,
        resized: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                length: u64,
                host: *mut ::std::os::raw::c_void,
            ),
        >,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_init_ram_from_file(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const ::std::os::raw::c_char,
        size: u64,
        align: u64,
        ram_flags: u32,
        path: *const ::std::os::raw::c_char,
        offset: ram_addr_t,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_init_ram_from_fd(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const ::std::os::raw::c_char,
        size: u64,
        ram_flags: u32,
        fd: ::std::os::raw::c_int,
        offset: ram_addr_t,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_init_ram_ptr(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const ::std::os::raw::c_char,
        size: u64,
        ptr: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn memory_region_init_ram_device_ptr(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const ::std::os::raw::c_char,
        size: u64,
        ptr: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn memory_region_init_alias(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const ::std::os::raw::c_char,
        orig: *mut MemoryRegion,
        offset: hwaddr,
        size: u64,
    );
}
unsafe extern "C" {
    pub fn memory_region_init_rom_nomigrate(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const ::std::os::raw::c_char,
        size: u64,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_init_rom_device_nomigrate(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        ops: *const MemoryRegionOps,
        opaque: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        size: u64,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_init_iommu(
        _iommu_mr: *mut ::std::os::raw::c_void,
        instance_size: usize,
        mrtypename: *const ::std::os::raw::c_char,
        owner: *mut Object,
        name: *const ::std::os::raw::c_char,
        size: u64,
    );
}
unsafe extern "C" {
    pub fn memory_region_init_ram(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const ::std::os::raw::c_char,
        size: u64,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_init_ram_guest_memfd(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const ::std::os::raw::c_char,
        size: u64,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_init_rom(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const ::std::os::raw::c_char,
        size: u64,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_init_rom_device(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        ops: *const MemoryRegionOps,
        opaque: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        size: u64,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_owner(mr: *mut MemoryRegion) -> *mut Object;
}
unsafe extern "C" {
    pub fn memory_region_size(mr: *mut MemoryRegion) -> u64;
}
unsafe extern "C" {
    pub fn memory_region_is_ram_device(mr: *mut MemoryRegion) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_is_protected(mr: *mut MemoryRegion) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_has_guest_memfd(mr: *mut MemoryRegion) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_iommu_get_min_page_size(iommu_mr: *mut IOMMUMemoryRegion) -> u64;
}
unsafe extern "C" {
    pub fn memory_region_notify_iommu(
        iommu_mr: *mut IOMMUMemoryRegion,
        iommu_idx: ::std::os::raw::c_int,
        event: IOMMUTLBEvent,
    );
}
unsafe extern "C" {
    pub fn memory_region_notify_iommu_one(
        notifier: *mut IOMMUNotifier,
        event: *const IOMMUTLBEvent,
    );
}
unsafe extern "C" {
    pub fn memory_region_unmap_iommu_notifier_range(notifier: *mut IOMMUNotifier);
}
unsafe extern "C" {
    pub fn memory_region_register_iommu_notifier(
        mr: *mut MemoryRegion,
        n: *mut IOMMUNotifier,
        errp: *mut *mut Error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memory_region_iommu_replay(iommu_mr: *mut IOMMUMemoryRegion, n: *mut IOMMUNotifier);
}
unsafe extern "C" {
    pub fn memory_region_unregister_iommu_notifier(mr: *mut MemoryRegion, n: *mut IOMMUNotifier);
}
unsafe extern "C" {
    pub fn memory_region_iommu_get_attr(
        iommu_mr: *mut IOMMUMemoryRegion,
        attr: IOMMUMemoryRegionAttr,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memory_region_iommu_attrs_to_index(
        iommu_mr: *mut IOMMUMemoryRegion,
        attrs: MemTxAttrs,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memory_region_iommu_num_indexes(
        iommu_mr: *mut IOMMUMemoryRegion,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memory_region_name(mr: *const MemoryRegion) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memory_region_is_logging(mr: *mut MemoryRegion, client: u8) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_get_dirty_log_mask(mr: *mut MemoryRegion) -> u8;
}
unsafe extern "C" {
    pub fn memory_region_get_fd(mr: *mut MemoryRegion) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memory_region_from_host(
        ptr: *mut ::std::os::raw::c_void,
        offset: *mut ram_addr_t,
    ) -> *mut MemoryRegion;
}
unsafe extern "C" {
    pub fn memory_region_get_ram_ptr(mr: *mut MemoryRegion) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memory_region_ram_resize(
        mr: *mut MemoryRegion,
        newsize: ram_addr_t,
        errp: *mut *mut Error,
    );
}
unsafe extern "C" {
    pub fn memory_region_msync(mr: *mut MemoryRegion, addr: hwaddr, size: hwaddr);
}
unsafe extern "C" {
    pub fn memory_region_writeback(mr: *mut MemoryRegion, addr: hwaddr, size: hwaddr);
}
unsafe extern "C" {
    pub fn memory_region_set_log(mr: *mut MemoryRegion, log: bool, client: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn memory_region_set_dirty(mr: *mut MemoryRegion, addr: hwaddr, size: hwaddr);
}
unsafe extern "C" {
    pub fn memory_region_clear_dirty_bitmap(mr: *mut MemoryRegion, start: hwaddr, len: hwaddr);
}
unsafe extern "C" {
    pub fn memory_region_snapshot_and_clear_dirty(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        size: hwaddr,
        client: ::std::os::raw::c_uint,
    ) -> *mut DirtyBitmapSnapshot;
}
unsafe extern "C" {
    pub fn memory_region_snapshot_get_dirty(
        mr: *mut MemoryRegion,
        snap: *mut DirtyBitmapSnapshot,
        addr: hwaddr,
        size: hwaddr,
    ) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_reset_dirty(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        size: hwaddr,
        client: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn memory_region_flush_rom_device(mr: *mut MemoryRegion, addr: hwaddr, size: hwaddr);
}
unsafe extern "C" {
    pub fn memory_region_set_readonly(mr: *mut MemoryRegion, readonly: bool);
}
unsafe extern "C" {
    pub fn memory_region_set_nonvolatile(mr: *mut MemoryRegion, nonvolatile: bool);
}
unsafe extern "C" {
    pub fn memory_region_rom_device_set_romd(mr: *mut MemoryRegion, romd_mode: bool);
}
unsafe extern "C" {
    pub fn memory_region_set_coalescing(mr: *mut MemoryRegion);
}
unsafe extern "C" {
    pub fn memory_region_add_coalescing(mr: *mut MemoryRegion, offset: hwaddr, size: u64);
}
unsafe extern "C" {
    pub fn memory_region_clear_coalescing(mr: *mut MemoryRegion);
}
unsafe extern "C" {
    pub fn memory_region_set_flush_coalesced(mr: *mut MemoryRegion);
}
unsafe extern "C" {
    pub fn memory_region_clear_flush_coalesced(mr: *mut MemoryRegion);
}
unsafe extern "C" {
    pub fn memory_region_add_eventfd(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        size: ::std::os::raw::c_uint,
        match_data: bool,
        data: u64,
        e: *mut EventNotifier,
    );
}
unsafe extern "C" {
    pub fn memory_region_del_eventfd(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        size: ::std::os::raw::c_uint,
        match_data: bool,
        data: u64,
        e: *mut EventNotifier,
    );
}
unsafe extern "C" {
    pub fn memory_region_add_subregion(
        mr: *mut MemoryRegion,
        offset: hwaddr,
        subregion: *mut MemoryRegion,
    );
}
unsafe extern "C" {
    pub fn memory_region_add_subregion_overlap(
        mr: *mut MemoryRegion,
        offset: hwaddr,
        subregion: *mut MemoryRegion,
        priority: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn memory_region_get_ram_addr(mr: *mut MemoryRegion) -> ram_addr_t;
}
unsafe extern "C" {
    pub fn memory_region_get_alignment(mr: *const MemoryRegion) -> u64;
}
unsafe extern "C" {
    pub fn memory_region_del_subregion(mr: *mut MemoryRegion, subregion: *mut MemoryRegion);
}
unsafe extern "C" {
    pub fn memory_region_set_enabled(mr: *mut MemoryRegion, enabled: bool);
}
unsafe extern "C" {
    pub fn memory_region_set_address(mr: *mut MemoryRegion, addr: hwaddr);
}
unsafe extern "C" {
    pub fn memory_region_set_size(mr: *mut MemoryRegion, size: u64);
}
unsafe extern "C" {
    pub fn memory_region_set_alias_offset(mr: *mut MemoryRegion, offset: hwaddr);
}
unsafe extern "C" {
    pub fn memory_region_set_unmergeable(mr: *mut MemoryRegion, unmergeable: bool);
}
unsafe extern "C" {
    pub fn memory_region_present(container: *mut MemoryRegion, addr: hwaddr) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_is_mapped(mr: *mut MemoryRegion) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_get_ram_discard_manager(mr: *mut MemoryRegion) -> *mut RamDiscardManager;
}
unsafe extern "C" {
    pub fn memory_region_set_ram_discard_manager(
        mr: *mut MemoryRegion,
        rdm: *mut RamDiscardManager,
    );
}
unsafe extern "C" {
    pub fn memory_region_find(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        size: u64,
    ) -> MemoryRegionSection;
}
unsafe extern "C" {
    pub fn memory_global_dirty_log_sync(last_stage: bool);
}
unsafe extern "C" {
    pub fn memory_global_after_dirty_log_sync();
}
unsafe extern "C" {
    pub fn memory_region_transaction_begin();
}
unsafe extern "C" {
    pub fn memory_region_transaction_commit();
}
unsafe extern "C" {
    pub fn memory_listener_register(listener: *mut MemoryListener, filter: *mut AddressSpace);
}
unsafe extern "C" {
    pub fn memory_listener_unregister(listener: *mut MemoryListener);
}
unsafe extern "C" {
    pub fn memory_global_dirty_log_start(
        flags: ::std::os::raw::c_uint,
        errp: *mut *mut Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn memory_global_dirty_log_stop(flags: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn mtree_info(flatview: bool, dispatch_tree: bool, owner: bool, disabled: bool);
}
unsafe extern "C" {
    pub fn memory_region_access_valid(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        size: ::std::os::raw::c_uint,
        is_write: bool,
        attrs: MemTxAttrs,
    ) -> bool;
}
unsafe extern "C" {
    pub fn memory_region_dispatch_read(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        pval: *mut u64,
        op: MemOp,
        attrs: MemTxAttrs,
    ) -> MemTxResult;
}
unsafe extern "C" {
    pub fn memory_region_dispatch_write(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        data: u64,
        op: MemOp,
        attrs: MemTxAttrs,
    ) -> MemTxResult;
}
unsafe extern "C" {
    pub fn address_space_init(
        as_: *mut AddressSpace,
        root: *mut MemoryRegion,
        name: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn address_space_destroy(as_: *mut AddressSpace);
}
unsafe extern "C" {
    pub fn address_space_remove_listeners(as_: *mut AddressSpace);
}
unsafe extern "C" {
    pub fn address_space_rw(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        buf: *mut ::std::os::raw::c_void,
        len: hwaddr,
        is_write: bool,
    ) -> MemTxResult;
}
unsafe extern "C" {
    pub fn address_space_write(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        buf: *const ::std::os::raw::c_void,
        len: hwaddr,
    ) -> MemTxResult;
}
unsafe extern "C" {
    pub fn address_space_write_rom(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        buf: *const ::std::os::raw::c_void,
        len: hwaddr,
    ) -> MemTxResult;
}
unsafe extern "C" {
    pub fn address_space_ldub(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u8;
}
unsafe extern "C" {
    pub fn address_space_lduw_le(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u16;
}
unsafe extern "C" {
    pub fn address_space_lduw_be(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u16;
}
unsafe extern "C" {
    pub fn address_space_ldl_le(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u32;
}
unsafe extern "C" {
    pub fn address_space_ldl_be(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u32;
}
unsafe extern "C" {
    pub fn address_space_ldq_le(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u64;
}
unsafe extern "C" {
    pub fn address_space_ldq_be(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u64;
}
unsafe extern "C" {
    pub fn address_space_stb(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u8,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stw_le(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u16,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stw_be(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u16,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stl_le(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u32,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stl_be(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u32,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stq_le(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u64,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stq_be(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u64,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct MemoryRegionCache {
    pub ptr: *mut u8,
    pub xlat: hwaddr,
    pub len: hwaddr,
    pub fv: *mut FlatView,
    pub mrs: MemoryRegionSection,
    pub is_write: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MemoryRegionCache"][::std::mem::size_of::<MemoryRegionCache>() - 112usize];
    ["Alignment of MemoryRegionCache"][::std::mem::align_of::<MemoryRegionCache>() - 16usize];
    ["Offset of field: MemoryRegionCache::ptr"]
        [::std::mem::offset_of!(MemoryRegionCache, ptr) - 0usize];
    ["Offset of field: MemoryRegionCache::xlat"]
        [::std::mem::offset_of!(MemoryRegionCache, xlat) - 8usize];
    ["Offset of field: MemoryRegionCache::len"]
        [::std::mem::offset_of!(MemoryRegionCache, len) - 16usize];
    ["Offset of field: MemoryRegionCache::fv"]
        [::std::mem::offset_of!(MemoryRegionCache, fv) - 24usize];
    ["Offset of field: MemoryRegionCache::mrs"]
        [::std::mem::offset_of!(MemoryRegionCache, mrs) - 32usize];
    ["Offset of field: MemoryRegionCache::is_write"]
        [::std::mem::offset_of!(MemoryRegionCache, is_write) - 96usize];
};
unsafe extern "C" {
    pub fn address_space_ldub_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u8;
}
unsafe extern "C" {
    pub fn address_space_lduw_le_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u16;
}
unsafe extern "C" {
    pub fn address_space_lduw_be_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u16;
}
unsafe extern "C" {
    pub fn address_space_ldl_le_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u32;
}
unsafe extern "C" {
    pub fn address_space_ldl_be_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u32;
}
unsafe extern "C" {
    pub fn address_space_ldq_le_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u64;
}
unsafe extern "C" {
    pub fn address_space_ldq_be_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u64;
}
unsafe extern "C" {
    pub fn address_space_stb_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u8,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stw_le_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u16,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stw_be_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u16,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stl_le_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u32,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stl_be_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u32,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stq_le_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u64,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stq_be_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u64,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_cache_init(
        cache: *mut MemoryRegionCache,
        as_: *mut AddressSpace,
        addr: hwaddr,
        len: hwaddr,
        is_write: bool,
    ) -> i64;
}
unsafe extern "C" {
    pub fn address_space_cache_invalidate(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        access_len: hwaddr,
    );
}
unsafe extern "C" {
    pub fn address_space_cache_destroy(cache: *mut MemoryRegionCache);
}
unsafe extern "C" {
    pub fn address_space_get_iotlb_entry(
        as_: *mut AddressSpace,
        addr: hwaddr,
        is_write: bool,
        attrs: MemTxAttrs,
    ) -> IOMMUTLBEntry;
}
unsafe extern "C" {
    pub fn flatview_translate(
        fv: *mut FlatView,
        addr: hwaddr,
        xlat: *mut hwaddr,
        len: *mut hwaddr,
        is_write: bool,
        attrs: MemTxAttrs,
    ) -> *mut MemoryRegion;
}
unsafe extern "C" {
    pub fn address_space_access_valid(
        as_: *mut AddressSpace,
        addr: hwaddr,
        len: hwaddr,
        is_write: bool,
        attrs: MemTxAttrs,
    ) -> bool;
}
unsafe extern "C" {
    pub fn address_space_map(
        as_: *mut AddressSpace,
        addr: hwaddr,
        plen: *mut hwaddr,
        is_write: bool,
        attrs: MemTxAttrs,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn address_space_unmap(
        as_: *mut AddressSpace,
        buffer: *mut ::std::os::raw::c_void,
        len: hwaddr,
        is_write: bool,
        access_len: hwaddr,
    );
}
unsafe extern "C" {
    pub fn address_space_register_map_client(as_: *mut AddressSpace, bh: *mut QEMUBH);
}
unsafe extern "C" {
    pub fn address_space_unregister_map_client(as_: *mut AddressSpace, bh: *mut QEMUBH);
}
unsafe extern "C" {
    pub fn address_space_read_full(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        buf: *mut ::std::os::raw::c_void,
        len: hwaddr,
    ) -> MemTxResult;
}
unsafe extern "C" {
    pub fn flatview_read_continue(
        fv: *mut FlatView,
        addr: hwaddr,
        attrs: MemTxAttrs,
        buf: *mut ::std::os::raw::c_void,
        len: hwaddr,
        addr1: hwaddr,
        l: hwaddr,
        mr: *mut MemoryRegion,
    ) -> MemTxResult;
}
unsafe extern "C" {
    pub fn qemu_map_ram_ptr(
        ram_block: *mut RAMBlock,
        addr: ram_addr_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn address_space_read_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        buf: *mut ::std::os::raw::c_void,
        len: hwaddr,
    ) -> MemTxResult;
}
unsafe extern "C" {
    pub fn address_space_write_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        buf: *const ::std::os::raw::c_void,
        len: hwaddr,
    ) -> MemTxResult;
}
unsafe extern "C" {
    pub fn memory_access_size(
        mr: *mut MemoryRegion,
        l: ::std::os::raw::c_uint,
        addr: hwaddr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn prepare_mmio_access(mr: *mut MemoryRegion) -> bool;
}
unsafe extern "C" {
    pub fn address_space_set(
        as_: *mut AddressSpace,
        addr: hwaddr,
        c: u8,
        len: hwaddr,
        attrs: MemTxAttrs,
    ) -> MemTxResult;
}
unsafe extern "C" {
    pub fn ram_block_discard_disable(state: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ram_block_uncoordinated_discard_disable(state: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ram_block_discard_require(state: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ram_block_coordinated_discard_require(state: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ram_block_discard_is_disabled() -> bool;
}
unsafe extern "C" {
    pub fn ram_block_discard_is_required() -> bool;
}
pub type float16 = u16;
pub type float32 = u32;
pub type float64 = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct floatx80 {
    pub low: u64,
    pub high: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of floatx80"][::std::mem::size_of::<floatx80>() - 16usize];
    ["Alignment of floatx80"][::std::mem::align_of::<floatx80>() - 8usize];
    ["Offset of field: floatx80::low"][::std::mem::offset_of!(floatx80, low) - 0usize];
    ["Offset of field: floatx80::high"][::std::mem::offset_of!(floatx80, high) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float128 {
    pub low: u64,
    pub high: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of float128"][::std::mem::size_of::<float128>() - 16usize];
    ["Alignment of float128"][::std::mem::align_of::<float128>() - 8usize];
    ["Offset of field: float128::low"][::std::mem::offset_of!(float128, low) - 0usize];
    ["Offset of field: float128::high"][::std::mem::offset_of!(float128, high) - 8usize];
};
pub type bfloat16 = u16;
pub const float_round_nearest_even: FloatRoundMode = 0;
pub const float_round_down: FloatRoundMode = 1;
pub const float_round_up: FloatRoundMode = 2;
pub const float_round_to_zero: FloatRoundMode = 3;
pub const float_round_ties_away: FloatRoundMode = 4;
pub const float_round_to_odd: FloatRoundMode = 5;
pub const float_round_to_odd_inf: FloatRoundMode = 6;
pub const float_round_nearest_even_max: FloatRoundMode = 7;
pub type FloatRoundMode = ::std::os::raw::c_uchar;
pub const float_flag_invalid: _bindgen_ty_39 = 1;
pub const float_flag_divbyzero: _bindgen_ty_39 = 2;
pub const float_flag_overflow: _bindgen_ty_39 = 4;
pub const float_flag_underflow: _bindgen_ty_39 = 8;
pub const float_flag_inexact: _bindgen_ty_39 = 16;
pub const float_flag_input_denormal_flushed: _bindgen_ty_39 = 32;
pub const float_flag_output_denormal_flushed: _bindgen_ty_39 = 64;
pub const float_flag_invalid_isi: _bindgen_ty_39 = 128;
pub const float_flag_invalid_imz: _bindgen_ty_39 = 256;
pub const float_flag_invalid_idi: _bindgen_ty_39 = 512;
pub const float_flag_invalid_zdz: _bindgen_ty_39 = 1024;
pub const float_flag_invalid_sqrt: _bindgen_ty_39 = 2048;
pub const float_flag_invalid_cvti: _bindgen_ty_39 = 4096;
pub const float_flag_invalid_snan: _bindgen_ty_39 = 8192;
pub type _bindgen_ty_39 = ::std::os::raw::c_uint;
pub const floatx80_precision_x: FloatX80RoundPrec = 0;
pub const floatx80_precision_d: FloatX80RoundPrec = 1;
pub const floatx80_precision_s: FloatX80RoundPrec = 2;
pub type FloatX80RoundPrec = ::std::os::raw::c_uchar;
pub const float_2nan_prop_none: Float2NaNPropRule = 0;
pub const float_2nan_prop_s_ab: Float2NaNPropRule = 1;
pub const float_2nan_prop_s_ba: Float2NaNPropRule = 2;
pub const float_2nan_prop_ab: Float2NaNPropRule = 3;
pub const float_2nan_prop_ba: Float2NaNPropRule = 4;
pub const float_2nan_prop_x87: Float2NaNPropRule = 5;
pub type Float2NaNPropRule = ::std::os::raw::c_uchar;
pub const R_3NAN_1ST_SHIFT: _bindgen_ty_40 = 0;
pub type _bindgen_ty_40 = ::std::os::raw::c_uint;
pub const R_3NAN_1ST_LENGTH: _bindgen_ty_41 = 2;
pub type _bindgen_ty_41 = ::std::os::raw::c_uint;
pub const R_3NAN_1ST_MASK: _bindgen_ty_42 = 3;
pub type _bindgen_ty_42 = ::std::os::raw::c_uint;
pub const R_3NAN_2ND_SHIFT: _bindgen_ty_43 = 2;
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
pub const R_3NAN_2ND_LENGTH: _bindgen_ty_44 = 2;
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
pub const R_3NAN_2ND_MASK: _bindgen_ty_45 = 12;
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
pub const R_3NAN_3RD_SHIFT: _bindgen_ty_46 = 4;
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
pub const R_3NAN_3RD_LENGTH: _bindgen_ty_47 = 2;
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
pub const R_3NAN_3RD_MASK: _bindgen_ty_48 = 48;
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
pub const R_3NAN_SNAN_SHIFT: _bindgen_ty_49 = 6;
pub type _bindgen_ty_49 = ::std::os::raw::c_uint;
pub const R_3NAN_SNAN_LENGTH: _bindgen_ty_50 = 1;
pub type _bindgen_ty_50 = ::std::os::raw::c_uint;
pub const R_3NAN_SNAN_MASK: _bindgen_ty_51 = 64;
pub type _bindgen_ty_51 = ::std::os::raw::c_uint;
pub const float_3nan_prop_none: Float3NaNPropRule = 0;
pub const float_3nan_prop_abc: Float3NaNPropRule = 36;
pub const float_3nan_prop_acb: Float3NaNPropRule = 24;
pub const float_3nan_prop_bac: Float3NaNPropRule = 33;
pub const float_3nan_prop_bca: Float3NaNPropRule = 9;
pub const float_3nan_prop_cab: Float3NaNPropRule = 18;
pub const float_3nan_prop_cba: Float3NaNPropRule = 6;
pub const float_3nan_prop_s_abc: Float3NaNPropRule = 100;
pub const float_3nan_prop_s_acb: Float3NaNPropRule = 88;
pub const float_3nan_prop_s_bac: Float3NaNPropRule = 97;
pub const float_3nan_prop_s_bca: Float3NaNPropRule = 73;
pub const float_3nan_prop_s_cab: Float3NaNPropRule = 82;
pub const float_3nan_prop_s_cba: Float3NaNPropRule = 70;
pub type Float3NaNPropRule = ::std::os::raw::c_uchar;
pub const float_infzeronan_none: FloatInfZeroNaNRule = 0;
pub const float_infzeronan_dnan_never: FloatInfZeroNaNRule = 1;
pub const float_infzeronan_dnan_always: FloatInfZeroNaNRule = 2;
pub const float_infzeronan_dnan_if_qnan: FloatInfZeroNaNRule = 3;
pub type FloatInfZeroNaNRule = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float_status {
    pub float_exception_flags: u16,
    pub float_rounding_mode: FloatRoundMode,
    pub floatx80_rounding_precision: FloatX80RoundPrec,
    pub float_2nan_prop_rule: Float2NaNPropRule,
    pub float_3nan_prop_rule: Float3NaNPropRule,
    pub float_infzeronan_rule: FloatInfZeroNaNRule,
    pub tininess_before_rounding: bool,
    pub flush_to_zero: bool,
    pub flush_inputs_to_zero: bool,
    pub default_nan_mode: bool,
    pub default_nan_pattern: u8,
    pub snan_bit_is_one: bool,
    pub no_signaling_nans: bool,
    pub rebias_overflow: bool,
    pub rebias_underflow: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of float_status"][::std::mem::size_of::<float_status>() - 16usize];
    ["Alignment of float_status"][::std::mem::align_of::<float_status>() - 2usize];
    ["Offset of field: float_status::float_exception_flags"]
        [::std::mem::offset_of!(float_status, float_exception_flags) - 0usize];
    ["Offset of field: float_status::float_rounding_mode"]
        [::std::mem::offset_of!(float_status, float_rounding_mode) - 2usize];
    ["Offset of field: float_status::floatx80_rounding_precision"]
        [::std::mem::offset_of!(float_status, floatx80_rounding_precision) - 3usize];
    ["Offset of field: float_status::float_2nan_prop_rule"]
        [::std::mem::offset_of!(float_status, float_2nan_prop_rule) - 4usize];
    ["Offset of field: float_status::float_3nan_prop_rule"]
        [::std::mem::offset_of!(float_status, float_3nan_prop_rule) - 5usize];
    ["Offset of field: float_status::float_infzeronan_rule"]
        [::std::mem::offset_of!(float_status, float_infzeronan_rule) - 6usize];
    ["Offset of field: float_status::tininess_before_rounding"]
        [::std::mem::offset_of!(float_status, tininess_before_rounding) - 7usize];
    ["Offset of field: float_status::flush_to_zero"]
        [::std::mem::offset_of!(float_status, flush_to_zero) - 8usize];
    ["Offset of field: float_status::flush_inputs_to_zero"]
        [::std::mem::offset_of!(float_status, flush_inputs_to_zero) - 9usize];
    ["Offset of field: float_status::default_nan_mode"]
        [::std::mem::offset_of!(float_status, default_nan_mode) - 10usize];
    ["Offset of field: float_status::default_nan_pattern"]
        [::std::mem::offset_of!(float_status, default_nan_pattern) - 11usize];
    ["Offset of field: float_status::snan_bit_is_one"]
        [::std::mem::offset_of!(float_status, snan_bit_is_one) - 12usize];
    ["Offset of field: float_status::no_signaling_nans"]
        [::std::mem::offset_of!(float_status, no_signaling_nans) - 13usize];
    ["Offset of field: float_status::rebias_overflow"]
        [::std::mem::offset_of!(float_status, rebias_overflow) - 14usize];
    ["Offset of field: float_status::rebias_underflow"]
        [::std::mem::offset_of!(float_status, rebias_underflow) - 15usize];
};
pub type Clock_autoptr = *mut Clock;
pub type Clock_listautoptr = *mut GList;
pub type Clock_slistautoptr = *mut GSList;
pub type Clock_queueautoptr = *mut GQueue;
pub const ClockUpdate: ClockEvent = 1;
pub const ClockPreUpdate: ClockEvent = 2;
pub type ClockEvent = ::std::os::raw::c_uint;
pub type ClockCallback = ::std::option::Option<
    unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, event: ClockEvent),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Clock {
    pub parent_obj: Object,
    pub period: u64,
    pub canonical_path: *mut ::std::os::raw::c_char,
    pub callback: ClockCallback,
    pub callback_opaque: *mut ::std::os::raw::c_void,
    pub callback_events: ::std::os::raw::c_uint,
    pub multiplier: u32,
    pub divider: u32,
    pub source: *mut Clock,
    pub children: Clock__bindgen_ty_1,
    pub sibling: Clock__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Clock__bindgen_ty_1 {
    pub lh_first: *mut Clock,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Clock__bindgen_ty_1"][::std::mem::size_of::<Clock__bindgen_ty_1>() - 8usize];
    ["Alignment of Clock__bindgen_ty_1"][::std::mem::align_of::<Clock__bindgen_ty_1>() - 8usize];
    ["Offset of field: Clock__bindgen_ty_1::lh_first"]
        [::std::mem::offset_of!(Clock__bindgen_ty_1, lh_first) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Clock__bindgen_ty_2 {
    pub le_next: *mut Clock,
    pub le_prev: *mut *mut Clock,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Clock__bindgen_ty_2"][::std::mem::size_of::<Clock__bindgen_ty_2>() - 16usize];
    ["Alignment of Clock__bindgen_ty_2"][::std::mem::align_of::<Clock__bindgen_ty_2>() - 8usize];
    ["Offset of field: Clock__bindgen_ty_2::le_next"]
        [::std::mem::offset_of!(Clock__bindgen_ty_2, le_next) - 0usize];
    ["Offset of field: Clock__bindgen_ty_2::le_prev"]
        [::std::mem::offset_of!(Clock__bindgen_ty_2, le_prev) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Clock"][::std::mem::size_of::<Clock>() - 120usize];
    ["Alignment of Clock"][::std::mem::align_of::<Clock>() - 8usize];
    ["Offset of field: Clock::parent_obj"][::std::mem::offset_of!(Clock, parent_obj) - 0usize];
    ["Offset of field: Clock::period"][::std::mem::offset_of!(Clock, period) - 40usize];
    ["Offset of field: Clock::canonical_path"]
        [::std::mem::offset_of!(Clock, canonical_path) - 48usize];
    ["Offset of field: Clock::callback"][::std::mem::offset_of!(Clock, callback) - 56usize];
    ["Offset of field: Clock::callback_opaque"]
        [::std::mem::offset_of!(Clock, callback_opaque) - 64usize];
    ["Offset of field: Clock::callback_events"]
        [::std::mem::offset_of!(Clock, callback_events) - 72usize];
    ["Offset of field: Clock::multiplier"][::std::mem::offset_of!(Clock, multiplier) - 76usize];
    ["Offset of field: Clock::divider"][::std::mem::offset_of!(Clock, divider) - 80usize];
    ["Offset of field: Clock::source"][::std::mem::offset_of!(Clock, source) - 88usize];
    ["Offset of field: Clock::children"][::std::mem::offset_of!(Clock, children) - 96usize];
    ["Offset of field: Clock::sibling"][::std::mem::offset_of!(Clock, sibling) - 104usize];
};
unsafe extern "C" {
    pub static vmstate_clock: VMStateDescription;
}
unsafe extern "C" {
    pub fn clock_setup_canonical_path(clk: *mut Clock);
}
unsafe extern "C" {
    pub fn clock_new(parent: *mut Object, name: *const ::std::os::raw::c_char) -> *mut Clock;
}
unsafe extern "C" {
    pub fn clock_set_callback(
        clk: *mut Clock,
        cb: ClockCallback,
        opaque: *mut ::std::os::raw::c_void,
        events: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn clock_set_source(clk: *mut Clock, src: *mut Clock);
}
unsafe extern "C" {
    pub fn clock_set(clk: *mut Clock, value: u64) -> bool;
}
unsafe extern "C" {
    pub fn clock_propagate(clk: *mut Clock);
}
unsafe extern "C" {
    pub fn clock_display_freq(clk: *mut Clock) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn clock_set_mul_div(clk: *mut Clock, multiplier: u32, divider: u32) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUMIPSTLBContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wr_t {
    pub b: [i8; 16usize],
    pub h: [i16; 8usize],
    pub w: [i32; 4usize],
    pub d: [i64; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wr_t"][::std::mem::size_of::<wr_t>() - 16usize];
    ["Alignment of wr_t"][::std::mem::align_of::<wr_t>() - 8usize];
    ["Offset of field: wr_t::b"][::std::mem::offset_of!(wr_t, b) - 0usize];
    ["Offset of field: wr_t::h"][::std::mem::offset_of!(wr_t, h) - 0usize];
    ["Offset of field: wr_t::w"][::std::mem::offset_of!(wr_t, w) - 0usize];
    ["Offset of field: wr_t::d"][::std::mem::offset_of!(wr_t, d) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union fpr_t {
    pub fd: float64,
    pub fs: [float32; 2usize],
    pub d: u64,
    pub w: [u32; 2usize],
    pub wr: wr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fpr_t"][::std::mem::size_of::<fpr_t>() - 16usize];
    ["Alignment of fpr_t"][::std::mem::align_of::<fpr_t>() - 8usize];
    ["Offset of field: fpr_t::fd"][::std::mem::offset_of!(fpr_t, fd) - 0usize];
    ["Offset of field: fpr_t::fs"][::std::mem::offset_of!(fpr_t, fs) - 0usize];
    ["Offset of field: fpr_t::d"][::std::mem::offset_of!(fpr_t, d) - 0usize];
    ["Offset of field: fpr_t::w"][::std::mem::offset_of!(fpr_t, w) - 0usize];
    ["Offset of field: fpr_t::wr"][::std::mem::offset_of!(fpr_t, wr) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CPUMIPSFPUContext {
    pub fpr: [fpr_t; 32usize],
    pub fp_status: float_status,
    pub fcr0: u32,
    pub fcr31_rw_bitmask: u32,
    pub fcr31: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUMIPSFPUContext"][::std::mem::size_of::<CPUMIPSFPUContext>() - 544usize];
    ["Alignment of CPUMIPSFPUContext"][::std::mem::align_of::<CPUMIPSFPUContext>() - 8usize];
    ["Offset of field: CPUMIPSFPUContext::fpr"]
        [::std::mem::offset_of!(CPUMIPSFPUContext, fpr) - 0usize];
    ["Offset of field: CPUMIPSFPUContext::fp_status"]
        [::std::mem::offset_of!(CPUMIPSFPUContext, fp_status) - 512usize];
    ["Offset of field: CPUMIPSFPUContext::fcr0"]
        [::std::mem::offset_of!(CPUMIPSFPUContext, fcr0) - 528usize];
    ["Offset of field: CPUMIPSFPUContext::fcr31_rw_bitmask"]
        [::std::mem::offset_of!(CPUMIPSFPUContext, fcr31_rw_bitmask) - 532usize];
    ["Offset of field: CPUMIPSFPUContext::fcr31"]
        [::std::mem::offset_of!(CPUMIPSFPUContext, fcr31) - 536usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUMIPSMVPContext {
    pub CP0_MVPControl: i32,
    pub CP0_MVPConf0: i32,
    pub CP0_MVPConf1: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUMIPSMVPContext"][::std::mem::size_of::<CPUMIPSMVPContext>() - 12usize];
    ["Alignment of CPUMIPSMVPContext"][::std::mem::align_of::<CPUMIPSMVPContext>() - 4usize];
    ["Offset of field: CPUMIPSMVPContext::CP0_MVPControl"]
        [::std::mem::offset_of!(CPUMIPSMVPContext, CP0_MVPControl) - 0usize];
    ["Offset of field: CPUMIPSMVPContext::CP0_MVPConf0"]
        [::std::mem::offset_of!(CPUMIPSMVPContext, CP0_MVPConf0) - 4usize];
    ["Offset of field: CPUMIPSMVPContext::CP0_MVPConf1"]
        [::std::mem::offset_of!(CPUMIPSMVPContext, CP0_MVPConf1) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mips_def_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCState {
    pub gpr: [target_ulong; 32usize],
    pub PC: target_ulong,
    pub HI: [target_ulong; 4usize],
    pub LO: [target_ulong; 4usize],
    pub ACX: [target_ulong; 4usize],
    pub DSPControl: target_ulong,
    pub CP0_TCStatus: i32,
    pub CP0_TCBind: i32,
    pub CP0_TCHalt: target_ulong,
    pub CP0_TCContext: target_ulong,
    pub CP0_TCSchedule: target_ulong,
    pub CP0_TCScheFBack: target_ulong,
    pub CP0_Debug_tcstatus: i32,
    pub CP0_UserLocal: target_ulong,
    pub msacsr: i32,
    pub msa_fp_status: float_status,
    pub mxu_gpr: [target_ulong; 15usize],
    pub mxu_cr: target_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCState"][::std::mem::size_of::<TCState>() - 300usize];
    ["Alignment of TCState"][::std::mem::align_of::<TCState>() - 4usize];
    ["Offset of field: TCState::gpr"][::std::mem::offset_of!(TCState, gpr) - 0usize];
    ["Offset of field: TCState::PC"][::std::mem::offset_of!(TCState, PC) - 128usize];
    ["Offset of field: TCState::HI"][::std::mem::offset_of!(TCState, HI) - 132usize];
    ["Offset of field: TCState::LO"][::std::mem::offset_of!(TCState, LO) - 148usize];
    ["Offset of field: TCState::ACX"][::std::mem::offset_of!(TCState, ACX) - 164usize];
    ["Offset of field: TCState::DSPControl"]
        [::std::mem::offset_of!(TCState, DSPControl) - 180usize];
    ["Offset of field: TCState::CP0_TCStatus"]
        [::std::mem::offset_of!(TCState, CP0_TCStatus) - 184usize];
    ["Offset of field: TCState::CP0_TCBind"]
        [::std::mem::offset_of!(TCState, CP0_TCBind) - 188usize];
    ["Offset of field: TCState::CP0_TCHalt"]
        [::std::mem::offset_of!(TCState, CP0_TCHalt) - 192usize];
    ["Offset of field: TCState::CP0_TCContext"]
        [::std::mem::offset_of!(TCState, CP0_TCContext) - 196usize];
    ["Offset of field: TCState::CP0_TCSchedule"]
        [::std::mem::offset_of!(TCState, CP0_TCSchedule) - 200usize];
    ["Offset of field: TCState::CP0_TCScheFBack"]
        [::std::mem::offset_of!(TCState, CP0_TCScheFBack) - 204usize];
    ["Offset of field: TCState::CP0_Debug_tcstatus"]
        [::std::mem::offset_of!(TCState, CP0_Debug_tcstatus) - 208usize];
    ["Offset of field: TCState::CP0_UserLocal"]
        [::std::mem::offset_of!(TCState, CP0_UserLocal) - 212usize];
    ["Offset of field: TCState::msacsr"][::std::mem::offset_of!(TCState, msacsr) - 216usize];
    ["Offset of field: TCState::msa_fp_status"]
        [::std::mem::offset_of!(TCState, msa_fp_status) - 220usize];
    ["Offset of field: TCState::mxu_gpr"][::std::mem::offset_of!(TCState, mxu_gpr) - 236usize];
    ["Offset of field: TCState::mxu_cr"][::std::mem::offset_of!(TCState, mxu_cr) - 296usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MIPSITUState {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct CPUArchState {
    pub active_tc: TCState,
    pub active_fpu: CPUMIPSFPUContext,
    pub current_tc: u32,
    pub SEGBITS: u32,
    pub PABITS: u32,
    pub SEGMask: target_ulong,
    pub PAMask: u64,
    pub msair: i32,
    pub CP0_Index: i32,
    pub CP0_VPControl: i32,
    pub CP0_Random: i32,
    pub CP0_VPEControl: i32,
    pub CP0_VPEConf0: i32,
    pub CP0_VPEConf1: i32,
    pub CP0_YQMask: target_ulong,
    pub CP0_VPESchedule: target_ulong,
    pub CP0_VPEScheFBack: target_ulong,
    pub CP0_VPEOpt: i32,
    pub CP0_EntryLo0: u64,
    pub CP0_EntryLo1: u64,
    pub CP0_GlobalNumber: i32,
    pub CP0_Context: target_ulong,
    pub CP0_MemoryMapID: i32,
    pub CP0_PageMask: i32,
    pub CP0_PageGrain_rw_bitmask: i32,
    pub CP0_PageGrain: i32,
    pub CP0_SegCtl0: target_ulong,
    pub CP0_SegCtl1: target_ulong,
    pub CP0_SegCtl2: target_ulong,
    pub CP0_PWBase: target_ulong,
    pub CP0_PWField: target_ulong,
    pub CP0_PWSize: target_ulong,
    pub CP0_Wired: i32,
    pub CP0_PWCtl: i32,
    pub CP0_SRSConf0_rw_bitmask: i32,
    pub CP0_SRSConf0: i32,
    pub CP0_SRSConf1_rw_bitmask: i32,
    pub CP0_SRSConf1: i32,
    pub CP0_SRSConf2_rw_bitmask: i32,
    pub CP0_SRSConf2: i32,
    pub CP0_SRSConf3_rw_bitmask: i32,
    pub CP0_SRSConf3: i32,
    pub CP0_SRSConf4_rw_bitmask: i32,
    pub CP0_SRSConf4: i32,
    pub CP0_HWREna: i32,
    pub CP0_BadVAddr: target_ulong,
    pub CP0_BadInstr: u32,
    pub CP0_BadInstrP: u32,
    pub CP0_BadInstrX: u32,
    pub CP0_Count: i32,
    pub CP0_EntryHi: target_ulong,
    pub CP0_EntryHi_ASID_mask: target_ulong,
    pub CP0_Compare: i32,
    pub CP0_Status: i32,
    pub CP0_IntCtl: i32,
    pub CP0_SRSCtl: i32,
    pub CP0_SRSMap: i32,
    pub CP0_Cause: i32,
    pub CP0_EPC: target_ulong,
    pub CP0_PRid: i32,
    pub CP0_EBase: target_ulong,
    pub CP0_EBaseWG_rw_bitmask: target_ulong,
    pub CP0_CMGCRBase: target_ulong,
    pub CP0_Config0: i32,
    pub CP0_Config1: i32,
    pub CP0_Config2: i32,
    pub CP0_Config3: i32,
    pub CP0_Config4: i32,
    pub CP0_Config4_rw_bitmask: i32,
    pub CP0_Config5: i32,
    pub CP0_Config5_rw_bitmask: i32,
    pub CP0_Config6: i32,
    pub CP0_Config6_rw_bitmask: i32,
    pub CP0_Config7: i32,
    pub CP0_Config7_rw_bitmask: i64,
    pub CP0_LLAddr: u64,
    pub CP0_MAAR: [u64; 16usize],
    pub CP0_MAARI: i32,
    pub lladdr: target_ulong,
    pub llval: target_ulong,
    pub llval_wp: u64,
    pub llnewval_wp: u32,
    pub CP0_LLAddr_rw_bitmask: u64,
    pub CP0_LLAddr_shift: ::std::os::raw::c_int,
    pub CP0_WatchLo: [target_ulong; 8usize],
    pub CP0_WatchHi: [u64; 8usize],
    pub CP0_XContext: target_ulong,
    pub CP0_Framemask: i32,
    pub CP0_Debug: i32,
    pub CP0_DEPC: target_ulong,
    pub CP0_Performance0: i32,
    pub CP0_ErrCtl: i32,
    pub CP0_TagLo: u64,
    pub CP0_DataLo: i32,
    pub CP0_TagHi: i32,
    pub CP0_DataHi: i32,
    pub CP0_ErrorEPC: target_ulong,
    pub CP0_DESAVE: i32,
    pub CP0_KScratch: [target_ulong; 6usize],
    pub lcsr_cpucfg1: u32,
    pub lcsr_cpucfg2: u32,
    pub tcs: [TCState; 16usize],
    pub fpus: [CPUMIPSFPUContext; 1usize],
    pub error_code: ::std::os::raw::c_int,
    pub hflags: u32,
    pub btarget: target_ulong,
    pub bcond: target_ulong,
    pub SYNCI_Step: ::std::os::raw::c_int,
    pub CCRes: ::std::os::raw::c_int,
    pub CP0_Status_rw_bitmask: u32,
    pub CP0_TCStatus_rw_bitmask: u32,
    pub insn_flags: u64,
    pub end_reset_fields: CPUArchState__bindgen_ty_1,
    pub mvp: *mut CPUMIPSMVPContext,
    pub tlb: *mut CPUMIPSTLBContext,
    pub irq: [qemu_irq; 8usize],
    pub itc_tag: *mut MemoryRegion,
    pub __bindgen_padding_0: u64,
    pub iocsr: CPUArchState__bindgen_ty_2,
    pub cpu_model: *const mips_def_t,
    pub timer: *mut QEMUTimer,
    pub count_clock: *mut Clock,
    pub exception_base: target_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUArchState__bindgen_ty_1 {}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUArchState__bindgen_ty_1"]
        [::std::mem::size_of::<CPUArchState__bindgen_ty_1>() - 0usize];
    ["Alignment of CPUArchState__bindgen_ty_1"]
        [::std::mem::align_of::<CPUArchState__bindgen_ty_1>() - 1usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct CPUArchState__bindgen_ty_2 {
    pub as_: AddressSpace,
    pub mr: MemoryRegion,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUArchState__bindgen_ty_2"]
        [::std::mem::size_of::<CPUArchState__bindgen_ty_2>() - 432usize];
    ["Alignment of CPUArchState__bindgen_ty_2"]
        [::std::mem::align_of::<CPUArchState__bindgen_ty_2>() - 16usize];
    ["Offset of field: CPUArchState__bindgen_ty_2::as_"]
        [::std::mem::offset_of!(CPUArchState__bindgen_ty_2, as_) - 0usize];
    ["Offset of field: CPUArchState__bindgen_ty_2::mr"]
        [::std::mem::offset_of!(CPUArchState__bindgen_ty_2, mr) - 160usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CPUArchState"][::std::mem::size_of::<CPUArchState>() - 7472usize];
    ["Alignment of CPUArchState"][::std::mem::align_of::<CPUArchState>() - 16usize];
    ["Offset of field: CPUArchState::active_tc"]
        [::std::mem::offset_of!(CPUArchState, active_tc) - 0usize];
    ["Offset of field: CPUArchState::active_fpu"]
        [::std::mem::offset_of!(CPUArchState, active_fpu) - 304usize];
    ["Offset of field: CPUArchState::current_tc"]
        [::std::mem::offset_of!(CPUArchState, current_tc) - 848usize];
    ["Offset of field: CPUArchState::SEGBITS"]
        [::std::mem::offset_of!(CPUArchState, SEGBITS) - 852usize];
    ["Offset of field: CPUArchState::PABITS"]
        [::std::mem::offset_of!(CPUArchState, PABITS) - 856usize];
    ["Offset of field: CPUArchState::SEGMask"]
        [::std::mem::offset_of!(CPUArchState, SEGMask) - 860usize];
    ["Offset of field: CPUArchState::PAMask"]
        [::std::mem::offset_of!(CPUArchState, PAMask) - 864usize];
    ["Offset of field: CPUArchState::msair"]
        [::std::mem::offset_of!(CPUArchState, msair) - 872usize];
    ["Offset of field: CPUArchState::CP0_Index"]
        [::std::mem::offset_of!(CPUArchState, CP0_Index) - 876usize];
    ["Offset of field: CPUArchState::CP0_VPControl"]
        [::std::mem::offset_of!(CPUArchState, CP0_VPControl) - 880usize];
    ["Offset of field: CPUArchState::CP0_Random"]
        [::std::mem::offset_of!(CPUArchState, CP0_Random) - 884usize];
    ["Offset of field: CPUArchState::CP0_VPEControl"]
        [::std::mem::offset_of!(CPUArchState, CP0_VPEControl) - 888usize];
    ["Offset of field: CPUArchState::CP0_VPEConf0"]
        [::std::mem::offset_of!(CPUArchState, CP0_VPEConf0) - 892usize];
    ["Offset of field: CPUArchState::CP0_VPEConf1"]
        [::std::mem::offset_of!(CPUArchState, CP0_VPEConf1) - 896usize];
    ["Offset of field: CPUArchState::CP0_YQMask"]
        [::std::mem::offset_of!(CPUArchState, CP0_YQMask) - 900usize];
    ["Offset of field: CPUArchState::CP0_VPESchedule"]
        [::std::mem::offset_of!(CPUArchState, CP0_VPESchedule) - 904usize];
    ["Offset of field: CPUArchState::CP0_VPEScheFBack"]
        [::std::mem::offset_of!(CPUArchState, CP0_VPEScheFBack) - 908usize];
    ["Offset of field: CPUArchState::CP0_VPEOpt"]
        [::std::mem::offset_of!(CPUArchState, CP0_VPEOpt) - 912usize];
    ["Offset of field: CPUArchState::CP0_EntryLo0"]
        [::std::mem::offset_of!(CPUArchState, CP0_EntryLo0) - 920usize];
    ["Offset of field: CPUArchState::CP0_EntryLo1"]
        [::std::mem::offset_of!(CPUArchState, CP0_EntryLo1) - 928usize];
    ["Offset of field: CPUArchState::CP0_GlobalNumber"]
        [::std::mem::offset_of!(CPUArchState, CP0_GlobalNumber) - 936usize];
    ["Offset of field: CPUArchState::CP0_Context"]
        [::std::mem::offset_of!(CPUArchState, CP0_Context) - 940usize];
    ["Offset of field: CPUArchState::CP0_MemoryMapID"]
        [::std::mem::offset_of!(CPUArchState, CP0_MemoryMapID) - 944usize];
    ["Offset of field: CPUArchState::CP0_PageMask"]
        [::std::mem::offset_of!(CPUArchState, CP0_PageMask) - 948usize];
    ["Offset of field: CPUArchState::CP0_PageGrain_rw_bitmask"]
        [::std::mem::offset_of!(CPUArchState, CP0_PageGrain_rw_bitmask) - 952usize];
    ["Offset of field: CPUArchState::CP0_PageGrain"]
        [::std::mem::offset_of!(CPUArchState, CP0_PageGrain) - 956usize];
    ["Offset of field: CPUArchState::CP0_SegCtl0"]
        [::std::mem::offset_of!(CPUArchState, CP0_SegCtl0) - 960usize];
    ["Offset of field: CPUArchState::CP0_SegCtl1"]
        [::std::mem::offset_of!(CPUArchState, CP0_SegCtl1) - 964usize];
    ["Offset of field: CPUArchState::CP0_SegCtl2"]
        [::std::mem::offset_of!(CPUArchState, CP0_SegCtl2) - 968usize];
    ["Offset of field: CPUArchState::CP0_PWBase"]
        [::std::mem::offset_of!(CPUArchState, CP0_PWBase) - 972usize];
    ["Offset of field: CPUArchState::CP0_PWField"]
        [::std::mem::offset_of!(CPUArchState, CP0_PWField) - 976usize];
    ["Offset of field: CPUArchState::CP0_PWSize"]
        [::std::mem::offset_of!(CPUArchState, CP0_PWSize) - 980usize];
    ["Offset of field: CPUArchState::CP0_Wired"]
        [::std::mem::offset_of!(CPUArchState, CP0_Wired) - 984usize];
    ["Offset of field: CPUArchState::CP0_PWCtl"]
        [::std::mem::offset_of!(CPUArchState, CP0_PWCtl) - 988usize];
    ["Offset of field: CPUArchState::CP0_SRSConf0_rw_bitmask"]
        [::std::mem::offset_of!(CPUArchState, CP0_SRSConf0_rw_bitmask) - 992usize];
    ["Offset of field: CPUArchState::CP0_SRSConf0"]
        [::std::mem::offset_of!(CPUArchState, CP0_SRSConf0) - 996usize];
    ["Offset of field: CPUArchState::CP0_SRSConf1_rw_bitmask"]
        [::std::mem::offset_of!(CPUArchState, CP0_SRSConf1_rw_bitmask) - 1000usize];
    ["Offset of field: CPUArchState::CP0_SRSConf1"]
        [::std::mem::offset_of!(CPUArchState, CP0_SRSConf1) - 1004usize];
    ["Offset of field: CPUArchState::CP0_SRSConf2_rw_bitmask"]
        [::std::mem::offset_of!(CPUArchState, CP0_SRSConf2_rw_bitmask) - 1008usize];
    ["Offset of field: CPUArchState::CP0_SRSConf2"]
        [::std::mem::offset_of!(CPUArchState, CP0_SRSConf2) - 1012usize];
    ["Offset of field: CPUArchState::CP0_SRSConf3_rw_bitmask"]
        [::std::mem::offset_of!(CPUArchState, CP0_SRSConf3_rw_bitmask) - 1016usize];
    ["Offset of field: CPUArchState::CP0_SRSConf3"]
        [::std::mem::offset_of!(CPUArchState, CP0_SRSConf3) - 1020usize];
    ["Offset of field: CPUArchState::CP0_SRSConf4_rw_bitmask"]
        [::std::mem::offset_of!(CPUArchState, CP0_SRSConf4_rw_bitmask) - 1024usize];
    ["Offset of field: CPUArchState::CP0_SRSConf4"]
        [::std::mem::offset_of!(CPUArchState, CP0_SRSConf4) - 1028usize];
    ["Offset of field: CPUArchState::CP0_HWREna"]
        [::std::mem::offset_of!(CPUArchState, CP0_HWREna) - 1032usize];
    ["Offset of field: CPUArchState::CP0_BadVAddr"]
        [::std::mem::offset_of!(CPUArchState, CP0_BadVAddr) - 1036usize];
    ["Offset of field: CPUArchState::CP0_BadInstr"]
        [::std::mem::offset_of!(CPUArchState, CP0_BadInstr) - 1040usize];
    ["Offset of field: CPUArchState::CP0_BadInstrP"]
        [::std::mem::offset_of!(CPUArchState, CP0_BadInstrP) - 1044usize];
    ["Offset of field: CPUArchState::CP0_BadInstrX"]
        [::std::mem::offset_of!(CPUArchState, CP0_BadInstrX) - 1048usize];
    ["Offset of field: CPUArchState::CP0_Count"]
        [::std::mem::offset_of!(CPUArchState, CP0_Count) - 1052usize];
    ["Offset of field: CPUArchState::CP0_EntryHi"]
        [::std::mem::offset_of!(CPUArchState, CP0_EntryHi) - 1056usize];
    ["Offset of field: CPUArchState::CP0_EntryHi_ASID_mask"]
        [::std::mem::offset_of!(CPUArchState, CP0_EntryHi_ASID_mask) - 1060usize];
    ["Offset of field: CPUArchState::CP0_Compare"]
        [::std::mem::offset_of!(CPUArchState, CP0_Compare) - 1064usize];
    ["Offset of field: CPUArchState::CP0_Status"]
        [::std::mem::offset_of!(CPUArchState, CP0_Status) - 1068usize];
    ["Offset of field: CPUArchState::CP0_IntCtl"]
        [::std::mem::offset_of!(CPUArchState, CP0_IntCtl) - 1072usize];
    ["Offset of field: CPUArchState::CP0_SRSCtl"]
        [::std::mem::offset_of!(CPUArchState, CP0_SRSCtl) - 1076usize];
    ["Offset of field: CPUArchState::CP0_SRSMap"]
        [::std::mem::offset_of!(CPUArchState, CP0_SRSMap) - 1080usize];
    ["Offset of field: CPUArchState::CP0_Cause"]
        [::std::mem::offset_of!(CPUArchState, CP0_Cause) - 1084usize];
    ["Offset of field: CPUArchState::CP0_EPC"]
        [::std::mem::offset_of!(CPUArchState, CP0_EPC) - 1088usize];
    ["Offset of field: CPUArchState::CP0_PRid"]
        [::std::mem::offset_of!(CPUArchState, CP0_PRid) - 1092usize];
    ["Offset of field: CPUArchState::CP0_EBase"]
        [::std::mem::offset_of!(CPUArchState, CP0_EBase) - 1096usize];
    ["Offset of field: CPUArchState::CP0_EBaseWG_rw_bitmask"]
        [::std::mem::offset_of!(CPUArchState, CP0_EBaseWG_rw_bitmask) - 1100usize];
    ["Offset of field: CPUArchState::CP0_CMGCRBase"]
        [::std::mem::offset_of!(CPUArchState, CP0_CMGCRBase) - 1104usize];
    ["Offset of field: CPUArchState::CP0_Config0"]
        [::std::mem::offset_of!(CPUArchState, CP0_Config0) - 1108usize];
    ["Offset of field: CPUArchState::CP0_Config1"]
        [::std::mem::offset_of!(CPUArchState, CP0_Config1) - 1112usize];
    ["Offset of field: CPUArchState::CP0_Config2"]
        [::std::mem::offset_of!(CPUArchState, CP0_Config2) - 1116usize];
    ["Offset of field: CPUArchState::CP0_Config3"]
        [::std::mem::offset_of!(CPUArchState, CP0_Config3) - 1120usize];
    ["Offset of field: CPUArchState::CP0_Config4"]
        [::std::mem::offset_of!(CPUArchState, CP0_Config4) - 1124usize];
    ["Offset of field: CPUArchState::CP0_Config4_rw_bitmask"]
        [::std::mem::offset_of!(CPUArchState, CP0_Config4_rw_bitmask) - 1128usize];
    ["Offset of field: CPUArchState::CP0_Config5"]
        [::std::mem::offset_of!(CPUArchState, CP0_Config5) - 1132usize];
    ["Offset of field: CPUArchState::CP0_Config5_rw_bitmask"]
        [::std::mem::offset_of!(CPUArchState, CP0_Config5_rw_bitmask) - 1136usize];
    ["Offset of field: CPUArchState::CP0_Config6"]
        [::std::mem::offset_of!(CPUArchState, CP0_Config6) - 1140usize];
    ["Offset of field: CPUArchState::CP0_Config6_rw_bitmask"]
        [::std::mem::offset_of!(CPUArchState, CP0_Config6_rw_bitmask) - 1144usize];
    ["Offset of field: CPUArchState::CP0_Config7"]
        [::std::mem::offset_of!(CPUArchState, CP0_Config7) - 1148usize];
    ["Offset of field: CPUArchState::CP0_Config7_rw_bitmask"]
        [::std::mem::offset_of!(CPUArchState, CP0_Config7_rw_bitmask) - 1152usize];
    ["Offset of field: CPUArchState::CP0_LLAddr"]
        [::std::mem::offset_of!(CPUArchState, CP0_LLAddr) - 1160usize];
    ["Offset of field: CPUArchState::CP0_MAAR"]
        [::std::mem::offset_of!(CPUArchState, CP0_MAAR) - 1168usize];
    ["Offset of field: CPUArchState::CP0_MAARI"]
        [::std::mem::offset_of!(CPUArchState, CP0_MAARI) - 1296usize];
    ["Offset of field: CPUArchState::lladdr"]
        [::std::mem::offset_of!(CPUArchState, lladdr) - 1300usize];
    ["Offset of field: CPUArchState::llval"]
        [::std::mem::offset_of!(CPUArchState, llval) - 1304usize];
    ["Offset of field: CPUArchState::llval_wp"]
        [::std::mem::offset_of!(CPUArchState, llval_wp) - 1312usize];
    ["Offset of field: CPUArchState::llnewval_wp"]
        [::std::mem::offset_of!(CPUArchState, llnewval_wp) - 1320usize];
    ["Offset of field: CPUArchState::CP0_LLAddr_rw_bitmask"]
        [::std::mem::offset_of!(CPUArchState, CP0_LLAddr_rw_bitmask) - 1328usize];
    ["Offset of field: CPUArchState::CP0_LLAddr_shift"]
        [::std::mem::offset_of!(CPUArchState, CP0_LLAddr_shift) - 1336usize];
    ["Offset of field: CPUArchState::CP0_WatchLo"]
        [::std::mem::offset_of!(CPUArchState, CP0_WatchLo) - 1340usize];
    ["Offset of field: CPUArchState::CP0_WatchHi"]
        [::std::mem::offset_of!(CPUArchState, CP0_WatchHi) - 1376usize];
    ["Offset of field: CPUArchState::CP0_XContext"]
        [::std::mem::offset_of!(CPUArchState, CP0_XContext) - 1440usize];
    ["Offset of field: CPUArchState::CP0_Framemask"]
        [::std::mem::offset_of!(CPUArchState, CP0_Framemask) - 1444usize];
    ["Offset of field: CPUArchState::CP0_Debug"]
        [::std::mem::offset_of!(CPUArchState, CP0_Debug) - 1448usize];
    ["Offset of field: CPUArchState::CP0_DEPC"]
        [::std::mem::offset_of!(CPUArchState, CP0_DEPC) - 1452usize];
    ["Offset of field: CPUArchState::CP0_Performance0"]
        [::std::mem::offset_of!(CPUArchState, CP0_Performance0) - 1456usize];
    ["Offset of field: CPUArchState::CP0_ErrCtl"]
        [::std::mem::offset_of!(CPUArchState, CP0_ErrCtl) - 1460usize];
    ["Offset of field: CPUArchState::CP0_TagLo"]
        [::std::mem::offset_of!(CPUArchState, CP0_TagLo) - 1464usize];
    ["Offset of field: CPUArchState::CP0_DataLo"]
        [::std::mem::offset_of!(CPUArchState, CP0_DataLo) - 1472usize];
    ["Offset of field: CPUArchState::CP0_TagHi"]
        [::std::mem::offset_of!(CPUArchState, CP0_TagHi) - 1476usize];
    ["Offset of field: CPUArchState::CP0_DataHi"]
        [::std::mem::offset_of!(CPUArchState, CP0_DataHi) - 1480usize];
    ["Offset of field: CPUArchState::CP0_ErrorEPC"]
        [::std::mem::offset_of!(CPUArchState, CP0_ErrorEPC) - 1484usize];
    ["Offset of field: CPUArchState::CP0_DESAVE"]
        [::std::mem::offset_of!(CPUArchState, CP0_DESAVE) - 1488usize];
    ["Offset of field: CPUArchState::CP0_KScratch"]
        [::std::mem::offset_of!(CPUArchState, CP0_KScratch) - 1492usize];
    ["Offset of field: CPUArchState::lcsr_cpucfg1"]
        [::std::mem::offset_of!(CPUArchState, lcsr_cpucfg1) - 1516usize];
    ["Offset of field: CPUArchState::lcsr_cpucfg2"]
        [::std::mem::offset_of!(CPUArchState, lcsr_cpucfg2) - 1520usize];
    ["Offset of field: CPUArchState::tcs"][::std::mem::offset_of!(CPUArchState, tcs) - 1524usize];
    ["Offset of field: CPUArchState::fpus"][::std::mem::offset_of!(CPUArchState, fpus) - 6328usize];
    ["Offset of field: CPUArchState::error_code"]
        [::std::mem::offset_of!(CPUArchState, error_code) - 6872usize];
    ["Offset of field: CPUArchState::hflags"]
        [::std::mem::offset_of!(CPUArchState, hflags) - 6876usize];
    ["Offset of field: CPUArchState::btarget"]
        [::std::mem::offset_of!(CPUArchState, btarget) - 6880usize];
    ["Offset of field: CPUArchState::bcond"]
        [::std::mem::offset_of!(CPUArchState, bcond) - 6884usize];
    ["Offset of field: CPUArchState::SYNCI_Step"]
        [::std::mem::offset_of!(CPUArchState, SYNCI_Step) - 6888usize];
    ["Offset of field: CPUArchState::CCRes"]
        [::std::mem::offset_of!(CPUArchState, CCRes) - 6892usize];
    ["Offset of field: CPUArchState::CP0_Status_rw_bitmask"]
        [::std::mem::offset_of!(CPUArchState, CP0_Status_rw_bitmask) - 6896usize];
    ["Offset of field: CPUArchState::CP0_TCStatus_rw_bitmask"]
        [::std::mem::offset_of!(CPUArchState, CP0_TCStatus_rw_bitmask) - 6900usize];
    ["Offset of field: CPUArchState::insn_flags"]
        [::std::mem::offset_of!(CPUArchState, insn_flags) - 6904usize];
    ["Offset of field: CPUArchState::end_reset_fields"]
        [::std::mem::offset_of!(CPUArchState, end_reset_fields) - 6912usize];
    ["Offset of field: CPUArchState::mvp"][::std::mem::offset_of!(CPUArchState, mvp) - 6912usize];
    ["Offset of field: CPUArchState::tlb"][::std::mem::offset_of!(CPUArchState, tlb) - 6920usize];
    ["Offset of field: CPUArchState::irq"][::std::mem::offset_of!(CPUArchState, irq) - 6928usize];
    ["Offset of field: CPUArchState::itc_tag"]
        [::std::mem::offset_of!(CPUArchState, itc_tag) - 6992usize];
    ["Offset of field: CPUArchState::iocsr"]
        [::std::mem::offset_of!(CPUArchState, iocsr) - 7008usize];
    ["Offset of field: CPUArchState::cpu_model"]
        [::std::mem::offset_of!(CPUArchState, cpu_model) - 7440usize];
    ["Offset of field: CPUArchState::timer"]
        [::std::mem::offset_of!(CPUArchState, timer) - 7448usize];
    ["Offset of field: CPUArchState::count_clock"]
        [::std::mem::offset_of!(CPUArchState, count_clock) - 7456usize];
    ["Offset of field: CPUArchState::exception_base"]
        [::std::mem::offset_of!(CPUArchState, exception_base) - 7464usize];
};
pub type CPUMIPSState = CPUArchState;
#[repr(C)]
#[repr(align(16))]
pub struct ArchCPU {
    pub parent_obj: CPUState,
    pub env: CPUMIPSState,
    pub clock: *mut Clock,
    pub count_div: *mut Clock,
    pub is_big_endian: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ArchCPU"][::std::mem::size_of::<ArchCPU>() - 18704usize];
    ["Alignment of ArchCPU"][::std::mem::align_of::<ArchCPU>() - 16usize];
    ["Offset of field: ArchCPU::parent_obj"][::std::mem::offset_of!(ArchCPU, parent_obj) - 0usize];
    ["Offset of field: ArchCPU::env"][::std::mem::offset_of!(ArchCPU, env) - 11200usize];
    ["Offset of field: ArchCPU::clock"][::std::mem::offset_of!(ArchCPU, clock) - 18672usize];
    ["Offset of field: ArchCPU::count_div"]
        [::std::mem::offset_of!(ArchCPU, count_div) - 18680usize];
    ["Offset of field: ArchCPU::is_big_endian"]
        [::std::mem::offset_of!(ArchCPU, is_big_endian) - 18688usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MIPSCPUClass {
    pub parent_class: CPUClass,
    pub parent_realize: DeviceRealize,
    pub parent_phases: ResettablePhases,
    pub cpu_def: *const mips_def_t,
    pub no_data_aborts: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MIPSCPUClass"][::std::mem::size_of::<MIPSCPUClass>() - 416usize];
    ["Alignment of MIPSCPUClass"][::std::mem::align_of::<MIPSCPUClass>() - 8usize];
    ["Offset of field: MIPSCPUClass::parent_class"]
        [::std::mem::offset_of!(MIPSCPUClass, parent_class) - 0usize];
    ["Offset of field: MIPSCPUClass::parent_realize"]
        [::std::mem::offset_of!(MIPSCPUClass, parent_realize) - 368usize];
    ["Offset of field: MIPSCPUClass::parent_phases"]
        [::std::mem::offset_of!(MIPSCPUClass, parent_phases) - 376usize];
    ["Offset of field: MIPSCPUClass::cpu_def"]
        [::std::mem::offset_of!(MIPSCPUClass, cpu_def) - 400usize];
    ["Offset of field: MIPSCPUClass::no_data_aborts"]
        [::std::mem::offset_of!(MIPSCPUClass, no_data_aborts) - 408usize];
};
unsafe extern "C" {
    pub fn cpu_wrdsp(rs: u32, mask_num: u32, env: *mut CPUMIPSState);
}
unsafe extern "C" {
    pub fn cpu_rddsp(mask_num: u32, env: *mut CPUMIPSState) -> u32;
}
unsafe extern "C" {
    pub fn target_words_bigendian() -> bool;
}
unsafe extern "C" {
    pub fn address_space_lduw(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u16;
}
unsafe extern "C" {
    pub fn address_space_ldl(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u32;
}
unsafe extern "C" {
    pub fn address_space_ldq(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u64;
}
unsafe extern "C" {
    pub fn address_space_stl_notdirty(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u32,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stw(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u16,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stl(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u32,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stq(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u64,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_lduw_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u16;
}
unsafe extern "C" {
    pub fn address_space_ldl_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u32;
}
unsafe extern "C" {
    pub fn address_space_ldq_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u64;
}
unsafe extern "C" {
    pub fn address_space_stl_notdirty_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u32,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stw_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u16,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stl_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u32,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
unsafe extern "C" {
    pub fn address_space_stq_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u64,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TargetPageBits {
    pub decided: bool,
    pub bits: ::std::os::raw::c_int,
    pub mask: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TargetPageBits"][::std::mem::size_of::<TargetPageBits>() - 16usize];
    ["Alignment of TargetPageBits"][::std::mem::align_of::<TargetPageBits>() - 8usize];
    ["Offset of field: TargetPageBits::decided"]
        [::std::mem::offset_of!(TargetPageBits, decided) - 0usize];
    ["Offset of field: TargetPageBits::bits"]
        [::std::mem::offset_of!(TargetPageBits, bits) - 4usize];
    ["Offset of field: TargetPageBits::mask"]
        [::std::mem::offset_of!(TargetPageBits, mask) - 8usize];
};
unsafe extern "C" {
    pub fn set_preferred_target_page_bits(bits: ::std::os::raw::c_int) -> bool;
}
unsafe extern "C" {
    pub fn finalize_target_page_bits();
}
unsafe extern "C" {
    pub static target_page: TargetPageBits;
}
unsafe extern "C" {
    pub fn cpu_copy(env: *mut CPUArchState) -> *mut CPUArchState;
}
pub const EXCP_NONE: _bindgen_ty_52 = -1;
pub const EXCP_RESET: _bindgen_ty_52 = 0;
pub const EXCP_SRESET: _bindgen_ty_52 = 1;
pub const EXCP_DSS: _bindgen_ty_52 = 2;
pub const EXCP_DINT: _bindgen_ty_52 = 3;
pub const EXCP_DDBL: _bindgen_ty_52 = 4;
pub const EXCP_DDBS: _bindgen_ty_52 = 5;
pub const EXCP_NMI: _bindgen_ty_52 = 6;
pub const EXCP_MCHECK: _bindgen_ty_52 = 7;
pub const EXCP_EXT_INTERRUPT: _bindgen_ty_52 = 8;
pub const EXCP_DFWATCH: _bindgen_ty_52 = 9;
pub const EXCP_DIB: _bindgen_ty_52 = 10;
pub const EXCP_IWATCH: _bindgen_ty_52 = 11;
pub const EXCP_AdEL: _bindgen_ty_52 = 12;
pub const EXCP_AdES: _bindgen_ty_52 = 13;
pub const EXCP_TLBF: _bindgen_ty_52 = 14;
pub const EXCP_IBE: _bindgen_ty_52 = 15;
pub const EXCP_DBp: _bindgen_ty_52 = 16;
pub const EXCP_SYSCALL: _bindgen_ty_52 = 17;
pub const EXCP_BREAK: _bindgen_ty_52 = 18;
pub const EXCP_CpU: _bindgen_ty_52 = 19;
pub const EXCP_RI: _bindgen_ty_52 = 20;
pub const EXCP_OVERFLOW: _bindgen_ty_52 = 21;
pub const EXCP_TRAP: _bindgen_ty_52 = 22;
pub const EXCP_FPE: _bindgen_ty_52 = 23;
pub const EXCP_DWATCH: _bindgen_ty_52 = 24;
pub const EXCP_LTLBL: _bindgen_ty_52 = 25;
pub const EXCP_TLBL: _bindgen_ty_52 = 26;
pub const EXCP_TLBS: _bindgen_ty_52 = 27;
pub const EXCP_DBE: _bindgen_ty_52 = 28;
pub const EXCP_THREAD: _bindgen_ty_52 = 29;
pub const EXCP_MDMX: _bindgen_ty_52 = 30;
pub const EXCP_C2E: _bindgen_ty_52 = 31;
pub const EXCP_CACHE: _bindgen_ty_52 = 32;
pub const EXCP_DSPDIS: _bindgen_ty_52 = 33;
pub const EXCP_MSADIS: _bindgen_ty_52 = 34;
pub const EXCP_MSAFPE: _bindgen_ty_52 = 35;
pub const EXCP_TLBXI: _bindgen_ty_52 = 36;
pub const EXCP_TLBRI: _bindgen_ty_52 = 37;
pub const EXCP_SEMIHOST: _bindgen_ty_52 = 38;
pub const EXCP_LAST: _bindgen_ty_52 = 38;
pub type _bindgen_ty_52 = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn cpu_type_supports_cps_smp(cpu_type: *const ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    pub fn cpu_supports_isa(env: *const CPUMIPSState, isa_mask: u64) -> bool;
}
unsafe extern "C" {
    pub fn cpu_type_supports_isa(cpu_type: *const ::std::os::raw::c_char, isa: u64) -> bool;
}
unsafe extern "C" {
    pub fn cpu_set_exception_base(vp_index: ::std::os::raw::c_int, address: target_ulong);
}
unsafe extern "C" {
    pub fn cpu_mips_kseg0_to_phys(opaque: *mut ::std::os::raw::c_void, addr: u64) -> u64;
}
unsafe extern "C" {
    pub fn cpu_mips_phys_to_kseg0(opaque: *mut ::std::os::raw::c_void, addr: u64) -> u64;
}
unsafe extern "C" {
    pub fn cpu_mips_kseg1_to_phys(opaque: *mut ::std::os::raw::c_void, addr: u64) -> u64;
}
unsafe extern "C" {
    pub fn cpu_mips_phys_to_kseg1(opaque: *mut ::std::os::raw::c_void, addr: u64) -> u64;
}
unsafe extern "C" {
    pub fn cpu_mips_soft_irq(
        env: *mut CPUMIPSState,
        irq: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn cpu_mips_irq_init_cpu(cpu: *mut MIPSCPU);
}
unsafe extern "C" {
    pub fn cpu_mips_clock_init(cpu: *mut MIPSCPU);
}
unsafe extern "C" {
    pub fn exception_resume_pc(env: *mut CPUMIPSState) -> target_ulong;
}
unsafe extern "C" {
    pub fn mips_cpu_create_with_clock(
        cpu_type: *const ::std::os::raw::c_char,
        cpu_refclk: *mut Clock,
        is_big_endian: bool,
    ) -> *mut MIPSCPU;
}
pub type target_ptr_t = target_ulong;
pub type target_pid_t = i32;
pub const PANDA_CB_BEFORE_BLOCK_TRANSLATE: panda_cb_type = 0;
pub const PANDA_CB_AFTER_BLOCK_TRANSLATE: panda_cb_type = 1;
pub const PANDA_CB_BLOCK_TRANSLATE: panda_cb_type = 2;
pub const PANDA_CB_BEFORE_BLOCK_EXEC_INVALIDATE_OPT: panda_cb_type = 3;
pub const PANDA_CB_BEFORE_TCG_CODEGEN: panda_cb_type = 4;
pub const PANDA_CB_BEFORE_BLOCK_EXEC: panda_cb_type = 5;
pub const PANDA_CB_AFTER_BLOCK_EXEC: panda_cb_type = 6;
pub const PANDA_CB_INSN_TRANSLATE: panda_cb_type = 7;
pub const PANDA_CB_INSN_EXEC: panda_cb_type = 8;
pub const PANDA_CB_AFTER_INSN_TRANSLATE: panda_cb_type = 9;
pub const PANDA_CB_AFTER_INSN_EXEC: panda_cb_type = 10;
pub const PANDA_CB_VIRT_MEM_BEFORE_READ: panda_cb_type = 11;
pub const PANDA_CB_VIRT_MEM_BEFORE_WRITE: panda_cb_type = 12;
pub const PANDA_CB_PHYS_MEM_BEFORE_READ: panda_cb_type = 13;
pub const PANDA_CB_PHYS_MEM_BEFORE_WRITE: panda_cb_type = 14;
pub const PANDA_CB_VIRT_MEM_AFTER_READ: panda_cb_type = 15;
pub const PANDA_CB_VIRT_MEM_AFTER_WRITE: panda_cb_type = 16;
pub const PANDA_CB_PHYS_MEM_AFTER_READ: panda_cb_type = 17;
pub const PANDA_CB_PHYS_MEM_AFTER_WRITE: panda_cb_type = 18;
pub const PANDA_CB_MMIO_AFTER_READ: panda_cb_type = 19;
pub const PANDA_CB_MMIO_BEFORE_WRITE: panda_cb_type = 20;
pub const PANDA_CB_HD_READ: panda_cb_type = 21;
pub const PANDA_CB_HD_WRITE: panda_cb_type = 22;
pub const PANDA_CB_GUEST_HYPERCALL: panda_cb_type = 23;
pub const PANDA_CB_MONITOR: panda_cb_type = 24;
pub const PANDA_CB_QMP: panda_cb_type = 25;
pub const PANDA_CB_CPU_RESTORE_STATE: panda_cb_type = 26;
pub const PANDA_CB_BEFORE_LOADVM: panda_cb_type = 27;
pub const PANDA_CB_ASID_CHANGED: panda_cb_type = 28;
pub const PANDA_CB_REPLAY_HD_TRANSFER: panda_cb_type = 29;
pub const PANDA_CB_REPLAY_NET_TRANSFER: panda_cb_type = 30;
pub const PANDA_CB_REPLAY_SERIAL_RECEIVE: panda_cb_type = 31;
pub const PANDA_CB_REPLAY_SERIAL_READ: panda_cb_type = 32;
pub const PANDA_CB_REPLAY_SERIAL_SEND: panda_cb_type = 33;
pub const PANDA_CB_REPLAY_SERIAL_WRITE: panda_cb_type = 34;
pub const PANDA_CB_REPLAY_BEFORE_DMA: panda_cb_type = 35;
pub const PANDA_CB_REPLAY_AFTER_DMA: panda_cb_type = 36;
pub const PANDA_CB_REPLAY_HANDLE_PACKET: panda_cb_type = 37;
pub const PANDA_CB_AFTER_CPU_EXEC_ENTER: panda_cb_type = 38;
pub const PANDA_CB_BEFORE_CPU_EXEC_EXIT: panda_cb_type = 39;
pub const PANDA_CB_AFTER_MACHINE_INIT: panda_cb_type = 40;
pub const PANDA_CB_AFTER_LOADVM: panda_cb_type = 41;
pub const PANDA_CB_TOP_LOOP: panda_cb_type = 42;
pub const PANDA_CB_DURING_MACHINE_INIT: panda_cb_type = 43;
pub const PANDA_CB_MAIN_LOOP_WAIT: panda_cb_type = 44;
pub const PANDA_CB_PRE_SHUTDOWN: panda_cb_type = 45;
pub const PANDA_CB_UNASSIGNED_IO_READ: panda_cb_type = 46;
pub const PANDA_CB_UNASSIGNED_IO_WRITE: panda_cb_type = 47;
pub const PANDA_CB_BEFORE_HANDLE_EXCEPTION: panda_cb_type = 48;
pub const PANDA_CB_BEFORE_HANDLE_INTERRUPT: panda_cb_type = 49;
pub const PANDA_CB_START_BLOCK_EXEC: panda_cb_type = 50;
pub const PANDA_CB_END_BLOCK_EXEC: panda_cb_type = 51;
pub const PANDA_CB_LAST: panda_cb_type = 52;
pub type panda_cb_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union panda_cb {
    pub before_block_exec_invalidate_opt: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, tb: *mut TranslationBlock) -> bool,
    >,
    pub before_tcg_codegen:
        ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState, tb: *mut TranslationBlock)>,
    pub before_block_exec:
        ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState, tb: *mut TranslationBlock)>,
    pub after_block_exec: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, tb: *mut TranslationBlock, exitCode: u8),
    >,
    pub before_block_translate:
        ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState, pc: u64)>,
    pub after_block_translate:
        ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState, tb: *mut TranslationBlock)>,
    pub block_translate:
        ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState, tb: *mut qemu_plugin_tb)>,
    pub after_cpu_exec_enter: ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState)>,
    pub before_cpu_exec_exit:
        ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState, ranBlock: bool)>,
    pub insn_translate:
        ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState, pc: u64) -> bool>,
    pub insn_exec: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, pc: u64) -> ::std::os::raw::c_int,
    >,
    pub after_insn_translate:
        ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState, pc: u64) -> bool>,
    pub after_insn_exec: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, pc: u64) -> ::std::os::raw::c_int,
    >,
    pub virt_mem_before_read: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, pc: u64, addr: u64, size: usize),
    >,
    pub virt_mem_before_write: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, pc: u64, addr: u64, size: usize, buf: *mut u8),
    >,
    pub phys_mem_before_read: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, pc: u64, addr: u64, size: usize),
    >,
    pub phys_mem_before_write: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, pc: u64, addr: u64, size: usize, buf: *mut u8),
    >,
    pub virt_mem_after_read: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, pc: u64, addr: u64, size: usize, buf: *mut u8),
    >,
    pub virt_mem_after_write: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, pc: u64, addr: u64, size: usize, buf: *mut u8),
    >,
    pub phys_mem_after_read: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, pc: u64, addr: u64, size: usize, buf: *mut u8),
    >,
    pub phys_mem_after_write: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, pc: u64, addr: u64, size: usize, buf: *mut u8),
    >,
    pub mmio_after_read: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut CPUState,
            physaddr: u64,
            vaddr: u64,
            size: usize,
            val: *mut u64,
        ),
    >,
    pub mmio_before_write: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut CPUState,
            physaddr: u64,
            vaddr: u64,
            size: usize,
            val: *mut u64,
        ),
    >,
    pub hd_read: ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState)>,
    pub hd_write: ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState)>,
    pub guest_hypercall: ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState) -> bool>,
    pub monitor: ::std::option::Option<
        unsafe extern "C" fn(
            mon: *mut Monitor,
            cmd: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub qmp: ::std::option::Option<
        unsafe extern "C" fn(
            command: *mut ::std::os::raw::c_char,
            args: *mut ::std::os::raw::c_char,
            result: *mut *mut ::std::os::raw::c_char,
        ) -> bool,
    >,
    pub cpu_restore_state:
        ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState, tb: *mut TranslationBlock)>,
    pub before_loadvm: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub asid_changed: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, oldval: u64, newval: u64) -> bool,
    >,
    pub replay_hd_transfer: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut CPUState,
            type_: u32,
            src_addr: u64,
            dest_addr: u64,
            num_bytes: usize,
        ),
    >,
    pub replay_before_dma: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut CPUState,
            buf: *const u8,
            addr: hwaddr,
            size: usize,
            is_write: bool,
        ),
    >,
    pub replay_after_dma: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut CPUState,
            buf: *const u8,
            addr: hwaddr,
            size: usize,
            is_write: bool,
        ),
    >,
    pub replay_handle_packet: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut CPUState,
            buf: *mut u8,
            size: usize,
            direction: u8,
            buf_addr_rec: u64,
        ),
    >,
    pub replay_net_transfer: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut CPUState,
            type_: u32,
            src_addr: u64,
            dest_addr: u64,
            num_bytes: usize,
        ),
    >,
    pub replay_serial_receive:
        ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState, fifo_addr: u64, value: u8)>,
    pub replay_serial_read: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, fifo_addr: u64, port_addr: u32, value: u8),
    >,
    pub replay_serial_send:
        ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState, fifo_addr: u64, value: u8)>,
    pub replay_serial_write: ::std::option::Option<
        unsafe extern "C" fn(env: *mut CPUState, fifo_addr: u64, port_addr: u32, value: u8),
    >,
    pub after_machine_init: ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState)>,
    pub after_loadvm: ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState)>,
    pub top_loop: ::std::option::Option<unsafe extern "C" fn(env: *mut CPUState)>,
    pub during_machine_init:
        ::std::option::Option<unsafe extern "C" fn(machine: *mut MachineState)>,
    pub main_loop_wait: ::std::option::Option<unsafe extern "C" fn()>,
    pub pre_shutdown: ::std::option::Option<unsafe extern "C" fn()>,
    pub unassigned_io_read: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut CPUState,
            pc: u64,
            addr: hwaddr,
            size: usize,
            val: *mut u64,
        ) -> bool,
    >,
    pub unassigned_io_write: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut CPUState,
            pc: u64,
            addr: hwaddr,
            size: usize,
            val: u64,
        ) -> bool,
    >,
    pub before_handle_exception: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut CPUState, exception_index: i32) -> i32,
    >,
    pub before_handle_interrupt: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut CPUState, interrupt_request: i32) -> i32,
    >,
    pub start_block_exec:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut CPUState, tb: *mut TranslationBlock)>,
    pub end_block_exec:
        ::std::option::Option<unsafe extern "C" fn(cpu: *mut CPUState, tb: *mut TranslationBlock)>,
    pub cbaddr: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of panda_cb"][::std::mem::size_of::<panda_cb>() - 8usize];
    ["Alignment of panda_cb"][::std::mem::align_of::<panda_cb>() - 8usize];
    ["Offset of field: panda_cb::before_block_exec_invalidate_opt"]
        [::std::mem::offset_of!(panda_cb, before_block_exec_invalidate_opt) - 0usize];
    ["Offset of field: panda_cb::before_tcg_codegen"]
        [::std::mem::offset_of!(panda_cb, before_tcg_codegen) - 0usize];
    ["Offset of field: panda_cb::before_block_exec"]
        [::std::mem::offset_of!(panda_cb, before_block_exec) - 0usize];
    ["Offset of field: panda_cb::after_block_exec"]
        [::std::mem::offset_of!(panda_cb, after_block_exec) - 0usize];
    ["Offset of field: panda_cb::before_block_translate"]
        [::std::mem::offset_of!(panda_cb, before_block_translate) - 0usize];
    ["Offset of field: panda_cb::after_block_translate"]
        [::std::mem::offset_of!(panda_cb, after_block_translate) - 0usize];
    ["Offset of field: panda_cb::block_translate"]
        [::std::mem::offset_of!(panda_cb, block_translate) - 0usize];
    ["Offset of field: panda_cb::after_cpu_exec_enter"]
        [::std::mem::offset_of!(panda_cb, after_cpu_exec_enter) - 0usize];
    ["Offset of field: panda_cb::before_cpu_exec_exit"]
        [::std::mem::offset_of!(panda_cb, before_cpu_exec_exit) - 0usize];
    ["Offset of field: panda_cb::insn_translate"]
        [::std::mem::offset_of!(panda_cb, insn_translate) - 0usize];
    ["Offset of field: panda_cb::insn_exec"][::std::mem::offset_of!(panda_cb, insn_exec) - 0usize];
    ["Offset of field: panda_cb::after_insn_translate"]
        [::std::mem::offset_of!(panda_cb, after_insn_translate) - 0usize];
    ["Offset of field: panda_cb::after_insn_exec"]
        [::std::mem::offset_of!(panda_cb, after_insn_exec) - 0usize];
    ["Offset of field: panda_cb::virt_mem_before_read"]
        [::std::mem::offset_of!(panda_cb, virt_mem_before_read) - 0usize];
    ["Offset of field: panda_cb::virt_mem_before_write"]
        [::std::mem::offset_of!(panda_cb, virt_mem_before_write) - 0usize];
    ["Offset of field: panda_cb::phys_mem_before_read"]
        [::std::mem::offset_of!(panda_cb, phys_mem_before_read) - 0usize];
    ["Offset of field: panda_cb::phys_mem_before_write"]
        [::std::mem::offset_of!(panda_cb, phys_mem_before_write) - 0usize];
    ["Offset of field: panda_cb::virt_mem_after_read"]
        [::std::mem::offset_of!(panda_cb, virt_mem_after_read) - 0usize];
    ["Offset of field: panda_cb::virt_mem_after_write"]
        [::std::mem::offset_of!(panda_cb, virt_mem_after_write) - 0usize];
    ["Offset of field: panda_cb::phys_mem_after_read"]
        [::std::mem::offset_of!(panda_cb, phys_mem_after_read) - 0usize];
    ["Offset of field: panda_cb::phys_mem_after_write"]
        [::std::mem::offset_of!(panda_cb, phys_mem_after_write) - 0usize];
    ["Offset of field: panda_cb::mmio_after_read"]
        [::std::mem::offset_of!(panda_cb, mmio_after_read) - 0usize];
    ["Offset of field: panda_cb::mmio_before_write"]
        [::std::mem::offset_of!(panda_cb, mmio_before_write) - 0usize];
    ["Offset of field: panda_cb::hd_read"][::std::mem::offset_of!(panda_cb, hd_read) - 0usize];
    ["Offset of field: panda_cb::hd_write"][::std::mem::offset_of!(panda_cb, hd_write) - 0usize];
    ["Offset of field: panda_cb::guest_hypercall"]
        [::std::mem::offset_of!(panda_cb, guest_hypercall) - 0usize];
    ["Offset of field: panda_cb::monitor"][::std::mem::offset_of!(panda_cb, monitor) - 0usize];
    ["Offset of field: panda_cb::qmp"][::std::mem::offset_of!(panda_cb, qmp) - 0usize];
    ["Offset of field: panda_cb::cpu_restore_state"]
        [::std::mem::offset_of!(panda_cb, cpu_restore_state) - 0usize];
    ["Offset of field: panda_cb::before_loadvm"]
        [::std::mem::offset_of!(panda_cb, before_loadvm) - 0usize];
    ["Offset of field: panda_cb::asid_changed"]
        [::std::mem::offset_of!(panda_cb, asid_changed) - 0usize];
    ["Offset of field: panda_cb::replay_hd_transfer"]
        [::std::mem::offset_of!(panda_cb, replay_hd_transfer) - 0usize];
    ["Offset of field: panda_cb::replay_before_dma"]
        [::std::mem::offset_of!(panda_cb, replay_before_dma) - 0usize];
    ["Offset of field: panda_cb::replay_after_dma"]
        [::std::mem::offset_of!(panda_cb, replay_after_dma) - 0usize];
    ["Offset of field: panda_cb::replay_handle_packet"]
        [::std::mem::offset_of!(panda_cb, replay_handle_packet) - 0usize];
    ["Offset of field: panda_cb::replay_net_transfer"]
        [::std::mem::offset_of!(panda_cb, replay_net_transfer) - 0usize];
    ["Offset of field: panda_cb::replay_serial_receive"]
        [::std::mem::offset_of!(panda_cb, replay_serial_receive) - 0usize];
    ["Offset of field: panda_cb::replay_serial_read"]
        [::std::mem::offset_of!(panda_cb, replay_serial_read) - 0usize];
    ["Offset of field: panda_cb::replay_serial_send"]
        [::std::mem::offset_of!(panda_cb, replay_serial_send) - 0usize];
    ["Offset of field: panda_cb::replay_serial_write"]
        [::std::mem::offset_of!(panda_cb, replay_serial_write) - 0usize];
    ["Offset of field: panda_cb::after_machine_init"]
        [::std::mem::offset_of!(panda_cb, after_machine_init) - 0usize];
    ["Offset of field: panda_cb::after_loadvm"]
        [::std::mem::offset_of!(panda_cb, after_loadvm) - 0usize];
    ["Offset of field: panda_cb::top_loop"][::std::mem::offset_of!(panda_cb, top_loop) - 0usize];
    ["Offset of field: panda_cb::during_machine_init"]
        [::std::mem::offset_of!(panda_cb, during_machine_init) - 0usize];
    ["Offset of field: panda_cb::main_loop_wait"]
        [::std::mem::offset_of!(panda_cb, main_loop_wait) - 0usize];
    ["Offset of field: panda_cb::pre_shutdown"]
        [::std::mem::offset_of!(panda_cb, pre_shutdown) - 0usize];
    ["Offset of field: panda_cb::unassigned_io_read"]
        [::std::mem::offset_of!(panda_cb, unassigned_io_read) - 0usize];
    ["Offset of field: panda_cb::unassigned_io_write"]
        [::std::mem::offset_of!(panda_cb, unassigned_io_write) - 0usize];
    ["Offset of field: panda_cb::before_handle_exception"]
        [::std::mem::offset_of!(panda_cb, before_handle_exception) - 0usize];
    ["Offset of field: panda_cb::before_handle_interrupt"]
        [::std::mem::offset_of!(panda_cb, before_handle_interrupt) - 0usize];
    ["Offset of field: panda_cb::start_block_exec"]
        [::std::mem::offset_of!(panda_cb, start_block_exec) - 0usize];
    ["Offset of field: panda_cb::end_block_exec"]
        [::std::mem::offset_of!(panda_cb, end_block_exec) - 0usize];
    ["Offset of field: panda_cb::cbaddr"][::std::mem::offset_of!(panda_cb, cbaddr) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union panda_cb_with_context {
    pub before_block_exec_invalidate_opt: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            tb: *mut TranslationBlock,
        ) -> bool,
    >,
    pub before_tcg_codegen: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            tb: *mut TranslationBlock,
        ),
    >,
    pub before_block_exec: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            tb: *mut TranslationBlock,
        ),
    >,
    pub after_block_exec: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            tb: *mut TranslationBlock,
            exitCode: u8,
        ),
    >,
    pub before_block_translate: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, env: *mut CPUState, pc: u64),
    >,
    pub after_block_translate: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            tb: *mut TranslationBlock,
        ),
    >,
    pub block_translate: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            tb: *mut qemu_plugin_tb,
        ),
    >,
    pub after_cpu_exec_enter: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, env: *mut CPUState),
    >,
    pub before_cpu_exec_exit: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            ranBlock: bool,
        ),
    >,
    pub insn_translate: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            pc: u64,
        ) -> bool,
    >,
    pub insn_exec: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            pc: u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub after_insn_translate: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            pc: u64,
        ) -> bool,
    >,
    pub after_insn_exec: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            pc: u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub virt_mem_before_read: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            pc: u64,
            addr: u64,
            size: usize,
        ),
    >,
    pub virt_mem_before_write: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            pc: u64,
            addr: u64,
            size: usize,
            buf: *mut u8,
        ),
    >,
    pub phys_mem_before_read: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            pc: u64,
            addr: u64,
            size: usize,
        ),
    >,
    pub phys_mem_before_write: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            pc: u64,
            addr: u64,
            size: usize,
            buf: *mut u8,
        ),
    >,
    pub virt_mem_after_read: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            pc: u64,
            addr: u64,
            size: usize,
            buf: *mut u8,
        ),
    >,
    pub virt_mem_after_write: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            pc: u64,
            addr: u64,
            size: usize,
            buf: *mut u8,
        ),
    >,
    pub phys_mem_after_read: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            pc: u64,
            addr: u64,
            size: usize,
            buf: *mut u8,
        ),
    >,
    pub phys_mem_after_write: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            pc: u64,
            addr: u64,
            size: usize,
            buf: *mut u8,
        ),
    >,
    pub mmio_after_read: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            physaddr: u64,
            vaddr: u64,
            size: usize,
            val: *mut u64,
        ),
    >,
    pub mmio_before_write: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            physaddr: u64,
            vaddr: u64,
            size: usize,
            val: *mut u64,
        ),
    >,
    pub hd_read: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, env: *mut CPUState),
    >,
    pub hd_write: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, env: *mut CPUState),
    >,
    pub guest_hypercall: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, env: *mut CPUState) -> bool,
    >,
    pub monitor: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            mon: *mut Monitor,
            cmd: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub qmp: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            command: *mut ::std::os::raw::c_char,
            args: *mut ::std::os::raw::c_char,
            result: *mut *mut ::std::os::raw::c_char,
        ) -> bool,
    >,
    pub cpu_restore_state: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            tb: *mut TranslationBlock,
        ),
    >,
    pub before_loadvm: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub asid_changed: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            oldval: u64,
            newval: u64,
        ) -> bool,
    >,
    pub replay_hd_transfer: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            type_: u32,
            src_addr: u64,
            dest_addr: u64,
            num_bytes: usize,
        ),
    >,
    pub replay_before_dma: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            buf: *const u8,
            addr: hwaddr,
            size: usize,
            is_write: bool,
        ),
    >,
    pub replay_after_dma: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            buf: *const u8,
            addr: hwaddr,
            size: usize,
            is_write: bool,
        ),
    >,
    pub replay_handle_packet: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            buf: *mut u8,
            size: usize,
            direction: u8,
            buf_addr_rec: u64,
        ),
    >,
    pub replay_net_transfer: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            type_: u32,
            src_addr: u64,
            dest_addr: u64,
            num_bytes: usize,
        ),
    >,
    pub replay_serial_receive: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            fifo_addr: u64,
            value: u8,
        ),
    >,
    pub replay_serial_read: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            fifo_addr: u64,
            port_addr: u32,
            value: u8,
        ),
    >,
    pub replay_serial_send: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            fifo_addr: u64,
            value: u8,
        ),
    >,
    pub replay_serial_write: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            fifo_addr: u64,
            port_addr: u32,
            value: u8,
        ),
    >,
    pub after_machine_init: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, env: *mut CPUState),
    >,
    pub after_loadvm: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, env: *mut CPUState),
    >,
    pub top_loop: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, env: *mut CPUState),
    >,
    pub during_machine_init: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, machine: *mut MachineState),
    >,
    pub main_loop_wait:
        ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>,
    pub pre_shutdown:
        ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>,
    pub unassigned_io_read: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            pc: u64,
            addr: hwaddr,
            size: usize,
            val: *mut u64,
        ) -> bool,
    >,
    pub unassigned_io_write: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            env: *mut CPUState,
            pc: u64,
            addr: hwaddr,
            size: usize,
            val: u64,
        ) -> bool,
    >,
    pub before_handle_exception: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            cpu: *mut CPUState,
            exception_index: i32,
        ) -> i32,
    >,
    pub before_handle_interrupt: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            cpu: *mut CPUState,
            interrupt_request: i32,
        ) -> i32,
    >,
    pub start_block_exec: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            cpu: *mut CPUState,
            tb: *mut TranslationBlock,
        ),
    >,
    pub end_block_exec: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            cpu: *mut CPUState,
            tb: *mut TranslationBlock,
        ),
    >,
    pub cbaddr: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of panda_cb_with_context"][::std::mem::size_of::<panda_cb_with_context>() - 8usize];
    ["Alignment of panda_cb_with_context"]
        [::std::mem::align_of::<panda_cb_with_context>() - 8usize];
    ["Offset of field: panda_cb_with_context::before_block_exec_invalidate_opt"]
        [::std::mem::offset_of!(panda_cb_with_context, before_block_exec_invalidate_opt) - 0usize];
    ["Offset of field: panda_cb_with_context::before_tcg_codegen"]
        [::std::mem::offset_of!(panda_cb_with_context, before_tcg_codegen) - 0usize];
    ["Offset of field: panda_cb_with_context::before_block_exec"]
        [::std::mem::offset_of!(panda_cb_with_context, before_block_exec) - 0usize];
    ["Offset of field: panda_cb_with_context::after_block_exec"]
        [::std::mem::offset_of!(panda_cb_with_context, after_block_exec) - 0usize];
    ["Offset of field: panda_cb_with_context::before_block_translate"]
        [::std::mem::offset_of!(panda_cb_with_context, before_block_translate) - 0usize];
    ["Offset of field: panda_cb_with_context::after_block_translate"]
        [::std::mem::offset_of!(panda_cb_with_context, after_block_translate) - 0usize];
    ["Offset of field: panda_cb_with_context::block_translate"]
        [::std::mem::offset_of!(panda_cb_with_context, block_translate) - 0usize];
    ["Offset of field: panda_cb_with_context::after_cpu_exec_enter"]
        [::std::mem::offset_of!(panda_cb_with_context, after_cpu_exec_enter) - 0usize];
    ["Offset of field: panda_cb_with_context::before_cpu_exec_exit"]
        [::std::mem::offset_of!(panda_cb_with_context, before_cpu_exec_exit) - 0usize];
    ["Offset of field: panda_cb_with_context::insn_translate"]
        [::std::mem::offset_of!(panda_cb_with_context, insn_translate) - 0usize];
    ["Offset of field: panda_cb_with_context::insn_exec"]
        [::std::mem::offset_of!(panda_cb_with_context, insn_exec) - 0usize];
    ["Offset of field: panda_cb_with_context::after_insn_translate"]
        [::std::mem::offset_of!(panda_cb_with_context, after_insn_translate) - 0usize];
    ["Offset of field: panda_cb_with_context::after_insn_exec"]
        [::std::mem::offset_of!(panda_cb_with_context, after_insn_exec) - 0usize];
    ["Offset of field: panda_cb_with_context::virt_mem_before_read"]
        [::std::mem::offset_of!(panda_cb_with_context, virt_mem_before_read) - 0usize];
    ["Offset of field: panda_cb_with_context::virt_mem_before_write"]
        [::std::mem::offset_of!(panda_cb_with_context, virt_mem_before_write) - 0usize];
    ["Offset of field: panda_cb_with_context::phys_mem_before_read"]
        [::std::mem::offset_of!(panda_cb_with_context, phys_mem_before_read) - 0usize];
    ["Offset of field: panda_cb_with_context::phys_mem_before_write"]
        [::std::mem::offset_of!(panda_cb_with_context, phys_mem_before_write) - 0usize];
    ["Offset of field: panda_cb_with_context::virt_mem_after_read"]
        [::std::mem::offset_of!(panda_cb_with_context, virt_mem_after_read) - 0usize];
    ["Offset of field: panda_cb_with_context::virt_mem_after_write"]
        [::std::mem::offset_of!(panda_cb_with_context, virt_mem_after_write) - 0usize];
    ["Offset of field: panda_cb_with_context::phys_mem_after_read"]
        [::std::mem::offset_of!(panda_cb_with_context, phys_mem_after_read) - 0usize];
    ["Offset of field: panda_cb_with_context::phys_mem_after_write"]
        [::std::mem::offset_of!(panda_cb_with_context, phys_mem_after_write) - 0usize];
    ["Offset of field: panda_cb_with_context::mmio_after_read"]
        [::std::mem::offset_of!(panda_cb_with_context, mmio_after_read) - 0usize];
    ["Offset of field: panda_cb_with_context::mmio_before_write"]
        [::std::mem::offset_of!(panda_cb_with_context, mmio_before_write) - 0usize];
    ["Offset of field: panda_cb_with_context::hd_read"]
        [::std::mem::offset_of!(panda_cb_with_context, hd_read) - 0usize];
    ["Offset of field: panda_cb_with_context::hd_write"]
        [::std::mem::offset_of!(panda_cb_with_context, hd_write) - 0usize];
    ["Offset of field: panda_cb_with_context::guest_hypercall"]
        [::std::mem::offset_of!(panda_cb_with_context, guest_hypercall) - 0usize];
    ["Offset of field: panda_cb_with_context::monitor"]
        [::std::mem::offset_of!(panda_cb_with_context, monitor) - 0usize];
    ["Offset of field: panda_cb_with_context::qmp"]
        [::std::mem::offset_of!(panda_cb_with_context, qmp) - 0usize];
    ["Offset of field: panda_cb_with_context::cpu_restore_state"]
        [::std::mem::offset_of!(panda_cb_with_context, cpu_restore_state) - 0usize];
    ["Offset of field: panda_cb_with_context::before_loadvm"]
        [::std::mem::offset_of!(panda_cb_with_context, before_loadvm) - 0usize];
    ["Offset of field: panda_cb_with_context::asid_changed"]
        [::std::mem::offset_of!(panda_cb_with_context, asid_changed) - 0usize];
    ["Offset of field: panda_cb_with_context::replay_hd_transfer"]
        [::std::mem::offset_of!(panda_cb_with_context, replay_hd_transfer) - 0usize];
    ["Offset of field: panda_cb_with_context::replay_before_dma"]
        [::std::mem::offset_of!(panda_cb_with_context, replay_before_dma) - 0usize];
    ["Offset of field: panda_cb_with_context::replay_after_dma"]
        [::std::mem::offset_of!(panda_cb_with_context, replay_after_dma) - 0usize];
    ["Offset of field: panda_cb_with_context::replay_handle_packet"]
        [::std::mem::offset_of!(panda_cb_with_context, replay_handle_packet) - 0usize];
    ["Offset of field: panda_cb_with_context::replay_net_transfer"]
        [::std::mem::offset_of!(panda_cb_with_context, replay_net_transfer) - 0usize];
    ["Offset of field: panda_cb_with_context::replay_serial_receive"]
        [::std::mem::offset_of!(panda_cb_with_context, replay_serial_receive) - 0usize];
    ["Offset of field: panda_cb_with_context::replay_serial_read"]
        [::std::mem::offset_of!(panda_cb_with_context, replay_serial_read) - 0usize];
    ["Offset of field: panda_cb_with_context::replay_serial_send"]
        [::std::mem::offset_of!(panda_cb_with_context, replay_serial_send) - 0usize];
    ["Offset of field: panda_cb_with_context::replay_serial_write"]
        [::std::mem::offset_of!(panda_cb_with_context, replay_serial_write) - 0usize];
    ["Offset of field: panda_cb_with_context::after_machine_init"]
        [::std::mem::offset_of!(panda_cb_with_context, after_machine_init) - 0usize];
    ["Offset of field: panda_cb_with_context::after_loadvm"]
        [::std::mem::offset_of!(panda_cb_with_context, after_loadvm) - 0usize];
    ["Offset of field: panda_cb_with_context::top_loop"]
        [::std::mem::offset_of!(panda_cb_with_context, top_loop) - 0usize];
    ["Offset of field: panda_cb_with_context::during_machine_init"]
        [::std::mem::offset_of!(panda_cb_with_context, during_machine_init) - 0usize];
    ["Offset of field: panda_cb_with_context::main_loop_wait"]
        [::std::mem::offset_of!(panda_cb_with_context, main_loop_wait) - 0usize];
    ["Offset of field: panda_cb_with_context::pre_shutdown"]
        [::std::mem::offset_of!(panda_cb_with_context, pre_shutdown) - 0usize];
    ["Offset of field: panda_cb_with_context::unassigned_io_read"]
        [::std::mem::offset_of!(panda_cb_with_context, unassigned_io_read) - 0usize];
    ["Offset of field: panda_cb_with_context::unassigned_io_write"]
        [::std::mem::offset_of!(panda_cb_with_context, unassigned_io_write) - 0usize];
    ["Offset of field: panda_cb_with_context::before_handle_exception"]
        [::std::mem::offset_of!(panda_cb_with_context, before_handle_exception) - 0usize];
    ["Offset of field: panda_cb_with_context::before_handle_interrupt"]
        [::std::mem::offset_of!(panda_cb_with_context, before_handle_interrupt) - 0usize];
    ["Offset of field: panda_cb_with_context::start_block_exec"]
        [::std::mem::offset_of!(panda_cb_with_context, start_block_exec) - 0usize];
    ["Offset of field: panda_cb_with_context::end_block_exec"]
        [::std::mem::offset_of!(panda_cb_with_context, end_block_exec) - 0usize];
    ["Offset of field: panda_cb_with_context::cbaddr"]
        [::std::mem::offset_of!(panda_cb_with_context, cbaddr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccelState {
    pub parent_obj: Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AccelState"][::std::mem::size_of::<AccelState>() - 40usize];
    ["Alignment of AccelState"][::std::mem::align_of::<AccelState>() - 8usize];
    ["Offset of field: AccelState::parent_obj"]
        [::std::mem::offset_of!(AccelState, parent_obj) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccelClass {
    pub parent_class: ObjectClass,
    pub name: *const ::std::os::raw::c_char,
    pub init_machine:
        ::std::option::Option<unsafe extern "C" fn(ms: *mut MachineState) -> ::std::os::raw::c_int>,
    pub setup_post:
        ::std::option::Option<unsafe extern "C" fn(ms: *mut MachineState, accel: *mut AccelState)>,
    pub has_memory: ::std::option::Option<
        unsafe extern "C" fn(
            ms: *mut MachineState,
            as_: *mut AddressSpace,
            start_addr: hwaddr,
            size: hwaddr,
        ) -> bool,
    >,
    pub cpu_common_realize: ::std::option::Option<
        unsafe extern "C" fn(cpu: *mut CPUState, errp: *mut *mut Error) -> bool,
    >,
    pub cpu_common_unrealize: ::std::option::Option<unsafe extern "C" fn(cpu: *mut CPUState)>,
    pub gdbstub_supported_sstep_flags:
        ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub allowed: *mut bool,
    pub compat_props: *mut GPtrArray,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AccelClass"][::std::mem::size_of::<AccelClass>() - 168usize];
    ["Alignment of AccelClass"][::std::mem::align_of::<AccelClass>() - 8usize];
    ["Offset of field: AccelClass::parent_class"]
        [::std::mem::offset_of!(AccelClass, parent_class) - 0usize];
    ["Offset of field: AccelClass::name"][::std::mem::offset_of!(AccelClass, name) - 96usize];
    ["Offset of field: AccelClass::init_machine"]
        [::std::mem::offset_of!(AccelClass, init_machine) - 104usize];
    ["Offset of field: AccelClass::setup_post"]
        [::std::mem::offset_of!(AccelClass, setup_post) - 112usize];
    ["Offset of field: AccelClass::has_memory"]
        [::std::mem::offset_of!(AccelClass, has_memory) - 120usize];
    ["Offset of field: AccelClass::cpu_common_realize"]
        [::std::mem::offset_of!(AccelClass, cpu_common_realize) - 128usize];
    ["Offset of field: AccelClass::cpu_common_unrealize"]
        [::std::mem::offset_of!(AccelClass, cpu_common_unrealize) - 136usize];
    ["Offset of field: AccelClass::gdbstub_supported_sstep_flags"]
        [::std::mem::offset_of!(AccelClass, gdbstub_supported_sstep_flags) - 144usize];
    ["Offset of field: AccelClass::allowed"]
        [::std::mem::offset_of!(AccelClass, allowed) - 152usize];
    ["Offset of field: AccelClass::compat_props"]
        [::std::mem::offset_of!(AccelClass, compat_props) - 160usize];
};
unsafe extern "C" {
    pub fn accel_find(opt_name: *const ::std::os::raw::c_char) -> *mut AccelClass;
}
unsafe extern "C" {
    pub fn current_accel() -> *mut AccelState;
}
unsafe extern "C" {
    pub fn current_accel_name() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn accel_init_interfaces(ac: *mut AccelClass);
}
unsafe extern "C" {
    pub fn accel_init_machine(
        accel: *mut AccelState,
        ms: *mut MachineState,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn accel_setup_post(ms: *mut MachineState);
}
unsafe extern "C" {
    pub fn accel_cpu_instance_init(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn accel_cpu_common_realize(cpu: *mut CPUState, errp: *mut *mut Error) -> bool;
}
unsafe extern "C" {
    pub fn accel_cpu_common_unrealize(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn accel_supported_gdbstub_sstep_flags() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn get_system_memory() -> *mut MemoryRegion;
}
unsafe extern "C" {
    pub fn get_system_io() -> *mut MemoryRegion;
}
unsafe extern "C" {
    pub static mut address_space_memory: AddressSpace;
}
unsafe extern "C" {
    pub static mut address_space_io: AddressSpace;
}
pub type tb_page_addr_t = ram_addr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tb_tc {
    pub ptr: *const ::std::os::raw::c_void,
    pub size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tb_tc"][::std::mem::size_of::<tb_tc>() - 16usize];
    ["Alignment of tb_tc"][::std::mem::align_of::<tb_tc>() - 8usize];
    ["Offset of field: tb_tc::ptr"][::std::mem::offset_of!(tb_tc, ptr) - 0usize];
    ["Offset of field: tb_tc::size"][::std::mem::offset_of!(tb_tc, size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TranslationBlock {
    pub pc: vaddr,
    pub cs_base: u64,
    pub flags: u32,
    pub cflags: u32,
    pub size: u16,
    pub icount: u16,
    pub tc: tb_tc,
    pub page_next: [usize; 2usize],
    pub page_addr: [tb_page_addr_t; 2usize],
    pub jmp_lock: QemuSpin,
    pub jmp_reset_offset: [u16; 2usize],
    pub jmp_insn_offset: [u16; 2usize],
    pub jmp_target_addr: [usize; 2usize],
    pub jmp_list_head: usize,
    pub jmp_list_next: [usize; 2usize],
    pub jmp_dest: [usize; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TranslationBlock"][::std::mem::size_of::<TranslationBlock>() - 152usize];
    ["Alignment of TranslationBlock"][::std::mem::align_of::<TranslationBlock>() - 8usize];
    ["Offset of field: TranslationBlock::pc"]
        [::std::mem::offset_of!(TranslationBlock, pc) - 0usize];
    ["Offset of field: TranslationBlock::cs_base"]
        [::std::mem::offset_of!(TranslationBlock, cs_base) - 8usize];
    ["Offset of field: TranslationBlock::flags"]
        [::std::mem::offset_of!(TranslationBlock, flags) - 16usize];
    ["Offset of field: TranslationBlock::cflags"]
        [::std::mem::offset_of!(TranslationBlock, cflags) - 20usize];
    ["Offset of field: TranslationBlock::size"]
        [::std::mem::offset_of!(TranslationBlock, size) - 24usize];
    ["Offset of field: TranslationBlock::icount"]
        [::std::mem::offset_of!(TranslationBlock, icount) - 26usize];
    ["Offset of field: TranslationBlock::tc"]
        [::std::mem::offset_of!(TranslationBlock, tc) - 32usize];
    ["Offset of field: TranslationBlock::page_next"]
        [::std::mem::offset_of!(TranslationBlock, page_next) - 48usize];
    ["Offset of field: TranslationBlock::page_addr"]
        [::std::mem::offset_of!(TranslationBlock, page_addr) - 64usize];
    ["Offset of field: TranslationBlock::jmp_lock"]
        [::std::mem::offset_of!(TranslationBlock, jmp_lock) - 80usize];
    ["Offset of field: TranslationBlock::jmp_reset_offset"]
        [::std::mem::offset_of!(TranslationBlock, jmp_reset_offset) - 84usize];
    ["Offset of field: TranslationBlock::jmp_insn_offset"]
        [::std::mem::offset_of!(TranslationBlock, jmp_insn_offset) - 88usize];
    ["Offset of field: TranslationBlock::jmp_target_addr"]
        [::std::mem::offset_of!(TranslationBlock, jmp_target_addr) - 96usize];
    ["Offset of field: TranslationBlock::jmp_list_head"]
        [::std::mem::offset_of!(TranslationBlock, jmp_list_head) - 112usize];
    ["Offset of field: TranslationBlock::jmp_list_next"]
        [::std::mem::offset_of!(TranslationBlock, jmp_list_next) - 120usize];
    ["Offset of field: TranslationBlock::jmp_dest"]
        [::std::mem::offset_of!(TranslationBlock, jmp_dest) - 136usize];
};
unsafe extern "C" {
    pub fn tcg_cflags_has(cpu: *mut CPUState, flags: u32) -> bool;
}
unsafe extern "C" {
    pub fn tcg_cflags_set(cpu: *mut CPUState, flags: u32);
}
unsafe extern "C" {
    pub fn tlb_init(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn tlb_destroy(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn tlb_flush_page(cpu: *mut CPUState, addr: vaddr);
}
unsafe extern "C" {
    pub fn tlb_flush_page_all_cpus_synced(src: *mut CPUState, addr: vaddr);
}
unsafe extern "C" {
    pub fn tlb_flush(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn tlb_flush_all_cpus_synced(src_cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn tlb_flush_page_by_mmuidx(cpu: *mut CPUState, addr: vaddr, idxmap: u16);
}
unsafe extern "C" {
    pub fn tlb_flush_page_by_mmuidx_all_cpus_synced(cpu: *mut CPUState, addr: vaddr, idxmap: u16);
}
unsafe extern "C" {
    pub fn tlb_flush_by_mmuidx(cpu: *mut CPUState, idxmap: u16);
}
unsafe extern "C" {
    pub fn tlb_flush_by_mmuidx_all_cpus_synced(cpu: *mut CPUState, idxmap: u16);
}
unsafe extern "C" {
    pub fn tlb_flush_page_bits_by_mmuidx(
        cpu: *mut CPUState,
        addr: vaddr,
        idxmap: u16,
        bits: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn tlb_flush_page_bits_by_mmuidx_all_cpus_synced(
        cpu: *mut CPUState,
        addr: vaddr,
        idxmap: u16,
        bits: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn tlb_flush_range_by_mmuidx(
        cpu: *mut CPUState,
        addr: vaddr,
        len: vaddr,
        idxmap: u16,
        bits: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn tlb_flush_range_by_mmuidx_all_cpus_synced(
        cpu: *mut CPUState,
        addr: vaddr,
        len: vaddr,
        idxmap: u16,
        bits: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn tlb_set_page_full(
        cpu: *mut CPUState,
        mmu_idx: ::std::os::raw::c_int,
        addr: vaddr,
        full: *mut CPUTLBEntryFull,
    );
}
unsafe extern "C" {
    pub fn tlb_set_page_with_attrs(
        cpu: *mut CPUState,
        addr: vaddr,
        paddr: hwaddr,
        attrs: MemTxAttrs,
        prot: ::std::os::raw::c_int,
        mmu_idx: ::std::os::raw::c_int,
        size: vaddr,
    );
}
unsafe extern "C" {
    pub fn tlb_set_page(
        cpu: *mut CPUState,
        addr: vaddr,
        paddr: hwaddr,
        prot: ::std::os::raw::c_int,
        mmu_idx: ::std::os::raw::c_int,
        size: vaddr,
    );
}
unsafe extern "C" {
    pub fn probe_access(
        env: *mut CPUArchState,
        addr: vaddr,
        size: ::std::os::raw::c_int,
        access_type: MMUAccessType,
        mmu_idx: ::std::os::raw::c_int,
        retaddr: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn probe_access_flags(
        env: *mut CPUArchState,
        addr: vaddr,
        size: ::std::os::raw::c_int,
        access_type: MMUAccessType,
        mmu_idx: ::std::os::raw::c_int,
        nonfault: bool,
        phost: *mut *mut ::std::os::raw::c_void,
        retaddr: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn probe_access_full(
        env: *mut CPUArchState,
        addr: vaddr,
        size: ::std::os::raw::c_int,
        access_type: MMUAccessType,
        mmu_idx: ::std::os::raw::c_int,
        nonfault: bool,
        phost: *mut *mut ::std::os::raw::c_void,
        pfull: *mut *mut CPUTLBEntryFull,
        retaddr: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn probe_access_full_mmu(
        env: *mut CPUArchState,
        addr: vaddr,
        size: ::std::os::raw::c_int,
        access_type: MMUAccessType,
        mmu_idx: ::std::os::raw::c_int,
        phost: *mut *mut ::std::os::raw::c_void,
        pfull: *mut *mut CPUTLBEntryFull,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tb_phys_invalidate(tb: *mut TranslationBlock, page_addr: tb_page_addr_t);
}
unsafe extern "C" {
    pub fn tb_invalidate_phys_range(start: tb_page_addr_t, last: tb_page_addr_t);
}
unsafe extern "C" {
    pub fn tb_set_jmp_target(tb: *mut TranslationBlock, n: ::std::os::raw::c_int, addr: usize);
}
unsafe extern "C" {
    pub fn iotlb_to_section(
        cpu: *mut CPUState,
        index: hwaddr,
        attrs: MemTxAttrs,
    ) -> *mut MemoryRegionSection;
}
unsafe extern "C" {
    pub fn get_page_addr_code_hostp(
        env: *mut CPUArchState,
        addr: vaddr,
        hostp: *mut *mut ::std::os::raw::c_void,
    ) -> tb_page_addr_t;
}
unsafe extern "C" {
    pub fn tlb_reset_dirty(cpu: *mut CPUState, start1: ram_addr_t, length: ram_addr_t);
}
unsafe extern "C" {
    pub fn tlb_reset_dirty_range_all(start: ram_addr_t, length: ram_addr_t);
}
unsafe extern "C" {
    pub fn address_space_translate_for_iotlb(
        cpu: *mut CPUState,
        asidx: ::std::os::raw::c_int,
        addr: hwaddr,
        xlat: *mut hwaddr,
        plen: *mut hwaddr,
        attrs: MemTxAttrs,
        prot: *mut ::std::os::raw::c_int,
    ) -> *mut MemoryRegionSection;
}
unsafe extern "C" {
    pub fn memory_region_section_get_iotlb(
        cpu: *mut CPUState,
        section: *mut MemoryRegionSection,
    ) -> hwaddr;
}
pub const GDB_SIGNAL_0: _bindgen_ty_53 = 0;
pub const GDB_SIGNAL_INT: _bindgen_ty_53 = 2;
pub const GDB_SIGNAL_QUIT: _bindgen_ty_53 = 3;
pub const GDB_SIGNAL_TRAP: _bindgen_ty_53 = 5;
pub const GDB_SIGNAL_ABRT: _bindgen_ty_53 = 6;
pub const GDB_SIGNAL_ALRM: _bindgen_ty_53 = 14;
pub const GDB_SIGNAL_STOP: _bindgen_ty_53 = 17;
pub const GDB_SIGNAL_IO: _bindgen_ty_53 = 23;
pub const GDB_SIGNAL_XCPU: _bindgen_ty_53 = 24;
pub const GDB_SIGNAL_UNKNOWN: _bindgen_ty_53 = 143;
pub type _bindgen_ty_53 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDBProcess {
    pub pid: u32,
    pub attached: bool,
    pub target_xml: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GDBProcess"][::std::mem::size_of::<GDBProcess>() - 16usize];
    ["Alignment of GDBProcess"][::std::mem::align_of::<GDBProcess>() - 8usize];
    ["Offset of field: GDBProcess::pid"][::std::mem::offset_of!(GDBProcess, pid) - 0usize];
    ["Offset of field: GDBProcess::attached"]
        [::std::mem::offset_of!(GDBProcess, attached) - 4usize];
    ["Offset of field: GDBProcess::target_xml"]
        [::std::mem::offset_of!(GDBProcess, target_xml) - 8usize];
};
pub const RS_INACTIVE: RSState = 0;
pub const RS_IDLE: RSState = 1;
pub const RS_GETLINE: RSState = 2;
pub const RS_GETLINE_ESC: RSState = 3;
pub const RS_GETLINE_RLE: RSState = 4;
pub const RS_CHKSUM1: RSState = 5;
pub const RS_CHKSUM2: RSState = 6;
pub type RSState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDBState {
    pub init: bool,
    pub c_cpu: *mut CPUState,
    pub g_cpu: *mut CPUState,
    pub query_cpu: *mut CPUState,
    pub state: RSState,
    pub line_buf: [::std::os::raw::c_char; 4096usize],
    pub line_buf_index: ::std::os::raw::c_int,
    pub line_sum: ::std::os::raw::c_int,
    pub line_csum: ::std::os::raw::c_int,
    pub last_packet: *mut GByteArray,
    pub signal: ::std::os::raw::c_int,
    pub multiprocess: bool,
    pub processes: *mut GDBProcess,
    pub process_num: ::std::os::raw::c_int,
    pub str_buf: *mut GString,
    pub mem_buf: *mut GByteArray,
    pub sstep_flags: ::std::os::raw::c_int,
    pub supported_sstep_flags: ::std::os::raw::c_int,
    pub allow_stop_reply: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GDBState"][::std::mem::size_of::<GDBState>() - 4208usize];
    ["Alignment of GDBState"][::std::mem::align_of::<GDBState>() - 8usize];
    ["Offset of field: GDBState::init"][::std::mem::offset_of!(GDBState, init) - 0usize];
    ["Offset of field: GDBState::c_cpu"][::std::mem::offset_of!(GDBState, c_cpu) - 8usize];
    ["Offset of field: GDBState::g_cpu"][::std::mem::offset_of!(GDBState, g_cpu) - 16usize];
    ["Offset of field: GDBState::query_cpu"][::std::mem::offset_of!(GDBState, query_cpu) - 24usize];
    ["Offset of field: GDBState::state"][::std::mem::offset_of!(GDBState, state) - 32usize];
    ["Offset of field: GDBState::line_buf"][::std::mem::offset_of!(GDBState, line_buf) - 36usize];
    ["Offset of field: GDBState::line_buf_index"]
        [::std::mem::offset_of!(GDBState, line_buf_index) - 4132usize];
    ["Offset of field: GDBState::line_sum"][::std::mem::offset_of!(GDBState, line_sum) - 4136usize];
    ["Offset of field: GDBState::line_csum"]
        [::std::mem::offset_of!(GDBState, line_csum) - 4140usize];
    ["Offset of field: GDBState::last_packet"]
        [::std::mem::offset_of!(GDBState, last_packet) - 4144usize];
    ["Offset of field: GDBState::signal"][::std::mem::offset_of!(GDBState, signal) - 4152usize];
    ["Offset of field: GDBState::multiprocess"]
        [::std::mem::offset_of!(GDBState, multiprocess) - 4156usize];
    ["Offset of field: GDBState::processes"]
        [::std::mem::offset_of!(GDBState, processes) - 4160usize];
    ["Offset of field: GDBState::process_num"]
        [::std::mem::offset_of!(GDBState, process_num) - 4168usize];
    ["Offset of field: GDBState::str_buf"][::std::mem::offset_of!(GDBState, str_buf) - 4176usize];
    ["Offset of field: GDBState::mem_buf"][::std::mem::offset_of!(GDBState, mem_buf) - 4184usize];
    ["Offset of field: GDBState::sstep_flags"]
        [::std::mem::offset_of!(GDBState, sstep_flags) - 4192usize];
    ["Offset of field: GDBState::supported_sstep_flags"]
        [::std::mem::offset_of!(GDBState, supported_sstep_flags) - 4196usize];
    ["Offset of field: GDBState::allow_stop_reply"]
        [::std::mem::offset_of!(GDBState, allow_stop_reply) - 4200usize];
};
unsafe extern "C" {
    pub static mut gdbserver_state: GDBState;
}
unsafe extern "C" {
    pub fn gdb_put_strbuf();
}
unsafe extern "C" {
    pub fn gdb_put_packet_binary(
        buf: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dump: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gdb_memtohex(buf: *mut GString, mem: *const u8, len: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn gdb_memtox(
        buf: *mut GString,
        mem: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn gdb_read_byte(ch: u8);
}
unsafe extern "C" {
    pub fn gdb_got_immediate_ack() -> bool;
}
unsafe extern "C" {
    pub fn gdb_get_process(pid: u32) -> *mut GDBProcess;
}
unsafe extern "C" {
    pub fn gdb_get_first_cpu_in_process(process: *mut GDBProcess) -> *mut CPUState;
}
unsafe extern "C" {
    pub fn gdb_first_attached_cpu() -> *mut CPUState;
}
unsafe extern "C" {
    pub fn gdb_append_thread_id(cpu: *mut CPUState, buf: *mut GString);
}
unsafe extern "C" {
    pub fn gdb_get_cpu_index(cpu: *mut CPUState) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gdb_get_max_cpus() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn gdb_can_reverse() -> bool;
}
unsafe extern "C" {
    pub fn gdb_target_sigtrap() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gdb_create_default_process(s: *mut GDBState);
}
unsafe extern "C" {
    pub fn gdb_signal_to_target(sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gdb_target_signal_to_gdb(sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gdb_get_char() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gdb_continue();
}
unsafe extern "C" {
    pub fn gdb_continue_partial(newstates: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gdb_put_buffer(buf: *const u8, len: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn gdb_init_gdbserver_state();
}
unsafe extern "C" {
    pub fn gdb_handle_query_rcmd(params: *mut GArray, ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn gdb_handle_query_offsets(params: *mut GArray, user_ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn gdb_handle_query_xfer_auxv(params: *mut GArray, user_ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn gdb_handle_query_xfer_siginfo(
        params: *mut GArray,
        user_ctx: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn gdb_handle_v_file_open(params: *mut GArray, user_ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn gdb_handle_v_file_close(params: *mut GArray, user_ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn gdb_handle_v_file_pread(params: *mut GArray, user_ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn gdb_handle_v_file_readlink(params: *mut GArray, user_ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn gdb_handle_query_xfer_exec_file(
        params: *mut GArray,
        user_ctx: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn gdb_handle_set_catch_syscalls(
        params: *mut GArray,
        user_ctx: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn gdb_handle_query_supported_user(gdb_supported: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gdb_handle_set_thread_user(pid: u32, tid: u32) -> bool;
}
unsafe extern "C" {
    pub fn gdb_handle_detach_user(pid: u32) -> bool;
}
unsafe extern "C" {
    pub fn gdb_handle_query_attached(params: *mut GArray, ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn gdb_handle_query_qemu_phy_mem_mode(
        params: *mut GArray,
        ctx: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn gdb_handle_set_qemu_phy_mem_mode(params: *mut GArray, ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn gdb_handle_file_io(params: *mut GArray, user_ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn gdb_handled_syscall() -> bool;
}
unsafe extern "C" {
    pub fn gdb_disable_syscalls();
}
unsafe extern "C" {
    pub fn gdb_syscall_reset();
}
unsafe extern "C" {
    pub fn gdb_syscall_handling(syscall_packet: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn gdb_supports_guest_debug() -> bool;
}
unsafe extern "C" {
    pub fn gdb_breakpoint_insert(
        cs: *mut CPUState,
        type_: ::std::os::raw::c_int,
        addr: vaddr,
        len: vaddr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gdb_breakpoint_remove(
        cs: *mut CPUState,
        type_: ::std::os::raw::c_int,
        addr: vaddr,
        len: vaddr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gdb_breakpoint_remove_all(cs: *mut CPUState);
}
unsafe extern "C" {
    pub fn gdb_target_memory_rw_debug(
        cs: *mut CPUState,
        addr: hwaddr,
        buf: *mut u8,
        len: ::std::os::raw::c_int,
        is_write: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_cleanup();
}
unsafe extern "C" {
    pub fn panda_set_os_name(os_name: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn panda_before_find_fast();
}
unsafe extern "C" {
    pub fn panda_disas(
        out: *mut FILE,
        code: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_ulong,
    );
}
unsafe extern "C" {
    pub fn panda_break_main_loop();
}
unsafe extern "C" {
    pub fn panda_find_ram() -> *mut MemoryRegion;
}
unsafe extern "C" {
    pub static mut panda_exit_loop: bool;
}
unsafe extern "C" {
    pub static mut panda_break_vl_loop_req: bool;
}
unsafe extern "C" {
    pub fn panda_current_asid(env: *mut CPUState) -> target_ulong;
}
unsafe extern "C" {
    pub fn panda_current_pc(cpu: *mut CPUState) -> target_ulong;
}
unsafe extern "C" {
    pub fn panda_find_max_ram_address() -> Int128;
}
unsafe extern "C" {
    pub fn panda_physical_memory_rw(
        addr: hwaddr,
        buf: *mut u8,
        len: ::std::os::raw::c_int,
        is_write: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_physical_memory_read(
        addr: hwaddr,
        buf: *mut u8,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_physical_memory_write(
        addr: hwaddr,
        buf: *mut u8,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_virt_to_phys(env: *mut CPUState, addr: target_ulong) -> hwaddr;
}
unsafe extern "C" {
    pub fn enter_priv(cpu: *mut CPUState) -> bool;
}
unsafe extern "C" {
    pub fn exit_priv(cpu: *mut CPUState);
}
unsafe extern "C" {
    pub fn panda_virtual_memory_rw(
        cpu: *mut CPUState,
        addr: target_ulong,
        buf: *mut u8,
        len: ::std::os::raw::c_int,
        is_write: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_virtual_memory_read(
        env: *mut CPUState,
        addr: target_ulong,
        buf: *mut u8,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_virtual_memory_write(
        env: *mut CPUState,
        addr: target_ulong,
        buf: *mut u8,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_map_virt_to_host(
        env: *mut CPUState,
        addr: target_ulong,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn panda_in_kernel_mode(cpu: *const CPUState) -> bool;
}
unsafe extern "C" {
    pub fn panda_in_kernel(cpu: *const CPUState) -> bool;
}
unsafe extern "C" {
    pub fn address_in_kernel_code_linux(addr: target_ulong) -> bool;
}
unsafe extern "C" {
    pub fn panda_in_kernel_code_linux(cpu: *mut CPUState) -> bool;
}
unsafe extern "C" {
    pub fn panda_current_ksp(cpu: *mut CPUState) -> target_ulong;
}
unsafe extern "C" {
    pub fn panda_current_sp(cpu: *const CPUState) -> target_ulong;
}
unsafe extern "C" {
    pub fn panda_get_retval(cpu: *const CPUState) -> target_ulong;
}
pub const TCG_MO_LD_LD: TCGBar = 1;
pub const TCG_MO_ST_LD: TCGBar = 2;
pub const TCG_MO_LD_ST: TCGBar = 4;
pub const TCG_MO_ST_ST: TCGBar = 8;
pub const TCG_MO_ALL: TCGBar = 15;
pub const TCG_BAR_LDAQ: TCGBar = 16;
pub const TCG_BAR_STRL: TCGBar = 32;
pub const TCG_BAR_SC: TCGBar = 48;
pub type TCGBar = ::std::os::raw::c_uint;
pub const TCG_REG_EAX: TCGReg = 0;
pub const TCG_REG_ECX: TCGReg = 1;
pub const TCG_REG_EDX: TCGReg = 2;
pub const TCG_REG_EBX: TCGReg = 3;
pub const TCG_REG_ESP: TCGReg = 4;
pub const TCG_REG_EBP: TCGReg = 5;
pub const TCG_REG_ESI: TCGReg = 6;
pub const TCG_REG_EDI: TCGReg = 7;
pub const TCG_REG_R8: TCGReg = 8;
pub const TCG_REG_R9: TCGReg = 9;
pub const TCG_REG_R10: TCGReg = 10;
pub const TCG_REG_R11: TCGReg = 11;
pub const TCG_REG_R12: TCGReg = 12;
pub const TCG_REG_R13: TCGReg = 13;
pub const TCG_REG_R14: TCGReg = 14;
pub const TCG_REG_R15: TCGReg = 15;
pub const TCG_REG_XMM0: TCGReg = 16;
pub const TCG_REG_XMM1: TCGReg = 17;
pub const TCG_REG_XMM2: TCGReg = 18;
pub const TCG_REG_XMM3: TCGReg = 19;
pub const TCG_REG_XMM4: TCGReg = 20;
pub const TCG_REG_XMM5: TCGReg = 21;
pub const TCG_REG_XMM6: TCGReg = 22;
pub const TCG_REG_XMM7: TCGReg = 23;
pub const TCG_REG_XMM8: TCGReg = 24;
pub const TCG_REG_XMM9: TCGReg = 25;
pub const TCG_REG_XMM10: TCGReg = 26;
pub const TCG_REG_XMM11: TCGReg = 27;
pub const TCG_REG_XMM12: TCGReg = 28;
pub const TCG_REG_XMM13: TCGReg = 29;
pub const TCG_REG_XMM14: TCGReg = 30;
pub const TCG_REG_XMM15: TCGReg = 31;
pub const TCG_REG_RAX: TCGReg = 0;
pub const TCG_REG_RCX: TCGReg = 1;
pub const TCG_REG_RDX: TCGReg = 2;
pub const TCG_REG_RBX: TCGReg = 3;
pub const TCG_REG_RSP: TCGReg = 4;
pub const TCG_REG_RBP: TCGReg = 5;
pub const TCG_REG_RSI: TCGReg = 6;
pub const TCG_REG_RDI: TCGReg = 7;
pub const TCG_AREG0: TCGReg = 5;
pub const TCG_REG_CALL_STACK: TCGReg = 4;
pub type TCGReg = ::std::os::raw::c_uint;
pub const TCG_COND_NEVER: TCGCond = 0;
pub const TCG_COND_ALWAYS: TCGCond = 1;
pub const TCG_COND_EQ: TCGCond = 8;
pub const TCG_COND_NE: TCGCond = 9;
pub const TCG_COND_TSTEQ: TCGCond = 12;
pub const TCG_COND_TSTNE: TCGCond = 13;
pub const TCG_COND_LT: TCGCond = 2;
pub const TCG_COND_GE: TCGCond = 3;
pub const TCG_COND_GT: TCGCond = 6;
pub const TCG_COND_LE: TCGCond = 7;
pub const TCG_COND_LTU: TCGCond = 10;
pub const TCG_COND_GEU: TCGCond = 11;
pub const TCG_COND_GTU: TCGCond = 14;
pub const TCG_COND_LEU: TCGCond = 15;
pub type TCGCond = ::std::os::raw::c_uint;
pub type tcg_target_long = i64;
pub type tcg_target_ulong = u64;
pub type TCGRegSet = u32;
pub const INDEX_op_discard: TCGOpcode = 0;
pub const INDEX_op_set_label: TCGOpcode = 1;
pub const INDEX_op_call: TCGOpcode = 2;
pub const INDEX_op_br: TCGOpcode = 3;
pub const INDEX_op_mb: TCGOpcode = 4;
pub const INDEX_op_mov_i32: TCGOpcode = 5;
pub const INDEX_op_setcond_i32: TCGOpcode = 6;
pub const INDEX_op_negsetcond_i32: TCGOpcode = 7;
pub const INDEX_op_movcond_i32: TCGOpcode = 8;
pub const INDEX_op_ld8u_i32: TCGOpcode = 9;
pub const INDEX_op_ld8s_i32: TCGOpcode = 10;
pub const INDEX_op_ld16u_i32: TCGOpcode = 11;
pub const INDEX_op_ld16s_i32: TCGOpcode = 12;
pub const INDEX_op_ld_i32: TCGOpcode = 13;
pub const INDEX_op_st8_i32: TCGOpcode = 14;
pub const INDEX_op_st16_i32: TCGOpcode = 15;
pub const INDEX_op_st_i32: TCGOpcode = 16;
pub const INDEX_op_add_i32: TCGOpcode = 17;
pub const INDEX_op_sub_i32: TCGOpcode = 18;
pub const INDEX_op_mul_i32: TCGOpcode = 19;
pub const INDEX_op_div_i32: TCGOpcode = 20;
pub const INDEX_op_divu_i32: TCGOpcode = 21;
pub const INDEX_op_rem_i32: TCGOpcode = 22;
pub const INDEX_op_remu_i32: TCGOpcode = 23;
pub const INDEX_op_div2_i32: TCGOpcode = 24;
pub const INDEX_op_divu2_i32: TCGOpcode = 25;
pub const INDEX_op_and_i32: TCGOpcode = 26;
pub const INDEX_op_or_i32: TCGOpcode = 27;
pub const INDEX_op_xor_i32: TCGOpcode = 28;
pub const INDEX_op_shl_i32: TCGOpcode = 29;
pub const INDEX_op_shr_i32: TCGOpcode = 30;
pub const INDEX_op_sar_i32: TCGOpcode = 31;
pub const INDEX_op_rotl_i32: TCGOpcode = 32;
pub const INDEX_op_rotr_i32: TCGOpcode = 33;
pub const INDEX_op_deposit_i32: TCGOpcode = 34;
pub const INDEX_op_extract_i32: TCGOpcode = 35;
pub const INDEX_op_sextract_i32: TCGOpcode = 36;
pub const INDEX_op_extract2_i32: TCGOpcode = 37;
pub const INDEX_op_brcond_i32: TCGOpcode = 38;
pub const INDEX_op_add2_i32: TCGOpcode = 39;
pub const INDEX_op_sub2_i32: TCGOpcode = 40;
pub const INDEX_op_mulu2_i32: TCGOpcode = 41;
pub const INDEX_op_muls2_i32: TCGOpcode = 42;
pub const INDEX_op_muluh_i32: TCGOpcode = 43;
pub const INDEX_op_mulsh_i32: TCGOpcode = 44;
pub const INDEX_op_brcond2_i32: TCGOpcode = 45;
pub const INDEX_op_setcond2_i32: TCGOpcode = 46;
pub const INDEX_op_ext8s_i32: TCGOpcode = 47;
pub const INDEX_op_ext16s_i32: TCGOpcode = 48;
pub const INDEX_op_ext8u_i32: TCGOpcode = 49;
pub const INDEX_op_ext16u_i32: TCGOpcode = 50;
pub const INDEX_op_bswap16_i32: TCGOpcode = 51;
pub const INDEX_op_bswap32_i32: TCGOpcode = 52;
pub const INDEX_op_not_i32: TCGOpcode = 53;
pub const INDEX_op_neg_i32: TCGOpcode = 54;
pub const INDEX_op_andc_i32: TCGOpcode = 55;
pub const INDEX_op_orc_i32: TCGOpcode = 56;
pub const INDEX_op_eqv_i32: TCGOpcode = 57;
pub const INDEX_op_nand_i32: TCGOpcode = 58;
pub const INDEX_op_nor_i32: TCGOpcode = 59;
pub const INDEX_op_clz_i32: TCGOpcode = 60;
pub const INDEX_op_ctz_i32: TCGOpcode = 61;
pub const INDEX_op_ctpop_i32: TCGOpcode = 62;
pub const INDEX_op_mov_i64: TCGOpcode = 63;
pub const INDEX_op_setcond_i64: TCGOpcode = 64;
pub const INDEX_op_negsetcond_i64: TCGOpcode = 65;
pub const INDEX_op_movcond_i64: TCGOpcode = 66;
pub const INDEX_op_ld8u_i64: TCGOpcode = 67;
pub const INDEX_op_ld8s_i64: TCGOpcode = 68;
pub const INDEX_op_ld16u_i64: TCGOpcode = 69;
pub const INDEX_op_ld16s_i64: TCGOpcode = 70;
pub const INDEX_op_ld32u_i64: TCGOpcode = 71;
pub const INDEX_op_ld32s_i64: TCGOpcode = 72;
pub const INDEX_op_ld_i64: TCGOpcode = 73;
pub const INDEX_op_st8_i64: TCGOpcode = 74;
pub const INDEX_op_st16_i64: TCGOpcode = 75;
pub const INDEX_op_st32_i64: TCGOpcode = 76;
pub const INDEX_op_st_i64: TCGOpcode = 77;
pub const INDEX_op_add_i64: TCGOpcode = 78;
pub const INDEX_op_sub_i64: TCGOpcode = 79;
pub const INDEX_op_mul_i64: TCGOpcode = 80;
pub const INDEX_op_div_i64: TCGOpcode = 81;
pub const INDEX_op_divu_i64: TCGOpcode = 82;
pub const INDEX_op_rem_i64: TCGOpcode = 83;
pub const INDEX_op_remu_i64: TCGOpcode = 84;
pub const INDEX_op_div2_i64: TCGOpcode = 85;
pub const INDEX_op_divu2_i64: TCGOpcode = 86;
pub const INDEX_op_and_i64: TCGOpcode = 87;
pub const INDEX_op_or_i64: TCGOpcode = 88;
pub const INDEX_op_xor_i64: TCGOpcode = 89;
pub const INDEX_op_shl_i64: TCGOpcode = 90;
pub const INDEX_op_shr_i64: TCGOpcode = 91;
pub const INDEX_op_sar_i64: TCGOpcode = 92;
pub const INDEX_op_rotl_i64: TCGOpcode = 93;
pub const INDEX_op_rotr_i64: TCGOpcode = 94;
pub const INDEX_op_deposit_i64: TCGOpcode = 95;
pub const INDEX_op_extract_i64: TCGOpcode = 96;
pub const INDEX_op_sextract_i64: TCGOpcode = 97;
pub const INDEX_op_extract2_i64: TCGOpcode = 98;
pub const INDEX_op_ext_i32_i64: TCGOpcode = 99;
pub const INDEX_op_extu_i32_i64: TCGOpcode = 100;
pub const INDEX_op_extrl_i64_i32: TCGOpcode = 101;
pub const INDEX_op_extrh_i64_i32: TCGOpcode = 102;
pub const INDEX_op_brcond_i64: TCGOpcode = 103;
pub const INDEX_op_ext8s_i64: TCGOpcode = 104;
pub const INDEX_op_ext16s_i64: TCGOpcode = 105;
pub const INDEX_op_ext32s_i64: TCGOpcode = 106;
pub const INDEX_op_ext8u_i64: TCGOpcode = 107;
pub const INDEX_op_ext16u_i64: TCGOpcode = 108;
pub const INDEX_op_ext32u_i64: TCGOpcode = 109;
pub const INDEX_op_bswap16_i64: TCGOpcode = 110;
pub const INDEX_op_bswap32_i64: TCGOpcode = 111;
pub const INDEX_op_bswap64_i64: TCGOpcode = 112;
pub const INDEX_op_not_i64: TCGOpcode = 113;
pub const INDEX_op_neg_i64: TCGOpcode = 114;
pub const INDEX_op_andc_i64: TCGOpcode = 115;
pub const INDEX_op_orc_i64: TCGOpcode = 116;
pub const INDEX_op_eqv_i64: TCGOpcode = 117;
pub const INDEX_op_nand_i64: TCGOpcode = 118;
pub const INDEX_op_nor_i64: TCGOpcode = 119;
pub const INDEX_op_clz_i64: TCGOpcode = 120;
pub const INDEX_op_ctz_i64: TCGOpcode = 121;
pub const INDEX_op_ctpop_i64: TCGOpcode = 122;
pub const INDEX_op_add2_i64: TCGOpcode = 123;
pub const INDEX_op_sub2_i64: TCGOpcode = 124;
pub const INDEX_op_mulu2_i64: TCGOpcode = 125;
pub const INDEX_op_muls2_i64: TCGOpcode = 126;
pub const INDEX_op_muluh_i64: TCGOpcode = 127;
pub const INDEX_op_mulsh_i64: TCGOpcode = 128;
pub const INDEX_op_insn_start: TCGOpcode = 129;
pub const INDEX_op_exit_tb: TCGOpcode = 130;
pub const INDEX_op_goto_tb: TCGOpcode = 131;
pub const INDEX_op_goto_ptr: TCGOpcode = 132;
pub const INDEX_op_plugin_cb: TCGOpcode = 133;
pub const INDEX_op_plugin_mem_cb: TCGOpcode = 134;
pub const INDEX_op_qemu_ld_a32_i32: TCGOpcode = 135;
pub const INDEX_op_qemu_st_a32_i32: TCGOpcode = 136;
pub const INDEX_op_qemu_ld_a32_i64: TCGOpcode = 137;
pub const INDEX_op_qemu_st_a32_i64: TCGOpcode = 138;
pub const INDEX_op_qemu_ld_a64_i32: TCGOpcode = 139;
pub const INDEX_op_qemu_st_a64_i32: TCGOpcode = 140;
pub const INDEX_op_qemu_ld_a64_i64: TCGOpcode = 141;
pub const INDEX_op_qemu_st_a64_i64: TCGOpcode = 142;
pub const INDEX_op_qemu_st8_a32_i32: TCGOpcode = 143;
pub const INDEX_op_qemu_st8_a64_i32: TCGOpcode = 144;
pub const INDEX_op_qemu_ld_a32_i128: TCGOpcode = 145;
pub const INDEX_op_qemu_ld_a64_i128: TCGOpcode = 146;
pub const INDEX_op_qemu_st_a32_i128: TCGOpcode = 147;
pub const INDEX_op_qemu_st_a64_i128: TCGOpcode = 148;
pub const INDEX_op_mov_vec: TCGOpcode = 149;
pub const INDEX_op_dup_vec: TCGOpcode = 150;
pub const INDEX_op_dup2_vec: TCGOpcode = 151;
pub const INDEX_op_ld_vec: TCGOpcode = 152;
pub const INDEX_op_st_vec: TCGOpcode = 153;
pub const INDEX_op_dupm_vec: TCGOpcode = 154;
pub const INDEX_op_add_vec: TCGOpcode = 155;
pub const INDEX_op_sub_vec: TCGOpcode = 156;
pub const INDEX_op_mul_vec: TCGOpcode = 157;
pub const INDEX_op_neg_vec: TCGOpcode = 158;
pub const INDEX_op_abs_vec: TCGOpcode = 159;
pub const INDEX_op_ssadd_vec: TCGOpcode = 160;
pub const INDEX_op_usadd_vec: TCGOpcode = 161;
pub const INDEX_op_sssub_vec: TCGOpcode = 162;
pub const INDEX_op_ussub_vec: TCGOpcode = 163;
pub const INDEX_op_smin_vec: TCGOpcode = 164;
pub const INDEX_op_umin_vec: TCGOpcode = 165;
pub const INDEX_op_smax_vec: TCGOpcode = 166;
pub const INDEX_op_umax_vec: TCGOpcode = 167;
pub const INDEX_op_and_vec: TCGOpcode = 168;
pub const INDEX_op_or_vec: TCGOpcode = 169;
pub const INDEX_op_xor_vec: TCGOpcode = 170;
pub const INDEX_op_andc_vec: TCGOpcode = 171;
pub const INDEX_op_orc_vec: TCGOpcode = 172;
pub const INDEX_op_nand_vec: TCGOpcode = 173;
pub const INDEX_op_nor_vec: TCGOpcode = 174;
pub const INDEX_op_eqv_vec: TCGOpcode = 175;
pub const INDEX_op_not_vec: TCGOpcode = 176;
pub const INDEX_op_shli_vec: TCGOpcode = 177;
pub const INDEX_op_shri_vec: TCGOpcode = 178;
pub const INDEX_op_sari_vec: TCGOpcode = 179;
pub const INDEX_op_rotli_vec: TCGOpcode = 180;
pub const INDEX_op_shls_vec: TCGOpcode = 181;
pub const INDEX_op_shrs_vec: TCGOpcode = 182;
pub const INDEX_op_sars_vec: TCGOpcode = 183;
pub const INDEX_op_rotls_vec: TCGOpcode = 184;
pub const INDEX_op_shlv_vec: TCGOpcode = 185;
pub const INDEX_op_shrv_vec: TCGOpcode = 186;
pub const INDEX_op_sarv_vec: TCGOpcode = 187;
pub const INDEX_op_rotlv_vec: TCGOpcode = 188;
pub const INDEX_op_rotrv_vec: TCGOpcode = 189;
pub const INDEX_op_cmp_vec: TCGOpcode = 190;
pub const INDEX_op_bitsel_vec: TCGOpcode = 191;
pub const INDEX_op_cmpsel_vec: TCGOpcode = 192;
pub const INDEX_op_last_generic: TCGOpcode = 193;
pub const INDEX_op_x86_shufps_vec: TCGOpcode = 194;
pub const INDEX_op_x86_blend_vec: TCGOpcode = 195;
pub const INDEX_op_x86_packss_vec: TCGOpcode = 196;
pub const INDEX_op_x86_packus_vec: TCGOpcode = 197;
pub const INDEX_op_x86_psrldq_vec: TCGOpcode = 198;
pub const INDEX_op_x86_vperm2i128_vec: TCGOpcode = 199;
pub const INDEX_op_x86_punpckl_vec: TCGOpcode = 200;
pub const INDEX_op_x86_punpckh_vec: TCGOpcode = 201;
pub const INDEX_op_x86_vpshldi_vec: TCGOpcode = 202;
pub const INDEX_op_x86_vpshldv_vec: TCGOpcode = 203;
pub const INDEX_op_x86_vpshrdv_vec: TCGOpcode = 204;
pub const NB_OPS: TCGOpcode = 205;
pub type TCGOpcode = ::std::os::raw::c_uint;
pub type tcg_insn_unit = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGRelocation {
    pub next: TCGRelocation__bindgen_ty_1,
    pub ptr: *mut tcg_insn_unit,
    pub addend: isize,
    pub type_: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGRelocation__bindgen_ty_1 {
    pub sqe_next: *mut TCGRelocation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGRelocation__bindgen_ty_1"]
        [::std::mem::size_of::<TCGRelocation__bindgen_ty_1>() - 8usize];
    ["Alignment of TCGRelocation__bindgen_ty_1"]
        [::std::mem::align_of::<TCGRelocation__bindgen_ty_1>() - 8usize];
    ["Offset of field: TCGRelocation__bindgen_ty_1::sqe_next"]
        [::std::mem::offset_of!(TCGRelocation__bindgen_ty_1, sqe_next) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGRelocation"][::std::mem::size_of::<TCGRelocation>() - 32usize];
    ["Alignment of TCGRelocation"][::std::mem::align_of::<TCGRelocation>() - 8usize];
    ["Offset of field: TCGRelocation::next"][::std::mem::offset_of!(TCGRelocation, next) - 0usize];
    ["Offset of field: TCGRelocation::ptr"][::std::mem::offset_of!(TCGRelocation, ptr) - 8usize];
    ["Offset of field: TCGRelocation::addend"]
        [::std::mem::offset_of!(TCGRelocation, addend) - 16usize];
    ["Offset of field: TCGRelocation::type_"]
        [::std::mem::offset_of!(TCGRelocation, type_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGLabelUse {
    pub next: TCGLabelUse__bindgen_ty_1,
    pub op: *mut TCGOp,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGLabelUse__bindgen_ty_1 {
    pub sqe_next: *mut TCGLabelUse,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGLabelUse__bindgen_ty_1"]
        [::std::mem::size_of::<TCGLabelUse__bindgen_ty_1>() - 8usize];
    ["Alignment of TCGLabelUse__bindgen_ty_1"]
        [::std::mem::align_of::<TCGLabelUse__bindgen_ty_1>() - 8usize];
    ["Offset of field: TCGLabelUse__bindgen_ty_1::sqe_next"]
        [::std::mem::offset_of!(TCGLabelUse__bindgen_ty_1, sqe_next) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGLabelUse"][::std::mem::size_of::<TCGLabelUse>() - 16usize];
    ["Alignment of TCGLabelUse"][::std::mem::align_of::<TCGLabelUse>() - 8usize];
    ["Offset of field: TCGLabelUse::next"][::std::mem::offset_of!(TCGLabelUse, next) - 0usize];
    ["Offset of field: TCGLabelUse::op"][::std::mem::offset_of!(TCGLabelUse, op) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TCGLabel {
    pub present: bool,
    pub has_value: bool,
    pub id: u16,
    pub u: TCGLabel__bindgen_ty_1,
    pub branches: TCGLabel__bindgen_ty_2,
    pub relocs: TCGLabel__bindgen_ty_3,
    pub next: TCGLabel__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCGLabel__bindgen_ty_1 {
    pub value: usize,
    pub value_ptr: *const tcg_insn_unit,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGLabel__bindgen_ty_1"][::std::mem::size_of::<TCGLabel__bindgen_ty_1>() - 8usize];
    ["Alignment of TCGLabel__bindgen_ty_1"]
        [::std::mem::align_of::<TCGLabel__bindgen_ty_1>() - 8usize];
    ["Offset of field: TCGLabel__bindgen_ty_1::value"]
        [::std::mem::offset_of!(TCGLabel__bindgen_ty_1, value) - 0usize];
    ["Offset of field: TCGLabel__bindgen_ty_1::value_ptr"]
        [::std::mem::offset_of!(TCGLabel__bindgen_ty_1, value_ptr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGLabel__bindgen_ty_2 {
    pub sqh_first: *mut TCGLabelUse,
    pub sqh_last: *mut *mut TCGLabelUse,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGLabel__bindgen_ty_2"][::std::mem::size_of::<TCGLabel__bindgen_ty_2>() - 16usize];
    ["Alignment of TCGLabel__bindgen_ty_2"]
        [::std::mem::align_of::<TCGLabel__bindgen_ty_2>() - 8usize];
    ["Offset of field: TCGLabel__bindgen_ty_2::sqh_first"]
        [::std::mem::offset_of!(TCGLabel__bindgen_ty_2, sqh_first) - 0usize];
    ["Offset of field: TCGLabel__bindgen_ty_2::sqh_last"]
        [::std::mem::offset_of!(TCGLabel__bindgen_ty_2, sqh_last) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGLabel__bindgen_ty_3 {
    pub sqh_first: *mut TCGRelocation,
    pub sqh_last: *mut *mut TCGRelocation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGLabel__bindgen_ty_3"][::std::mem::size_of::<TCGLabel__bindgen_ty_3>() - 16usize];
    ["Alignment of TCGLabel__bindgen_ty_3"]
        [::std::mem::align_of::<TCGLabel__bindgen_ty_3>() - 8usize];
    ["Offset of field: TCGLabel__bindgen_ty_3::sqh_first"]
        [::std::mem::offset_of!(TCGLabel__bindgen_ty_3, sqh_first) - 0usize];
    ["Offset of field: TCGLabel__bindgen_ty_3::sqh_last"]
        [::std::mem::offset_of!(TCGLabel__bindgen_ty_3, sqh_last) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGLabel__bindgen_ty_4 {
    pub sqe_next: *mut TCGLabel,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGLabel__bindgen_ty_4"][::std::mem::size_of::<TCGLabel__bindgen_ty_4>() - 8usize];
    ["Alignment of TCGLabel__bindgen_ty_4"]
        [::std::mem::align_of::<TCGLabel__bindgen_ty_4>() - 8usize];
    ["Offset of field: TCGLabel__bindgen_ty_4::sqe_next"]
        [::std::mem::offset_of!(TCGLabel__bindgen_ty_4, sqe_next) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGLabel"][::std::mem::size_of::<TCGLabel>() - 56usize];
    ["Alignment of TCGLabel"][::std::mem::align_of::<TCGLabel>() - 8usize];
    ["Offset of field: TCGLabel::present"][::std::mem::offset_of!(TCGLabel, present) - 0usize];
    ["Offset of field: TCGLabel::has_value"][::std::mem::offset_of!(TCGLabel, has_value) - 1usize];
    ["Offset of field: TCGLabel::id"][::std::mem::offset_of!(TCGLabel, id) - 2usize];
    ["Offset of field: TCGLabel::u"][::std::mem::offset_of!(TCGLabel, u) - 8usize];
    ["Offset of field: TCGLabel::branches"][::std::mem::offset_of!(TCGLabel, branches) - 16usize];
    ["Offset of field: TCGLabel::relocs"][::std::mem::offset_of!(TCGLabel, relocs) - 32usize];
    ["Offset of field: TCGLabel::next"][::std::mem::offset_of!(TCGLabel, next) - 48usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug)]
pub struct TCGPool {
    pub next: *mut TCGPool,
    pub size: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u8; 4usize],
    pub data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGPool"][::std::mem::size_of::<TCGPool>() - 16usize];
    ["Alignment of TCGPool"][::std::mem::align_of::<TCGPool>() - 16usize];
    ["Offset of field: TCGPool::next"][::std::mem::offset_of!(TCGPool, next) - 0usize];
    ["Offset of field: TCGPool::size"][::std::mem::offset_of!(TCGPool, size) - 8usize];
    ["Offset of field: TCGPool::data"][::std::mem::offset_of!(TCGPool, data) - 16usize];
};
pub const TCG_TYPE_I32: TCGType = 0;
pub const TCG_TYPE_I64: TCGType = 1;
pub const TCG_TYPE_I128: TCGType = 2;
pub const TCG_TYPE_V64: TCGType = 3;
pub const TCG_TYPE_V128: TCGType = 4;
pub const TCG_TYPE_V256: TCGType = 5;
pub const TCG_TYPE_REG: TCGType = 1;
pub const TCG_TYPE_PTR: TCGType = 1;
pub type TCGType = ::std::os::raw::c_uint;
pub type TCGArg = tcg_target_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGv_i32_d {
    _unused: [u8; 0],
}
pub type TCGv_i32 = *mut TCGv_i32_d;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGv_i64_d {
    _unused: [u8; 0],
}
pub type TCGv_i64 = *mut TCGv_i64_d;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGv_i128_d {
    _unused: [u8; 0],
}
pub type TCGv_i128 = *mut TCGv_i128_d;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGv_ptr_d {
    _unused: [u8; 0],
}
pub type TCGv_ptr = *mut TCGv_ptr_d;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGv_vec_d {
    _unused: [u8; 0],
}
pub type TCGv_vec = *mut TCGv_vec_d;
pub type TCGv_env = TCGv_ptr;
pub const TCG_BSWAP_IZ: _bindgen_ty_54 = 1;
pub const TCG_BSWAP_OZ: _bindgen_ty_54 = 2;
pub const TCG_BSWAP_OS: _bindgen_ty_54 = 4;
pub type _bindgen_ty_54 = ::std::os::raw::c_uint;
pub const TEMP_VAL_DEAD: TCGTempVal = 0;
pub const TEMP_VAL_REG: TCGTempVal = 1;
pub const TEMP_VAL_MEM: TCGTempVal = 2;
pub const TEMP_VAL_CONST: TCGTempVal = 3;
pub type TCGTempVal = ::std::os::raw::c_uint;
pub const TEMP_EBB: TCGTempKind = 0;
pub const TEMP_TB: TCGTempKind = 1;
pub const TEMP_GLOBAL: TCGTempKind = 2;
pub const TEMP_FIXED: TCGTempKind = 3;
pub const TEMP_CONST: TCGTempKind = 4;
pub type TCGTempKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGTemp {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub val: i64,
    pub mem_base: *mut TCGTemp,
    pub mem_offset: isize,
    pub name: *const ::std::os::raw::c_char,
    pub state: usize,
    pub state_ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGTemp"][::std::mem::size_of::<TCGTemp>() - 56usize];
    ["Alignment of TCGTemp"][::std::mem::align_of::<TCGTemp>() - 8usize];
    ["Offset of field: TCGTemp::val"][::std::mem::offset_of!(TCGTemp, val) - 8usize];
    ["Offset of field: TCGTemp::mem_base"][::std::mem::offset_of!(TCGTemp, mem_base) - 16usize];
    ["Offset of field: TCGTemp::mem_offset"][::std::mem::offset_of!(TCGTemp, mem_offset) - 24usize];
    ["Offset of field: TCGTemp::name"][::std::mem::offset_of!(TCGTemp, name) - 32usize];
    ["Offset of field: TCGTemp::state"][::std::mem::offset_of!(TCGTemp, state) - 40usize];
    ["Offset of field: TCGTemp::state_ptr"][::std::mem::offset_of!(TCGTemp, state_ptr) - 48usize];
};
impl TCGTemp {
    #[inline]
    pub fn reg(&self) -> TCGReg {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reg(&mut self, val: TCGReg) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reg_raw(this: *const Self) -> TCGReg {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reg_raw(this: *mut Self, val: TCGReg) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn val_type(&self) -> TCGTempVal {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_val_type(&mut self, val: TCGTempVal) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn val_type_raw(this: *const Self) -> TCGTempVal {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_val_type_raw(this: *mut Self, val: TCGTempVal) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn base_type(&self) -> TCGType {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_base_type(&mut self, val: TCGType) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn base_type_raw(this: *const Self) -> TCGType {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_base_type_raw(this: *mut Self, val: TCGType) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> TCGType {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: TCGType) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> TCGType {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: TCGType) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn kind(&self) -> TCGTempKind {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_kind(&mut self, val: TCGTempKind) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn kind_raw(this: *const Self) -> TCGTempKind {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_kind_raw(this: *mut Self, val: TCGTempKind) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn indirect_reg(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_indirect_reg(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn indirect_reg_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                35usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_indirect_reg_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn indirect_base(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_indirect_base(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn indirect_base_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_indirect_base_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mem_coherent(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_coherent(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mem_coherent_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mem_coherent_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mem_allocated(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_allocated(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mem_allocated_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mem_allocated_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn temp_allocated(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temp_allocated(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn temp_allocated_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                39usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_temp_allocated_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                39usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn temp_subindex(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_temp_subindex(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn temp_subindex_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_temp_subindex_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reg: TCGReg,
        val_type: TCGTempVal,
        base_type: TCGType,
        type_: TCGType,
        kind: TCGTempKind,
        indirect_reg: ::std::os::raw::c_uint,
        indirect_base: ::std::os::raw::c_uint,
        mem_coherent: ::std::os::raw::c_uint,
        mem_allocated: ::std::os::raw::c_uint,
        temp_allocated: ::std::os::raw::c_uint,
        temp_subindex: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reg: u32 = unsafe { ::std::mem::transmute(reg) };
            reg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let val_type: u32 = unsafe { ::std::mem::transmute(val_type) };
            val_type as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let base_type: u32 = unsafe { ::std::mem::transmute(base_type) };
            base_type as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(32usize, 3u8, {
            let kind: u32 = unsafe { ::std::mem::transmute(kind) };
            kind as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let indirect_reg: u32 = unsafe { ::std::mem::transmute(indirect_reg) };
            indirect_reg as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let indirect_base: u32 = unsafe { ::std::mem::transmute(indirect_base) };
            indirect_base as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let mem_coherent: u32 = unsafe { ::std::mem::transmute(mem_coherent) };
            mem_coherent as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let mem_allocated: u32 = unsafe { ::std::mem::transmute(mem_allocated) };
            mem_allocated as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let temp_allocated: u32 = unsafe { ::std::mem::transmute(temp_allocated) };
            temp_allocated as u64
        });
        __bindgen_bitfield_unit.set(40usize, 2u8, {
            let temp_subindex: u32 = unsafe { ::std::mem::transmute(temp_subindex) };
            temp_subindex as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGTempSet {
    pub l: [::std::os::raw::c_ulong; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGTempSet"][::std::mem::size_of::<TCGTempSet>() - 64usize];
    ["Alignment of TCGTempSet"][::std::mem::align_of::<TCGTempSet>() - 8usize];
    ["Offset of field: TCGTempSet::l"][::std::mem::offset_of!(TCGTempSet, l) - 0usize];
};
pub type TCGLifeData = u32;
#[repr(C)]
pub struct TCGOp {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub life: TCGLifeData,
    pub link: TCGOp__bindgen_ty_1,
    pub output_pref: [TCGRegSet; 2usize],
    pub args: __IncompleteArrayField<TCGArg>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCGOp__bindgen_ty_1 {
    pub tqe_next: *mut TCGOp,
    pub tqe_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGOp__bindgen_ty_1"][::std::mem::size_of::<TCGOp__bindgen_ty_1>() - 16usize];
    ["Alignment of TCGOp__bindgen_ty_1"][::std::mem::align_of::<TCGOp__bindgen_ty_1>() - 8usize];
    ["Offset of field: TCGOp__bindgen_ty_1::tqe_next"]
        [::std::mem::offset_of!(TCGOp__bindgen_ty_1, tqe_next) - 0usize];
    ["Offset of field: TCGOp__bindgen_ty_1::tqe_circ"]
        [::std::mem::offset_of!(TCGOp__bindgen_ty_1, tqe_circ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGOp"][::std::mem::size_of::<TCGOp>() - 32usize];
    ["Alignment of TCGOp"][::std::mem::align_of::<TCGOp>() - 8usize];
    ["Offset of field: TCGOp::life"][::std::mem::offset_of!(TCGOp, life) - 4usize];
    ["Offset of field: TCGOp::link"][::std::mem::offset_of!(TCGOp, link) - 8usize];
    ["Offset of field: TCGOp::output_pref"][::std::mem::offset_of!(TCGOp, output_pref) - 24usize];
    ["Offset of field: TCGOp::args"][::std::mem::offset_of!(TCGOp, args) - 32usize];
};
impl TCGOp {
    #[inline]
    pub fn opc(&self) -> TCGOpcode {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_opc(&mut self, val: TCGOpcode) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn opc_raw(this: *const Self) -> TCGOpcode {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_opc_raw(this: *mut Self, val: TCGOpcode) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nargs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_nargs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nargs_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_nargs_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn param1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_param1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn param1_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_param1_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn param2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_param2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn param2_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_param2_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        opc: TCGOpcode,
        nargs: ::std::os::raw::c_uint,
        param1: ::std::os::raw::c_uint,
        param2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let opc: u32 = unsafe { ::std::mem::transmute(opc) };
            opc as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let nargs: u32 = unsafe { ::std::mem::transmute(nargs) };
            nargs as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let param1: u32 = unsafe { ::std::mem::transmute(param1) };
            param1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let param2: u32 = unsafe { ::std::mem::transmute(param2) };
            param2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TCGContext {
    pub pool_cur: *mut u8,
    pub pool_end: *mut u8,
    pub pool_first: *mut TCGPool,
    pub pool_current: *mut TCGPool,
    pub pool_first_large: *mut TCGPool,
    pub nb_labels: ::std::os::raw::c_int,
    pub nb_globals: ::std::os::raw::c_int,
    pub nb_temps: ::std::os::raw::c_int,
    pub nb_indirects: ::std::os::raw::c_int,
    pub nb_ops: ::std::os::raw::c_int,
    pub addr_type: TCGType,
    pub page_mask: ::std::os::raw::c_int,
    pub page_bits: u8,
    pub tlb_dyn_max_bits: u8,
    pub insn_start_words: u8,
    pub guest_mo: TCGBar,
    pub reserved_regs: TCGRegSet,
    pub current_frame_offset: isize,
    pub frame_start: isize,
    pub frame_end: isize,
    pub frame_temp: *mut TCGTemp,
    pub gen_tb: *mut TranslationBlock,
    pub code_buf: *mut tcg_insn_unit,
    pub code_ptr: *mut tcg_insn_unit,
    pub code_gen_buffer: *mut ::std::os::raw::c_void,
    pub code_gen_buffer_size: usize,
    pub code_gen_ptr: *mut ::std::os::raw::c_void,
    pub data_gen_ptr: *mut ::std::os::raw::c_void,
    pub code_gen_highwater: *mut ::std::os::raw::c_void,
    pub cpu: *mut CPUState,
    pub ldst_labels: TCGContext__bindgen_ty_1,
    pub pool_labels: *mut TCGLabelPoolData,
    pub exitreq_label: *mut TCGLabel,
    pub plugin_tb: *mut qemu_plugin_tb,
    pub plugin_db: *const DisasContextBase,
    pub plugin_insn: *mut qemu_plugin_insn,
    pub const_table: [*mut GHashTable; 6usize],
    pub free_temps: [TCGTempSet; 6usize],
    pub temps: [TCGTemp; 512usize],
    pub ops: TCGContext__bindgen_ty_2,
    pub free_ops: TCGContext__bindgen_ty_2,
    pub labels: TCGContext__bindgen_ty_3,
    pub emit_before_op: *mut TCGOp,
    pub reg_to_temp: [*mut TCGTemp; 32usize],
    pub gen_insn_end_off: [u16; 512usize],
    pub gen_insn_data: *mut u64,
    pub jmp_trans: sigjmp_buf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGContext__bindgen_ty_1 {
    pub sqh_first: *mut TCGLabelQemuLdst,
    pub sqh_last: *mut *mut TCGLabelQemuLdst,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGContext__bindgen_ty_1"]
        [::std::mem::size_of::<TCGContext__bindgen_ty_1>() - 16usize];
    ["Alignment of TCGContext__bindgen_ty_1"]
        [::std::mem::align_of::<TCGContext__bindgen_ty_1>() - 8usize];
    ["Offset of field: TCGContext__bindgen_ty_1::sqh_first"]
        [::std::mem::offset_of!(TCGContext__bindgen_ty_1, sqh_first) - 0usize];
    ["Offset of field: TCGContext__bindgen_ty_1::sqh_last"]
        [::std::mem::offset_of!(TCGContext__bindgen_ty_1, sqh_last) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCGContext__bindgen_ty_2 {
    pub tqh_first: *mut TCGOp,
    pub tqh_circ: QTailQLink,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGContext__bindgen_ty_2"]
        [::std::mem::size_of::<TCGContext__bindgen_ty_2>() - 16usize];
    ["Alignment of TCGContext__bindgen_ty_2"]
        [::std::mem::align_of::<TCGContext__bindgen_ty_2>() - 8usize];
    ["Offset of field: TCGContext__bindgen_ty_2::tqh_first"]
        [::std::mem::offset_of!(TCGContext__bindgen_ty_2, tqh_first) - 0usize];
    ["Offset of field: TCGContext__bindgen_ty_2::tqh_circ"]
        [::std::mem::offset_of!(TCGContext__bindgen_ty_2, tqh_circ) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGContext__bindgen_ty_3 {
    pub sqh_first: *mut TCGLabel,
    pub sqh_last: *mut *mut TCGLabel,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGContext__bindgen_ty_3"]
        [::std::mem::size_of::<TCGContext__bindgen_ty_3>() - 16usize];
    ["Alignment of TCGContext__bindgen_ty_3"]
        [::std::mem::align_of::<TCGContext__bindgen_ty_3>() - 8usize];
    ["Offset of field: TCGContext__bindgen_ty_3::sqh_first"]
        [::std::mem::offset_of!(TCGContext__bindgen_ty_3, sqh_first) - 0usize];
    ["Offset of field: TCGContext__bindgen_ty_3::sqh_last"]
        [::std::mem::offset_of!(TCGContext__bindgen_ty_3, sqh_last) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGContext"][::std::mem::size_of::<TCGContext>() - 30888usize];
    ["Alignment of TCGContext"][::std::mem::align_of::<TCGContext>() - 8usize];
    ["Offset of field: TCGContext::pool_cur"]
        [::std::mem::offset_of!(TCGContext, pool_cur) - 0usize];
    ["Offset of field: TCGContext::pool_end"]
        [::std::mem::offset_of!(TCGContext, pool_end) - 8usize];
    ["Offset of field: TCGContext::pool_first"]
        [::std::mem::offset_of!(TCGContext, pool_first) - 16usize];
    ["Offset of field: TCGContext::pool_current"]
        [::std::mem::offset_of!(TCGContext, pool_current) - 24usize];
    ["Offset of field: TCGContext::pool_first_large"]
        [::std::mem::offset_of!(TCGContext, pool_first_large) - 32usize];
    ["Offset of field: TCGContext::nb_labels"]
        [::std::mem::offset_of!(TCGContext, nb_labels) - 40usize];
    ["Offset of field: TCGContext::nb_globals"]
        [::std::mem::offset_of!(TCGContext, nb_globals) - 44usize];
    ["Offset of field: TCGContext::nb_temps"]
        [::std::mem::offset_of!(TCGContext, nb_temps) - 48usize];
    ["Offset of field: TCGContext::nb_indirects"]
        [::std::mem::offset_of!(TCGContext, nb_indirects) - 52usize];
    ["Offset of field: TCGContext::nb_ops"][::std::mem::offset_of!(TCGContext, nb_ops) - 56usize];
    ["Offset of field: TCGContext::addr_type"]
        [::std::mem::offset_of!(TCGContext, addr_type) - 60usize];
    ["Offset of field: TCGContext::page_mask"]
        [::std::mem::offset_of!(TCGContext, page_mask) - 64usize];
    ["Offset of field: TCGContext::page_bits"]
        [::std::mem::offset_of!(TCGContext, page_bits) - 68usize];
    ["Offset of field: TCGContext::tlb_dyn_max_bits"]
        [::std::mem::offset_of!(TCGContext, tlb_dyn_max_bits) - 69usize];
    ["Offset of field: TCGContext::insn_start_words"]
        [::std::mem::offset_of!(TCGContext, insn_start_words) - 70usize];
    ["Offset of field: TCGContext::guest_mo"]
        [::std::mem::offset_of!(TCGContext, guest_mo) - 72usize];
    ["Offset of field: TCGContext::reserved_regs"]
        [::std::mem::offset_of!(TCGContext, reserved_regs) - 76usize];
    ["Offset of field: TCGContext::current_frame_offset"]
        [::std::mem::offset_of!(TCGContext, current_frame_offset) - 80usize];
    ["Offset of field: TCGContext::frame_start"]
        [::std::mem::offset_of!(TCGContext, frame_start) - 88usize];
    ["Offset of field: TCGContext::frame_end"]
        [::std::mem::offset_of!(TCGContext, frame_end) - 96usize];
    ["Offset of field: TCGContext::frame_temp"]
        [::std::mem::offset_of!(TCGContext, frame_temp) - 104usize];
    ["Offset of field: TCGContext::gen_tb"][::std::mem::offset_of!(TCGContext, gen_tb) - 112usize];
    ["Offset of field: TCGContext::code_buf"]
        [::std::mem::offset_of!(TCGContext, code_buf) - 120usize];
    ["Offset of field: TCGContext::code_ptr"]
        [::std::mem::offset_of!(TCGContext, code_ptr) - 128usize];
    ["Offset of field: TCGContext::code_gen_buffer"]
        [::std::mem::offset_of!(TCGContext, code_gen_buffer) - 136usize];
    ["Offset of field: TCGContext::code_gen_buffer_size"]
        [::std::mem::offset_of!(TCGContext, code_gen_buffer_size) - 144usize];
    ["Offset of field: TCGContext::code_gen_ptr"]
        [::std::mem::offset_of!(TCGContext, code_gen_ptr) - 152usize];
    ["Offset of field: TCGContext::data_gen_ptr"]
        [::std::mem::offset_of!(TCGContext, data_gen_ptr) - 160usize];
    ["Offset of field: TCGContext::code_gen_highwater"]
        [::std::mem::offset_of!(TCGContext, code_gen_highwater) - 168usize];
    ["Offset of field: TCGContext::cpu"][::std::mem::offset_of!(TCGContext, cpu) - 176usize];
    ["Offset of field: TCGContext::ldst_labels"]
        [::std::mem::offset_of!(TCGContext, ldst_labels) - 184usize];
    ["Offset of field: TCGContext::pool_labels"]
        [::std::mem::offset_of!(TCGContext, pool_labels) - 200usize];
    ["Offset of field: TCGContext::exitreq_label"]
        [::std::mem::offset_of!(TCGContext, exitreq_label) - 208usize];
    ["Offset of field: TCGContext::plugin_tb"]
        [::std::mem::offset_of!(TCGContext, plugin_tb) - 216usize];
    ["Offset of field: TCGContext::plugin_db"]
        [::std::mem::offset_of!(TCGContext, plugin_db) - 224usize];
    ["Offset of field: TCGContext::plugin_insn"]
        [::std::mem::offset_of!(TCGContext, plugin_insn) - 232usize];
    ["Offset of field: TCGContext::const_table"]
        [::std::mem::offset_of!(TCGContext, const_table) - 240usize];
    ["Offset of field: TCGContext::free_temps"]
        [::std::mem::offset_of!(TCGContext, free_temps) - 288usize];
    ["Offset of field: TCGContext::temps"][::std::mem::offset_of!(TCGContext, temps) - 672usize];
    ["Offset of field: TCGContext::ops"][::std::mem::offset_of!(TCGContext, ops) - 29344usize];
    ["Offset of field: TCGContext::free_ops"]
        [::std::mem::offset_of!(TCGContext, free_ops) - 29360usize];
    ["Offset of field: TCGContext::labels"]
        [::std::mem::offset_of!(TCGContext, labels) - 29376usize];
    ["Offset of field: TCGContext::emit_before_op"]
        [::std::mem::offset_of!(TCGContext, emit_before_op) - 29392usize];
    ["Offset of field: TCGContext::reg_to_temp"]
        [::std::mem::offset_of!(TCGContext, reg_to_temp) - 29400usize];
    ["Offset of field: TCGContext::gen_insn_end_off"]
        [::std::mem::offset_of!(TCGContext, gen_insn_end_off) - 29656usize];
    ["Offset of field: TCGContext::gen_insn_data"]
        [::std::mem::offset_of!(TCGContext, gen_insn_data) - 30680usize];
    ["Offset of field: TCGContext::jmp_trans"]
        [::std::mem::offset_of!(TCGContext, jmp_trans) - 30688usize];
};
unsafe extern "C" {
    pub static mut tcg_ctx: *mut TCGContext;
}
unsafe extern "C" {
    pub static mut tcg_code_gen_epilogue: *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub static mut tcg_splitwx_diff: usize;
}
unsafe extern "C" {
    pub static mut tcg_env: TCGv_env;
}
unsafe extern "C" {
    pub fn in_code_gen_buffer(p: *const ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    pub fn tcg_malloc_internal(
        s: *mut TCGContext,
        size: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn tcg_pool_reset(s: *mut TCGContext);
}
unsafe extern "C" {
    pub fn tcg_tb_alloc(s: *mut TCGContext) -> *mut TranslationBlock;
}
unsafe extern "C" {
    pub fn tcg_region_reset_all();
}
unsafe extern "C" {
    pub fn tcg_code_size() -> usize;
}
unsafe extern "C" {
    pub fn tcg_code_capacity() -> usize;
}
unsafe extern "C" {
    pub fn tcg_tb_insert(tb: *mut TranslationBlock);
}
unsafe extern "C" {
    pub fn tcg_tb_remove(tb: *mut TranslationBlock);
}
unsafe extern "C" {
    pub fn tcg_tb_lookup(tc_ptr: usize) -> *mut TranslationBlock;
}
unsafe extern "C" {
    pub fn tcg_tb_foreach(func: GTraverseFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn tcg_nb_tbs() -> usize;
}
unsafe extern "C" {
    pub fn tcg_func_start(s: *mut TCGContext);
}
unsafe extern "C" {
    pub fn tcg_gen_code(
        s: *mut TCGContext,
        tb: *mut TranslationBlock,
        pc_start: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tb_target_set_jmp_target(
        arg1: *const TranslationBlock,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: usize,
    );
}
unsafe extern "C" {
    pub fn tcg_set_frame(s: *mut TCGContext, reg: TCGReg, start: isize, size: isize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGArgConstraint {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub regs: TCGRegSet,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGArgConstraint"][::std::mem::size_of::<TCGArgConstraint>() - 12usize];
    ["Alignment of TCGArgConstraint"][::std::mem::align_of::<TCGArgConstraint>() - 4usize];
    ["Offset of field: TCGArgConstraint::regs"]
        [::std::mem::offset_of!(TCGArgConstraint, regs) - 8usize];
};
impl TCGArgConstraint {
    #[inline]
    pub fn ct(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_ct(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ct_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ct_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn alias_index(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_alias_index(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn alias_index_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_alias_index_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sort_index(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sort_index(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sort_index_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sort_index_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pair_index(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_pair_index(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pair_index_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pair_index_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pair(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pair(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pair_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pair_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn oalias(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_oalias(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn oalias_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_oalias_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ialias(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ialias(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ialias_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ialias_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn newreg(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_newreg(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn newreg_raw(this: *const Self) -> bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 5usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_newreg_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 5usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ct: ::std::os::raw::c_uint,
        alias_index: ::std::os::raw::c_uint,
        sort_index: ::std::os::raw::c_uint,
        pair_index: ::std::os::raw::c_uint,
        pair: ::std::os::raw::c_uint,
        oalias: bool,
        ialias: bool,
        newreg: bool,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let ct: u32 = unsafe { ::std::mem::transmute(ct) };
            ct as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let alias_index: u32 = unsafe { ::std::mem::transmute(alias_index) };
            alias_index as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let sort_index: u32 = unsafe { ::std::mem::transmute(sort_index) };
            sort_index as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let pair_index: u32 = unsafe { ::std::mem::transmute(pair_index) };
            pair_index as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let pair: u32 = unsafe { ::std::mem::transmute(pair) };
            pair as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let oalias: u8 = unsafe { ::std::mem::transmute(oalias) };
            oalias as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ialias: u8 = unsafe { ::std::mem::transmute(ialias) };
            ialias as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let newreg: u8 = unsafe { ::std::mem::transmute(newreg) };
            newreg as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const TCG_OPF_BB_EXIT: _bindgen_ty_55 = 1;
pub const TCG_OPF_BB_END: _bindgen_ty_55 = 2;
pub const TCG_OPF_CALL_CLOBBER: _bindgen_ty_55 = 4;
pub const TCG_OPF_SIDE_EFFECTS: _bindgen_ty_55 = 8;
pub const TCG_OPF_NOT_PRESENT: _bindgen_ty_55 = 32;
pub const TCG_OPF_VECTOR: _bindgen_ty_55 = 64;
pub const TCG_OPF_COND_BRANCH: _bindgen_ty_55 = 128;
pub type _bindgen_ty_55 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGOpDef {
    pub name: *const ::std::os::raw::c_char,
    pub nb_oargs: u8,
    pub nb_iargs: u8,
    pub nb_cargs: u8,
    pub nb_args: u8,
    pub flags: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TCGOpDef"][::std::mem::size_of::<TCGOpDef>() - 16usize];
    ["Alignment of TCGOpDef"][::std::mem::align_of::<TCGOpDef>() - 8usize];
    ["Offset of field: TCGOpDef::name"][::std::mem::offset_of!(TCGOpDef, name) - 0usize];
    ["Offset of field: TCGOpDef::nb_oargs"][::std::mem::offset_of!(TCGOpDef, nb_oargs) - 8usize];
    ["Offset of field: TCGOpDef::nb_iargs"][::std::mem::offset_of!(TCGOpDef, nb_iargs) - 9usize];
    ["Offset of field: TCGOpDef::nb_cargs"][::std::mem::offset_of!(TCGOpDef, nb_cargs) - 10usize];
    ["Offset of field: TCGOpDef::nb_args"][::std::mem::offset_of!(TCGOpDef, nb_args) - 11usize];
    ["Offset of field: TCGOpDef::flags"][::std::mem::offset_of!(TCGOpDef, flags) - 12usize];
};
unsafe extern "C" {
    pub static tcg_op_defs: [TCGOpDef; 0usize];
}
unsafe extern "C" {
    pub static tcg_op_defs_max: usize;
}
unsafe extern "C" {
    pub fn tcg_op_supported(op: TCGOpcode, type_: TCGType, flags: ::std::os::raw::c_uint) -> bool;
}
unsafe extern "C" {
    pub fn tcg_op_deposit_valid(
        type_: TCGType,
        ofs: ::std::os::raw::c_uint,
        len: ::std::os::raw::c_uint,
    ) -> bool;
}
unsafe extern "C" {
    pub fn tcg_gen_call0(
        func: *mut ::std::os::raw::c_void,
        arg1: *mut TCGHelperInfo,
        ret: *mut TCGTemp,
    );
}
unsafe extern "C" {
    pub fn tcg_gen_call1(
        func: *mut ::std::os::raw::c_void,
        arg1: *mut TCGHelperInfo,
        ret: *mut TCGTemp,
        arg2: *mut TCGTemp,
    );
}
unsafe extern "C" {
    pub fn tcg_gen_call2(
        func: *mut ::std::os::raw::c_void,
        arg1: *mut TCGHelperInfo,
        ret: *mut TCGTemp,
        arg2: *mut TCGTemp,
        arg3: *mut TCGTemp,
    );
}
unsafe extern "C" {
    pub fn tcg_gen_call3(
        func: *mut ::std::os::raw::c_void,
        arg1: *mut TCGHelperInfo,
        ret: *mut TCGTemp,
        arg2: *mut TCGTemp,
        arg3: *mut TCGTemp,
        arg4: *mut TCGTemp,
    );
}
unsafe extern "C" {
    pub fn tcg_gen_call4(
        func: *mut ::std::os::raw::c_void,
        arg1: *mut TCGHelperInfo,
        ret: *mut TCGTemp,
        arg2: *mut TCGTemp,
        arg3: *mut TCGTemp,
        arg4: *mut TCGTemp,
        arg5: *mut TCGTemp,
    );
}
unsafe extern "C" {
    pub fn tcg_gen_call5(
        func: *mut ::std::os::raw::c_void,
        arg1: *mut TCGHelperInfo,
        ret: *mut TCGTemp,
        arg2: *mut TCGTemp,
        arg3: *mut TCGTemp,
        arg4: *mut TCGTemp,
        arg5: *mut TCGTemp,
        arg6: *mut TCGTemp,
    );
}
unsafe extern "C" {
    pub fn tcg_gen_call6(
        func: *mut ::std::os::raw::c_void,
        arg1: *mut TCGHelperInfo,
        ret: *mut TCGTemp,
        arg2: *mut TCGTemp,
        arg3: *mut TCGTemp,
        arg4: *mut TCGTemp,
        arg5: *mut TCGTemp,
        arg6: *mut TCGTemp,
        arg7: *mut TCGTemp,
    );
}
unsafe extern "C" {
    pub fn tcg_gen_call7(
        func: *mut ::std::os::raw::c_void,
        arg1: *mut TCGHelperInfo,
        ret: *mut TCGTemp,
        arg2: *mut TCGTemp,
        arg3: *mut TCGTemp,
        arg4: *mut TCGTemp,
        arg5: *mut TCGTemp,
        arg6: *mut TCGTemp,
        arg7: *mut TCGTemp,
        arg8: *mut TCGTemp,
    );
}
unsafe extern "C" {
    pub fn tcg_emit_op(opc: TCGOpcode, nargs: ::std::os::raw::c_uint) -> *mut TCGOp;
}
unsafe extern "C" {
    pub fn tcg_op_remove(s: *mut TCGContext, op: *mut TCGOp);
}
unsafe extern "C" {
    pub fn tcg_remove_ops_after(op: *mut TCGOp);
}
unsafe extern "C" {
    pub fn tcg_optimize(s: *mut TCGContext);
}
unsafe extern "C" {
    pub fn gen_new_label() -> *mut TCGLabel;
}
pub type tcg_prologue_fn = ::std::option::Option<
    unsafe extern "C" fn(env: *mut CPUArchState, tb_ptr: *const ::std::os::raw::c_void) -> usize,
>;
unsafe extern "C" {
    pub static mut tcg_qemu_tb_exec: tcg_prologue_fn;
}
unsafe extern "C" {
    pub fn tcg_register_jit(buf: *const ::std::os::raw::c_void, buf_size: usize);
}
unsafe extern "C" {
    pub fn tcg_can_emit_vec_op(
        arg1: TCGOpcode,
        arg2: TCGType,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tcg_expand_vec_op(
        arg1: TCGOpcode,
        arg2: TCGType,
        arg3: ::std::os::raw::c_uint,
        arg4: TCGArg,
        ...
    );
}
unsafe extern "C" {
    pub fn dup_const(vece: ::std::os::raw::c_uint, c: u64) -> u64;
}
unsafe extern "C" {
    pub fn tcg_can_emit_vecop_list(
        arg1: *const TCGOpcode,
        arg2: TCGType,
        arg3: ::std::os::raw::c_uint,
    ) -> bool;
}
unsafe extern "C" {
    pub fn tcg_dump_ops(s: *mut TCGContext, f: *mut FILE, have_prefs: bool);
}
unsafe extern "C" {
    pub fn disas(out: *mut FILE, code: *const ::std::os::raw::c_void, size: usize);
}
unsafe extern "C" {
    pub fn target_disas(out: *mut FILE, cpu: *mut CPUState, db: *const DisasContextBase);
}
unsafe extern "C" {
    pub fn monitor_disas(
        mon: *mut Monitor,
        cpu: *mut CPUState,
        pc: u64,
        nb_insn: ::std::os::raw::c_int,
        is_physical: bool,
    );
}
unsafe extern "C" {
    pub fn plugin_disas(
        cpu: *mut CPUState,
        db: *const DisasContextBase,
        addr: u64,
        size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn lookup_symbol(orig_addr: u64) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elf32_sym {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elf64_sym {
    _unused: [u8; 0],
}
pub type lookup_symbol_t = ::std::option::Option<
    unsafe extern "C" fn(s: *mut syminfo, orig_addr: u64) -> *const ::std::os::raw::c_char,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct syminfo {
    pub lookup_symbol: lookup_symbol_t,
    pub disas_num_syms: ::std::os::raw::c_uint,
    pub disas_symtab: syminfo__bindgen_ty_1,
    pub disas_strtab: *const ::std::os::raw::c_char,
    pub next: *mut syminfo,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union syminfo__bindgen_ty_1 {
    pub elf32: *mut elf32_sym,
    pub elf64: *mut elf64_sym,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of syminfo__bindgen_ty_1"][::std::mem::size_of::<syminfo__bindgen_ty_1>() - 8usize];
    ["Alignment of syminfo__bindgen_ty_1"]
        [::std::mem::align_of::<syminfo__bindgen_ty_1>() - 8usize];
    ["Offset of field: syminfo__bindgen_ty_1::elf32"]
        [::std::mem::offset_of!(syminfo__bindgen_ty_1, elf32) - 0usize];
    ["Offset of field: syminfo__bindgen_ty_1::elf64"]
        [::std::mem::offset_of!(syminfo__bindgen_ty_1, elf64) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of syminfo"][::std::mem::size_of::<syminfo>() - 40usize];
    ["Alignment of syminfo"][::std::mem::align_of::<syminfo>() - 8usize];
    ["Offset of field: syminfo::lookup_symbol"]
        [::std::mem::offset_of!(syminfo, lookup_symbol) - 0usize];
    ["Offset of field: syminfo::disas_num_syms"]
        [::std::mem::offset_of!(syminfo, disas_num_syms) - 8usize];
    ["Offset of field: syminfo::disas_symtab"]
        [::std::mem::offset_of!(syminfo, disas_symtab) - 16usize];
    ["Offset of field: syminfo::disas_strtab"]
        [::std::mem::offset_of!(syminfo, disas_strtab) - 24usize];
    ["Offset of field: syminfo::next"][::std::mem::offset_of!(syminfo, next) - 32usize];
};
unsafe extern "C" {
    pub static mut syminfos: *mut syminfo;
}
pub type panda_cb_list = _panda_cb_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _panda_cb_list {
    pub entry: panda_cb_with_context,
    pub owner: *mut ::std::os::raw::c_void,
    pub next: *mut panda_cb_list,
    pub prev: *mut panda_cb_list,
    pub enabled: bool,
    pub context: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _panda_cb_list"][::std::mem::size_of::<_panda_cb_list>() - 48usize];
    ["Alignment of _panda_cb_list"][::std::mem::align_of::<_panda_cb_list>() - 8usize];
    ["Offset of field: _panda_cb_list::entry"]
        [::std::mem::offset_of!(_panda_cb_list, entry) - 0usize];
    ["Offset of field: _panda_cb_list::owner"]
        [::std::mem::offset_of!(_panda_cb_list, owner) - 8usize];
    ["Offset of field: _panda_cb_list::next"]
        [::std::mem::offset_of!(_panda_cb_list, next) - 16usize];
    ["Offset of field: _panda_cb_list::prev"]
        [::std::mem::offset_of!(_panda_cb_list, prev) - 24usize];
    ["Offset of field: _panda_cb_list::enabled"]
        [::std::mem::offset_of!(_panda_cb_list, enabled) - 32usize];
    ["Offset of field: _panda_cb_list::context"]
        [::std::mem::offset_of!(_panda_cb_list, context) - 40usize];
};
unsafe extern "C" {
    pub fn panda_cb_list_next(plist: *mut panda_cb_list) -> *mut panda_cb_list;
}
unsafe extern "C" {
    pub fn panda_enable_plugin(plugin: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn panda_disable_plugin(plugin: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct panda_plugin {
    pub name: *mut ::std::os::raw::c_char,
    pub plugin: *mut ::std::os::raw::c_void,
    pub unload: bool,
    pub exported_symbols: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of panda_plugin"][::std::mem::size_of::<panda_plugin>() - 24usize];
    ["Alignment of panda_plugin"][::std::mem::align_of::<panda_plugin>() - 8usize];
    ["Offset of field: panda_plugin::name"][::std::mem::offset_of!(panda_plugin, name) - 0usize];
    ["Offset of field: panda_plugin::plugin"]
        [::std::mem::offset_of!(panda_plugin, plugin) - 8usize];
    ["Offset of field: panda_plugin::unload"]
        [::std::mem::offset_of!(panda_plugin, unload) - 16usize];
    ["Offset of field: panda_plugin::exported_symbols"]
        [::std::mem::offset_of!(panda_plugin, exported_symbols) - 17usize];
};
unsafe extern "C" {
    pub fn panda_get_cb_trampoline(type_: panda_cb_type) -> panda_cb_with_context;
}
unsafe extern "C" {
    pub fn panda_register_callback(
        plugin: *mut ::std::os::raw::c_void,
        type_: panda_cb_type,
        cb: panda_cb,
    );
}
unsafe extern "C" {
    pub fn panda_register_callback_with_context(
        plugin: *mut ::std::os::raw::c_void,
        type_: panda_cb_type,
        cb: panda_cb_with_context,
        context: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn panda_disable_callback(
        plugin: *mut ::std::os::raw::c_void,
        type_: panda_cb_type,
        cb: panda_cb,
    );
}
unsafe extern "C" {
    pub fn panda_disable_callback_with_context(
        plugin: *mut ::std::os::raw::c_void,
        type_: panda_cb_type,
        cb: panda_cb_with_context,
        context: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn panda_enable_callback(
        plugin: *mut ::std::os::raw::c_void,
        type_: panda_cb_type,
        cb: panda_cb,
    );
}
unsafe extern "C" {
    pub fn panda_enable_callback_with_context(
        plugin: *mut ::std::os::raw::c_void,
        type_: panda_cb_type,
        cb: panda_cb_with_context,
        context: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn panda_unregister_callbacks(plugin: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn panda_load_plugin(
        filename: *const ::std::os::raw::c_char,
        plugin_name: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn panda_add_arg(
        plugin_name: *const ::std::os::raw::c_char,
        plugin_arg: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn panda_get_plugin_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn panda_unload_plugin_by_name(name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn panda_do_unload_plugin(index: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn panda_unload_plugin(plugin: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn panda_unload_plugin_idx(idx: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn panda_unload_plugins();
}
unsafe extern "C" {
    pub static mut panda_update_pc: bool;
}
unsafe extern "C" {
    pub static mut panda_use_memcb: bool;
}
unsafe extern "C" {
    pub static mut panda_cbs: [*mut panda_cb_list; 52usize];
}
unsafe extern "C" {
    pub static mut panda_tb_chaining: bool;
}
pub const OS_UNKNOWN: OSFamilyEnum = 0;
pub const OS_WINDOWS: OSFamilyEnum = 1;
pub const OS_LINUX: OSFamilyEnum = 2;
pub const OS_FREEBSD: OSFamilyEnum = 3;
pub type OSFamilyEnum = ::std::os::raw::c_uint;
pub use self::OSFamilyEnum as PandaOsFamily;
unsafe extern "C" {
    pub static mut panda_os_name: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut panda_os_family: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut panda_os_variant: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut panda_os_bits: u32;
}
unsafe extern "C" {
    pub static mut panda_os_familyno: PandaOsFamily;
}
unsafe extern "C" {
    pub fn panda_break_exec() -> bool;
}
unsafe extern "C" {
    pub fn panda_flush_tb() -> bool;
}
unsafe extern "C" {
    pub fn panda_do_flush_tb();
}
unsafe extern "C" {
    pub fn panda_do_break_exec();
}
unsafe extern "C" {
    pub fn panda_enable_precise_pc();
}
unsafe extern "C" {
    pub fn panda_disable_precise_pc();
}
unsafe extern "C" {
    pub fn panda_enable_memcb();
}
unsafe extern "C" {
    pub fn panda_disable_memcb();
}
unsafe extern "C" {
    pub fn panda_enable_llvm();
}
unsafe extern "C" {
    pub fn panda_enable_llvm_no_exec();
}
unsafe extern "C" {
    pub fn panda_disable_llvm();
}
unsafe extern "C" {
    pub fn panda_enable_llvm_helpers();
}
unsafe extern "C" {
    pub fn panda_disable_llvm_helpers();
}
unsafe extern "C" {
    pub fn panda_write_current_llvm_bitcode_to_file(
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_get_current_llvm_module() -> usize;
}
unsafe extern "C" {
    pub fn panda_disable_tb_chaining();
}
unsafe extern "C" {
    pub fn panda_enable_tb_chaining();
}
unsafe extern "C" {
    pub fn panda_memsavep(file: *mut FILE);
}
unsafe extern "C" {
    pub fn panda_vm_quit() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_get_rr_name() -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct panda_arg {
    pub argptr: *mut ::std::os::raw::c_char,
    pub key: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of panda_arg"][::std::mem::size_of::<panda_arg>() - 24usize];
    ["Alignment of panda_arg"][::std::mem::align_of::<panda_arg>() - 8usize];
    ["Offset of field: panda_arg::argptr"][::std::mem::offset_of!(panda_arg, argptr) - 0usize];
    ["Offset of field: panda_arg::key"][::std::mem::offset_of!(panda_arg, key) - 8usize];
    ["Offset of field: panda_arg::value"][::std::mem::offset_of!(panda_arg, value) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct panda_arg_list {
    pub nargs: ::std::os::raw::c_int,
    pub list: *mut panda_arg,
    pub plugin_name: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of panda_arg_list"][::std::mem::size_of::<panda_arg_list>() - 24usize];
    ["Alignment of panda_arg_list"][::std::mem::align_of::<panda_arg_list>() - 8usize];
    ["Offset of field: panda_arg_list::nargs"]
        [::std::mem::offset_of!(panda_arg_list, nargs) - 0usize];
    ["Offset of field: panda_arg_list::list"]
        [::std::mem::offset_of!(panda_arg_list, list) - 8usize];
    ["Offset of field: panda_arg_list::plugin_name"]
        [::std::mem::offset_of!(panda_arg_list, plugin_name) - 16usize];
};
unsafe extern "C" {
    pub fn panda_get_args(plugin_name: *const ::std::os::raw::c_char) -> *mut panda_arg_list;
}
unsafe extern "C" {
    pub fn panda_free_args(args: *mut panda_arg_list);
}
unsafe extern "C" {
    pub fn panda_parse_ulong(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        defval: target_ulong,
    ) -> target_ulong;
}
unsafe extern "C" {
    pub fn panda_parse_ulong_req(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        help: *const ::std::os::raw::c_char,
    ) -> target_ulong;
}
unsafe extern "C" {
    pub fn panda_parse_ulong_opt(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        defval: target_ulong,
        help: *const ::std::os::raw::c_char,
    ) -> target_ulong;
}
unsafe extern "C" {
    pub fn panda_parse_uint32(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        defval: u32,
    ) -> u32;
}
unsafe extern "C" {
    pub fn panda_parse_uint32_req(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        help: *const ::std::os::raw::c_char,
    ) -> u32;
}
unsafe extern "C" {
    pub fn panda_parse_uint32_opt(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        defval: u32,
        help: *const ::std::os::raw::c_char,
    ) -> u32;
}
unsafe extern "C" {
    pub fn panda_parse_uint64(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        defval: u64,
    ) -> u64;
}
unsafe extern "C" {
    pub fn panda_parse_uint64_req(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        help: *const ::std::os::raw::c_char,
    ) -> u64;
}
unsafe extern "C" {
    pub fn panda_parse_uint64_opt(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        defval: u64,
        help: *const ::std::os::raw::c_char,
    ) -> u64;
}
unsafe extern "C" {
    pub fn panda_parse_double(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        defval: f64,
    ) -> f64;
}
unsafe extern "C" {
    pub fn panda_parse_double_req(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        help: *const ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn panda_parse_double_opt(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        defval: f64,
        help: *const ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn panda_parse_bool(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn panda_parse_bool_req(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        help: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn panda_parse_bool_opt(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        help: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn panda_parse_string(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        defval: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn panda_parse_string_req(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        help: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn panda_parse_string_opt(
        args: *mut panda_arg_list,
        argname: *const ::std::os::raw::c_char,
        defval: *const ::std::os::raw::c_char,
        help: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut panda_argv: [*mut gchar; 32usize];
}
unsafe extern "C" {
    pub static mut panda_argc: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn str_split(
        a_str: *mut ::std::os::raw::c_char,
        a_delim: ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn resolve_file_from_plugin_directory(
        file_name_fmt: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn panda_plugin_path(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn panda_shared_library_path(
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn panda_require(name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn panda_require_from_library(
        plugin_name: *const ::std::os::raw::c_char,
        plugin_args: *mut *mut ::std::os::raw::c_char,
        num_args: u32,
    );
}
unsafe extern "C" {
    pub fn panda_is_callback_enabled(
        plugin: *mut ::std::os::raw::c_void,
        type_: panda_cb_type,
        cb: panda_cb,
    ) -> bool;
}
unsafe extern "C" {
    pub fn panda_init(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        envp: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_run() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_stop(code: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn panda_cont();
}
unsafe extern "C" {
    pub fn _panda_set_library_mode(arg1: bool);
}
unsafe extern "C" {
    pub fn panda_start_pandalog(name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn panda_snap(name: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_delvm(name: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_revert(name: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_reset();
}
unsafe extern "C" {
    pub fn panda_finish() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_was_aborted() -> bool;
}
unsafe extern "C" {
    pub fn panda_set_qemu_path(filepath: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn panda_set_extra_plugin_path(filepath: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn panda_init_plugin(
        plugin_name: *mut ::std::os::raw::c_char,
        plugin_args: *mut *mut ::std::os::raw::c_char,
        num_args: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_register_callback_helper(
        plugin: *mut ::std::os::raw::c_void,
        type_: panda_cb_type,
        cb: *mut panda_cb,
    );
}
unsafe extern "C" {
    pub fn panda_enable_callback_helper(
        plugin: *mut ::std::os::raw::c_void,
        type_: panda_cb_type,
        cb: *mut panda_cb,
    );
}
unsafe extern "C" {
    pub fn panda_disable_callback_helper(
        plugin: *mut ::std::os::raw::c_void,
        type_: panda_cb_type,
        cb: *mut panda_cb,
    );
}
unsafe extern "C" {
    pub fn rr_get_guest_instr_count_external() -> u64;
}
unsafe extern "C" {
    pub fn panda_virtual_memory_read_external(
        cpu: *mut CPUState,
        addr: target_ulong,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_virtual_memory_write_external(
        cpu: *mut CPUState,
        addr: target_ulong,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_physical_memory_read_external(
        addr: hwaddr,
        buf: *mut u8,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_physical_memory_write_external(
        addr: hwaddr,
        buf: *mut u8,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn panda_get_retval_external(cpu: *const CPUState) -> target_ulong;
}
unsafe extern "C" {
    pub fn PandaPhysicalAddressToRamOffset_external(
        out: *mut ram_addr_t,
        addr: hwaddr,
        is_write: bool,
    ) -> MemTxResult;
}
unsafe extern "C" {
    pub fn panda_in_kernel_external(cpu: *const CPUState) -> bool;
}
unsafe extern "C" {
    pub fn panda_in_kernel_mode_external(cpu: *const CPUState) -> bool;
}
unsafe extern "C" {
    pub fn panda_in_kernel_code_linux_external(cpu: *mut CPUState) -> bool;
}
unsafe extern "C" {
    pub fn panda_current_ksp_external(cpu: *mut CPUState) -> target_ulong;
}
unsafe extern "C" {
    pub fn panda_current_sp_external(cpu: *const CPUState) -> target_ulong;
}
unsafe extern "C" {
    pub fn panda_current_sp_masked_pagesize_external(
        cpu: *const CPUState,
        pagesize: target_ulong,
    ) -> target_ulong;
}
unsafe extern "C" {
    pub fn panda_virt_to_phys_external(cpu: *mut CPUState, addr: target_ulong) -> target_ulong;
}
unsafe extern "C" {
    pub fn panda_setup_signal_handling(
        sigfun: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: *mut ::std::os::raw::c_void,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
unsafe extern "C" {
    pub fn map_memory(name: *mut ::std::os::raw::c_char, size: u64, address: u64);
}
unsafe extern "C" {
    pub fn panda_init_monitor();
}
unsafe extern "C" {
    pub fn panda_monitor_run(buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn get_cpu() -> *mut CPUState;
}
unsafe extern "C" {
    pub fn panda_cpu_get_index(q: *mut CPUState) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn garray_len(list: *mut GArray) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn panda_cpu_env(cpu: *mut CPUState) -> *mut CPUArchState;
}
unsafe extern "C" {
    pub fn panda_cleanup_record();
}
unsafe extern "C" {
    pub fn panda_cpu_by_index(index: ::std::os::raw::c_int) -> *mut CPUState;
}
unsafe extern "C" {
    pub fn panda_cpu_in_translate() -> *mut CPUState;
}
unsafe extern "C" {
    pub fn panda_get_tb(tb: *mut qemu_plugin_tb) -> *mut TranslationBlock;
}
unsafe extern "C" {
    pub fn panda_get_memcb_status() -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_at {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ax25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_dl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_eon {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_inarp {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ipx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_iso {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ns {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_x25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct link_map {
    pub _address: u8,
}
pub type __int128_t = i128;
pub type Int128Alias___uint128_t = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvm_dirty_gfn {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qht_map {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_cb {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGLabelQemuLdst {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGLabelPoolData {
    pub _address: u8,
}
