from cffi import FFI
from os.path import join, realpath
import re
from glob import glob
from pathlib import Path

plugin_dir = realpath(join(__file__, "../../../plugins"))

def remove_hash_lines(total):
	return "\n".join([x for x in total.split("\n") if x and not x.startswith("#")])

def just_defines(total):
	return "\n".join([x for x in total.split("\n") if x.startswith("#define")])

def ppp_cb_typedef_regex():
	return re.compile(r"PPP_CB_TYPEDEF\( *(void|bool|int) *, *([a-zA-Z0-9_-]+) *, *(.*)\).*")

def typedef(ret_type, name, args):
	return f"typedef {ret_type} (*{name}_t)({args});"

pypanda_start_pattern = """// BEGIN_PYPANDA_NEEDS_THIS -- do not delete this comment bc pypanda
// api autogen needs it.  And don't put any compiler directives
// between this and END_PYPANDA_NEEDS_THIS except includes of other
// files in this directory that contain subsections like this one.
"""

pypanda_end_pattern = "// END_PYPANDA_NEEDS_THIS -- do not delete this comment!\n"

def trim_pypanda(contents):
	'''
	Trim data between pypanda_start_pattern/pypanda_end_pattern
	return None if patterns aren't found
	'''
	a = contents.find(pypanda_start_pattern)
	if a == -1: return None
	a += len(pypanda_start_pattern)
	b = contents.find(pypanda_end_pattern)
	if b == -1: return None
	recurse = None
	if len(contents[b+len(pypanda_end_pattern):]):
		recurse = trim_pypanda(contents[b+len(pypanda_end_pattern):])
	if recurse:
		return contents[a:b]+recurse
	else:
		return contents[a:b]

def copy_ppp_header(filepath):
	# For the PPP-like headers we look for typedefs and then make the void ppp_add_cb(name)(name_t); functions
	# and the bool ppp_remove_cb(name)(name_t)
	# This probably won't support everything
	# pypanda_h = os.path.join(INCLUDE_DIR_PYP, os.path.split(filename)[-1])
	# print("Creating pypanda PPP header [%s] for [%s]" % (pypanda_h, filename))
	new_contents = [f"//Autogenerated PPP header from {filepath}"]
	reg = ppp_cb_typedef_regex()
	contents = open(filepath).read()
	subcontents = trim_pypanda(contents)
	if not subcontents:
		breakpoint()
	for line in subcontents.split("\n"):
		# now add void ppp_add_cb_{cb_name}({cb_name}_t);
		forbidden = ["#ifndef", "#endif"]
		if any(i in line for i in forbidden):
			continue
		m = reg.match(line)
		if m:
			ret_type = m.groups(1)[0]
			name = m.groups(1)[1]
			args = m.groups(1)[2]
			new_contents.append(typedef(ret_type, name, args))
			new_contents.append(f"void ppp_add_cb_{name}({name}_t);")
			new_contents.append(f"bool ppp_remove_cb_{name}({name}_t);")
			# void ppp_add_cb_{cb_name}(void (*)({cb_args}))
		elif "PPP_CB_TYPEDEF" in line:
			raise Exception(f"Failed to parse: {line}")
		else:
			new_contents.append(line.strip())
	return "\n".join(new_contents)

def handle_python(arch, total):
	syscalls2_lookup = {
		"i386": "syscalls_ext_typedefs_x86.h",
		"x86_64": "syscalls_ext_typedefs_x64.h",
		"arm": "syscalls_ext_typedefs_arm.h",
		"aarch64": "syscalls_ext_typedefs_arm64.h",
		"mips": "syscalls_ext_typedefs_mips.h",
		"mipsel": "syscalls_ext_typedefs_mips.h",
		"mips64": "syscalls_ext_typedefs_mips64.h",
		"mips64el": "syscalls_ext_typedefs_mips64.h",
	}
	ffibuilder = FFI()
	ppp_headers = [
		"syscalls2/syscalls2_info.h",
		"syscalls2/generated/syscalls_ext_typedefs.h",
		"osi/osi_types.h",
		"osi/os_intro.h",
		"proc_start_linux/proc_start_linux.h",
		"hypercaller/hypercaller.h",
		"proc_start_linux/proc_start_linux_ppp.h",
	]
	for header in ppp_headers:
		total += copy_ppp_header(join(plugin_dir, header))

	syscalls2_val = syscalls2_lookup.get(arch, None)
	if syscalls2_val:
		total += copy_ppp_header(join(plugin_dir, f"syscalls2/generated/{syscalls2_lookup[arch]}"))
	int_fns = glob(f"{plugin_dir}/**/*_int_fns.h", recursive=True)
	for ints in int_fns:
		pdir = Path(ints).relative_to(plugin_dir)
		total += copy_ppp_header(join(plugin_dir, pdir))
	# with open(f"panda_python_{arch}.h","w") as f:
		# f.write(total)
	mod = f"pandare2.autogen._pandare_ffi_{arch}_softmmu"
	ffibuilder.set_source(mod, None)
	ffibuilder.cdef(total, override=True)
	ffibuilder.compile(debug=True)
